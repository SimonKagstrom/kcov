<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Coverage - frodo</title>
  <link rel="stylesheet" type="text/css" href="bcov.css"/>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="title">Coverage Report</td></tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr>
    <td width="100%">
      <table cellpadding="1" border="0" width="100%">
        <tr>
          <td class="headerItem" width="20%">Command:</td>
          <td class="headerValue" width="80%" colspan=6>frodo</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Date:</td>
          <td class="headerValue" width="15%">2012-06-16 11:50:06</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Instrumented&nbsp;lines:</td>
          <td class="headerValue" width="10%">391</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Code&nbsp;covered:</td>
          <td class="coverPerLeftMed" width="15%">36.6%</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Executed&nbsp;lines:</td>
          <td class="headerValue" width="10%">143</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
</table>
<pre class="source">
<span class="lineNum">    1</span>              : &#047;*  </span>
<span class="lineNum">    2</span>              :  *  Display.cpp - C64 graphics display, emulator window handling  </span>
<span class="lineNum">    3</span>              :  *  </span>
<span class="lineNum">    4</span>              :  *  Frodo (C) 1994-1997,2002-2005 Christian Bauer  </span>
<span class="lineNum">    5</span>              :  *  </span>
<span class="lineNum">    6</span>              :  *  This program is free software; you can redistribute it and&#047;or modify  </span>
<span class="lineNum">    7</span>              :  *  it under the terms of the GNU General Public License as published by  </span>
<span class="lineNum">    8</span>              :  *  the Free Software Foundation; either version 2 of the License, or  </span>
<span class="lineNum">    9</span>              :  *  (at your option) any later version.  </span>
<span class="lineNum">   10</span>              :  *  </span>
<span class="lineNum">   11</span>              :  *  This program is distributed in the hope that it will be useful,  </span>
<span class="lineNum">   12</span>              :  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  </span>
<span class="lineNum">   13</span>              :  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  </span>
<span class="lineNum">   14</span>              :  *  GNU General Public License for more details.  </span>
<span class="lineNum">   15</span>              :  *  </span>
<span class="lineNum">   16</span>              :  *  You should have received a copy of the GNU General Public License  </span>
<span class="lineNum">   17</span>              :  *  along with this program; if not, write to the Free Software  </span>
<span class="lineNum">   18</span>              :  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  </span>
<span class="lineNum">   19</span>              :  *&#047;  </span>
<span class="lineNum">   20</span>              :   </span>
<span class="lineNum">   21</span>              : #include &quot;sysdeps.h&quot;  </span>
<span class="lineNum">   22</span>              : #if defined(GEKKO)  </span>
<span class="lineNum">   23</span>              : # include &lt;ogc&#047;system.h&gt;  </span>
<span class="lineNum">   24</span>              : #endif  </span>
<span class="lineNum">   25</span>              :   </span>
<span class="lineNum">   26</span>              : #include &quot;Display.h&quot;  </span>
<span class="lineNum">   27</span>              : #include &quot;Version.h&quot;  </span>
<span class="lineNum">   28</span>              : #include &quot;main.h&quot;  </span>
<span class="lineNum">   29</span>              : #include &quot;Prefs.h&quot;  </span>
<span class="lineNum">   30</span>              : #include &quot;C64.h&quot;  </span>
<span class="lineNum">   31</span>              : #include &quot;CIA.h&quot;  </span>
<span class="lineNum">   32</span>              : #include &quot;utils.hh&quot;  </span>
<span class="lineNum">   33</span>              :   </span>
<span class="lineNum">   34</span>              : #include &quot;gui&#047;gui.hh&quot;  </span>
<span class="lineNum">   35</span>              : #include &quot;gui&#047;status_bar.hh&quot;  </span>
<span class="lineNum">   36</span>              : #include &quot;gui&#047;virtual_keyboard.hh&quot;  </span>
<span class="lineNum">   37</span>              :   </span>
<span class="lineNum">   38</span>              : &#047;&#047; LED states  </span>
<span class="lineNum">   39</span>              : enum {  </span>
<span class="lineNum">   40</span>              : 	LED_OFF,		&#047;&#047; LED off  </span>
<span class="lineNum">   41</span>              : 	LED_ON,			&#047;&#047; LED on (green)  </span>
<span class="lineNum">   42</span>              : 	LED_ERROR_ON,	&#047;&#047; LED blinking (red), currently on  </span>
<span class="lineNum">   43</span>              : 	LED_ERROR_OFF	&#047;&#047; LED blinking, currently off  </span>
<span class="lineNum">   44</span>              : };  </span>
<span class="lineNum">   45</span>              :   </span>
<span class="lineNum">   46</span>              :   </span>
<span class="lineNum">   47</span>              : #define USE_PEPTO_COLORS 1  </span>
<span class="lineNum">   48</span>              :   </span>
<span class="lineNum">   49</span>              : #ifdef USE_PEPTO_COLORS  </span>
<span class="lineNum">   50</span>              :   </span>
<span class="lineNum">   51</span>              : &#047;&#047; C64 color palette  </span>
<span class="lineNum">   52</span>              : &#047;&#047; Values based on measurements by Philip &quot;Pepto&quot; Timmermann &lt;pepto@pepto.de&gt;  </span>
<span class="lineNum">   53</span>              : &#047;&#047; (see http:&#047;&#047;www.pepto.de&#047;projects&#047;colorvic&#047;)  </span>
<span class="lineNum">   54</span>              : const uint8 palette_red[16] = {  </span>
<span class="lineNum">   55</span>              : 	0x00, 0xff, 0x86, 0x4c, 0x88, 0x35, 0x20, 0xcf, 0x88, 0x40, 0xcb, 0x34, 0x68, 0x8b, 0x68, 0xa1  </span>
<span class="lineNum">   56</span>              : };  </span>
<span class="lineNum">   57</span>              :   </span>
<span class="lineNum">   58</span>              : const uint8 palette_green[16] = {  </span>
<span class="lineNum">   59</span>              : 	0x00, 0xff, 0x19, 0xc1, 0x17, 0xac, 0x07, 0xf2, 0x3e, 0x2a, 0x55, 0x34, 0x68, 0xff, 0x4a, 0xa1  </span>
<span class="lineNum">   60</span>              : };  </span>
<span class="lineNum">   61</span>              :   </span>
<span class="lineNum">   62</span>              : const uint8 palette_blue[16] = {  </span>
<span class="lineNum">   63</span>              : 	0x00, 0xff, 0x01, 0xe3, 0xbd, 0x0a, 0xc0, 0x2d, 0x00, 0x00, 0x37, 0x34, 0x68, 0x59, 0xff, 0xa1  </span>
<span class="lineNum">   64</span>              : };  </span>
<span class="lineNum">   65</span>              :   </span>
<span class="lineNum">   66</span>              : #else  </span>
<span class="lineNum">   67</span>              :   </span>
<span class="lineNum">   68</span>              : &#047;&#047; C64 color palette (traditional Frodo colors)  </span>
<span class="lineNum">   69</span>              : const uint8 palette_red[16] = {  </span>
<span class="lineNum">   70</span>              : 	0x00, 0xff, 0x99, 0x00, 0xcc, 0x44, 0x11, 0xff, 0xaa, 0x66, 0xff, 0x40, 0x80, 0x66, 0x77, 0xc0  </span>
<span class="lineNum">   71</span>              : };  </span>
<span class="lineNum">   72</span>              :   </span>
<span class="lineNum">   73</span>              : const uint8 palette_green[16] = {  </span>
<span class="lineNum">   74</span>              : 	0x00, 0xff, 0x00, 0xff, 0x00, 0xcc, 0x00, 0xdd, 0x55, 0x33, 0x66, 0x40, 0x80, 0xff, 0x77, 0xc0  </span>
<span class="lineNum">   75</span>              : };  </span>
<span class="lineNum">   76</span>              :   </span>
<span class="lineNum">   77</span>              : const uint8 palette_blue[16] = {  </span>
<span class="lineNum">   78</span>              : 	0x00, 0xff, 0x00, 0xcc, 0xcc, 0x44, 0x99, 0x00, 0x00, 0x00, 0x66, 0x40, 0x80, 0x66, 0xff, 0xc0  </span>
<span class="lineNum">   79</span>              : };  </span>
<span class="lineNum">   80</span>              :   </span>
<span class="lineNum">   81</span>              : #endif  </span>
<span class="lineNum">   82</span>              :   </span>
<span class="lineNum">   83</span>              :   </span>
<span class="lineNum">   84</span>              : &#047;*  </span>
<span class="lineNum">   85</span>              :  *  Update drive LED display (deferred until Update())  </span>
<span class="lineNum">   86</span>              :  *&#047;  </span>
<span class="lineNum">   87</span>              :   </span>
<span class="lineNum">   88</span>              : void C64Display::UpdateLEDs(int l0, int l1, int l2, int l3)  </span>
<span class="lineNum">   89</span><span class="lineNoCov">      0  /   2: {  </span>
<span class="lineNum">   90</span><span class="lineNoCov">      0  /   1: 	led_state[0] = l0;  </span>
<span class="lineNum">   91</span><span class="lineNoCov">      0  /   1: 	led_state[1] = l1;  </span>
<span class="lineNum">   92</span><span class="lineNoCov">      0  /   1: 	led_state[2] = l2;  </span>
<span class="lineNum">   93</span><span class="lineNoCov">      0  /   1: 	led_state[3] = l3;  </span>
<span class="lineNum">   94</span><span class="lineNoCov">      0  /   1: }  </span>
<span class="lineNum">   95</span>              :   </span>
<span class="lineNum">   96</span>              :   </span>
<span class="lineNum">   97</span>              : &#047;&#047; Display surface  </span>
<span class="lineNum">   98</span>              : static Uint8 screen[DISPLAY_X * DISPLAY_Y];  </span>
<span class="lineNum">   99</span>              : static int screen_bits_per_pixel;  </span>
<span class="lineNum">  100</span>              :   </span>
<span class="lineNum">  101</span>              : static SDL_Window *window;  </span>
<span class="lineNum">  102</span>              : SDL_PixelFormat *pixel_format = NULL;  </span>
<span class="lineNum">  103</span>              : SDL_Renderer *renderer = NULL;  </span>
<span class="lineNum">  104</span>              : SDL_Texture *screen_texture = NULL;  </span>
<span class="lineNum">  105</span>              : SDL_Surface *real_screen = NULL;  </span>
<span class="lineNum">  106</span>              :   </span>
<span class="lineNum">  107</span>              : &#047;&#047; Keyboard  </span>
<span class="lineNum">  108</span>              : static bool num_locked = false;  </span>
<span class="lineNum">  109</span>              :   </span>
<span class="lineNum">  110</span>              : &#047;&#047; SDL joysticks  </span>
<span class="lineNum">  111</span>              : static SDL_Joystick *joy[2] = {NULL, NULL};  </span>
<span class="lineNum">  112</span>              :   </span>
<span class="lineNum">  113</span>              : static Uint16 palette_16[PALETTE_SIZE];  </span>
<span class="lineNum">  114</span>              : static Uint32 palette_32[PALETTE_SIZE];  </span>
<span class="lineNum">  115</span>              : SDL_Color sdl_palette[PALETTE_SIZE];  </span>
<span class="lineNum">  116</span>              :   </span>
<span class="lineNum">  117</span>              : int FULL_DISPLAY_X = 640;  </span>
<span class="lineNum">  118</span>              : int FULL_DISPLAY_Y = 480;  </span>
<span class="lineNum">  119</span>              :   </span>
<span class="lineNum">  120</span>              : &#047;*  </span>
<span class="lineNum">  121</span>              :   C64 keyboard matrix:  </span>
<span class="lineNum">  122</span>              :   </span>
<span class="lineNum">  123</span>              :     Bit 7   6   5   4   3   2   1   0  </span>
<span class="lineNum">  124</span>              :   0    CUD  F5  F3  F1  F7 CLR RET DEL  </span>
<span class="lineNum">  125</span>              :   1    SHL  E   S   Z   4   A   W   3  </span>
<span class="lineNum">  126</span>              :   2     X   T   F   C   6   D   R   5  </span>
<span class="lineNum">  127</span>              :   3     V   U   H   B   8   G   Y   7  </span>
<span class="lineNum">  128</span>              :   4     N   O   K   M   0   J   I   9  </span>
<span class="lineNum">  129</span>              :   5     ,   @   :   .   -   L   P   +  </span>
<span class="lineNum">  130</span>              :   6     &#047;   ^   =  SHR HOM  ;   *   ï¿½  </span>
<span class="lineNum">  131</span>              :   7    R&#047;S  Q   C= SPC  2  CTL  &lt;-  1  </span>
<span class="lineNum">  132</span>              : *&#047;  </span>
<span class="lineNum">  133</span>              :   </span>
<span class="lineNum">  134</span>              : #define MATRIX(a,b) (((a) &lt;&lt; 3) | (b))  </span>
<span class="lineNum">  135</span>              :   </span>
<span class="lineNum">  136</span>              :   </span>
<span class="lineNum">  137</span>              : &#047;*  </span>
<span class="lineNum">  138</span>              :  *  Open window  </span>
<span class="lineNum">  139</span>              :  *&#047;  </span>
<span class="lineNum">  140</span>              :   </span>
<span class="lineNum">  141</span>              : int init_graphics(void)  </span>
<span class="lineNum">  142</span><span class="lineCov">      1  /   1: {  </span>
<span class="lineNum">  143</span>              : 	Uint32 rmask, gmask, bmask, amask;  </span>
<span class="lineNum">  144</span>              : 	const SDL_VideoInfo *info;  </span>
<span class="lineNum">  145</span>              :   </span>
<span class="lineNum">  146</span>              : 	&#047;* SDL interprets each pixel as a 32-bit number, so our masks must depend  </span>
<span class="lineNum">  147</span>              :            on the endianness (byte order) of the machine *&#047;  </span>
<span class="lineNum">  148</span>              : #if SDL_BYTEORDER == SDL_BIG_ENDIAN  </span>
<span class="lineNum">  149</span>              : 	rmask = 0xff000000;  </span>
<span class="lineNum">  150</span>              : 	gmask = 0x00ff0000;  </span>
<span class="lineNum">  151</span>              : 	bmask = 0x0000ff00;  </span>
<span class="lineNum">  152</span>              : 	amask = 0x000000ff;  </span>
<span class="lineNum">  153</span>              : #else  </span>
<span class="lineNum">  154</span>              :      	rmask = 0x000000ff;  </span>
<span class="lineNum">  155</span>              : 	gmask = 0x0000ff00;  </span>
<span class="lineNum">  156</span>              : 	bmask = 0x00ff0000;  </span>
<span class="lineNum">  157</span>              : 	amask = 0xff000000;  </span>
<span class="lineNum">  158</span>              : #endif  </span>
<span class="lineNum">  159</span>              :   </span>
<span class="lineNum">  160</span>              : 	&#047;&#047; Open window  </span>
<span class="lineNum">  161</span><span class="lineCov">      1  /   1: 	SDL_ShowCursor(SDL_DISABLE);  </span>
<span class="lineNum">  162</span>              :   </span>
<span class="lineNum">  163</span><span class="lineCov">      1  /   1: 	SDL_FreeSurface(real_screen);  </span>
<span class="lineNum">  164</span>              :   </span>
<span class="lineNum">  165</span>              : 	window = SDL_CreateWindow(&quot;c64-network.org&quot;,  </span>
<span class="lineNum">  166</span>              : 			SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,  </span>
<span class="lineNum">  167</span>              : 			FULL_DISPLAY_X, FULL_DISPLAY_Y,  </span>
<span class="lineNum">  168</span><span class="lineCov">      2  /   2: 			SDL_WINDOW_SHOWN);  </span>
<span class="lineNum">  169</span><span class="linePartCov">      2  /   4: 	panic_if(!window,  </span>
<span class="lineNum">  170</span>              : 			&quot;Can&#039;t create SDL window: %s&#092;n&quot;, SDL_GetError());  </span>
<span class="lineNum">  171</span>              :   </span>
<span class="lineNum">  172</span><span class="lineCov">      2  /   2: 	pixel_format = SDL_AllocFormat(SDL_GetWindowPixelFormat(window));  </span>
<span class="lineNum">  173</span>              :   </span>
<span class="lineNum">  174</span>              : 	&#047;&#047; Setup SDL renderer  </span>
<span class="lineNum">  175</span><span class="lineCov">      3  /   3: 	renderer = SDL_CreateRenderer(window, -1, 0);  </span>
<span class="lineNum">  176</span><span class="linePartCov">      2  /   4: 	panic_if(!renderer,  </span>
<span class="lineNum">  177</span>              : 			&quot;Can&#039;t create SDL renderer: %s&#092;n&quot;, SDL_GetError());  </span>
<span class="lineNum">  178</span>              :   </span>
<span class="lineNum">  179</span>              : 	&#047;&#047; And a texture to draw to  </span>
<span class="lineNum">  180</span>              : 	screen_texture = SDL_CreateTexture(renderer,  </span>
<span class="lineNum">  181</span>              :             SDL_PIXELFORMAT_ARGB8888,  </span>
<span class="lineNum">  182</span>              :             SDL_TEXTUREACCESS_STREAMING,  </span>
<span class="lineNum">  183</span><span class="lineCov">      2  /   2:             FULL_DISPLAY_X, FULL_DISPLAY_Y);  </span>
<span class="lineNum">  184</span><span class="linePartCov">      2  /   4: 	panic_if(!screen_texture,  </span>
<span class="lineNum">  185</span>              : 			&quot;Can&#039;t create SDL texture: %s&#092;n&quot;, SDL_GetError());  </span>
<span class="lineNum">  186</span>              :   </span>
<span class="lineNum">  187</span>              : 	real_screen = SDL_CreateRGBSurfaceFrom(NULL,  </span>
<span class="lineNum">  188</span>              : 			FULL_DISPLAY_X, FULL_DISPLAY_Y,  </span>
<span class="lineNum">  189</span>              : 			32, 0,  </span>
<span class="lineNum">  190</span>              : 			0x00FF0000,  </span>
<span class="lineNum">  191</span>              : 			0x0000FF00,  </span>
<span class="lineNum">  192</span>              : 			0x000000FF,  </span>
<span class="lineNum">  193</span><span class="lineCov">      2  /   2: 			0xFF000000);  </span>
<span class="lineNum">  194</span><span class="linePartCov">      2  /   4: 	panic_if(!real_screen,  </span>
<span class="lineNum">  195</span>              : 			&quot;&#092;n&#092;nCannot initialize video: %s&#092;n&quot;, SDL_GetError());  </span>
<span class="lineNum">  196</span>              :   </span>
<span class="lineNum">  197</span><span class="lineCov">      1  /   1: 	info = SDL_GetVideoInfo();  </span>
<span class="lineNum">  198</span><span class="lineCov">      1  /   1: 	screen_bits_per_pixel = info-&gt;vfmt-&gt;BitsPerPixel;  </span>
<span class="lineNum">  199</span>              :   </span>
<span class="lineNum">  200</span>              : 	return 1;  </span>
<span class="lineNum">  201</span><span class="lineCov">      1  /   1: }  </span>
<span class="lineNum">  202</span>              :   </span>
<span class="lineNum">  203</span>              :   </span>
<span class="lineNum">  204</span>              : &#047;*  </span>
<span class="lineNum">  205</span>              :  *  Display constructor  </span>
<span class="lineNum">  206</span>              :  *&#047;  </span>
<span class="lineNum">  207</span>              :   </span>
<span class="lineNum">  208</span><span class="lineCov">      3  /   3: C64Display::C64Display(C64 *the_c64) : TheC64(the_c64)  </span>
<span class="lineNum">  209</span>              : {  </span>
<span class="lineNum">  210</span><span class="lineCov">      1  /   1: 	quit_requested = false;  </span>
<span class="lineNum">  211</span><span class="lineCov">      1  /   1: 	speedometer_string[0] = 0;  </span>
<span class="lineNum">  212</span><span class="lineCov">      1  /   1: 	networktraffic_string[0] = 0;  </span>
<span class="lineNum">  213</span><span class="lineCov">      1  /   1: 	this-&gt;text_message_send = NULL;  </span>
<span class="lineNum">  214</span>              :   </span>
<span class="lineNum">  215</span>              : 	&#047;&#047; Open window  </span>
<span class="lineNum">  216</span><span class="lineCov">      1  /   1: 	SDL_WM_SetCaption(VERSION_STRING, &quot;Frodo&quot;);  </span>
<span class="lineNum">  217</span>              : 	&#047;&#047; LEDs off  </span>
<span class="lineNum">  218</span>              : 	for (int i=0; i&lt;4; i++)  </span>
<span class="lineNum">  219</span><span class="lineCov">      1  /   1: 		led_state[i] = old_led_state[i] = LED_OFF;  </span>
<span class="lineNum">  220</span><span class="lineCov">      1  /   1: }  </span>
<span class="lineNum">  221</span>              :   </span>
<span class="lineNum">  222</span>              :   </span>
<span class="lineNum">  223</span>              : &#047;*  </span>
<span class="lineNum">  224</span>              :  *  Display destructor  </span>
<span class="lineNum">  225</span>              :  *&#047;  </span>
<span class="lineNum">  226</span>              :   </span>
<span class="lineNum">  227</span><span class="lineCov">      1  /   1: C64Display::~C64Display()  </span>
<span class="lineNum">  228</span>              : {  </span>
<span class="lineNum">  229</span><span class="lineCov">      1  /   1: 	SDL_Quit();  </span>
<span class="lineNum">  230</span><span class="lineCov">      1  /   1: }  </span>
<span class="lineNum">  231</span>              :   </span>
<span class="lineNum">  232</span>              :   </span>
<span class="lineNum">  233</span>              : &#047;*  </span>
<span class="lineNum">  234</span>              :  *  Prefs may have changed  </span>
<span class="lineNum">  235</span>              :  *&#047;  </span>
<span class="lineNum">  236</span>              :   </span>
<span class="lineNum">  237</span>              : void C64Display::NewPrefs(Prefs *prefs)  </span>
<span class="lineNum">  238</span><span class="lineCov">      1  /   1: {  </span>
<span class="lineNum">  239</span><span class="lineCov">      1  /   1: }  </span>
<span class="lineNum">  240</span>              :   </span>
<span class="lineNum">  241</span>              :   </span>
<span class="lineNum">  242</span>              : &#047;*  </span>
<span class="lineNum">  243</span>              :  *  Redraw bitmap  </span>
<span class="lineNum">  244</span>              :  *&#047;  </span>
<span class="lineNum">  245</span><span class="lineCov">      1  /   1: void C64Display::Update_32(uint8 *src_pixels)  </span>
<span class="lineNum">  246</span><span class="lineCov">      1  /   1: {  </span>
<span class="lineNum">  247</span>              : 	const Uint16 src_pitch = DISPLAY_X;  </span>
<span class="lineNum">  248</span><span class="lineCov">      2  /   2: 	const int x_border = (DISPLAY_X - FULL_DISPLAY_X &#047; 2) &#047; 2;  </span>
<span class="lineNum">  249</span><span class="lineCov">      4  /   4: 	const int y_border = (DISPLAY_Y - FULL_DISPLAY_Y &#047; 2) &#047; 2;  </span>
<span class="lineNum">  250</span><span class="lineCov">      2  /   2: 	Uint32 *dst_pixels = (Uint32*)real_screen-&gt;pixels;  </span>
<span class="lineNum">  251</span><span class="lineCov">      2  /   2: 	const int dst_pitch = real_screen-&gt;pitch &#047; sizeof(Uint32);  </span>
<span class="lineNum">  252</span>              :   </span>
<span class="lineNum">  253</span>              : 	&#047;* Center, double size *&#047;  </span>
<span class="lineNum">  254</span><span class="lineCov">      4  /   4: 	for (int y = y_border; y &lt; (FULL_DISPLAY_Y&#047;2) + y_border; y++)  </span>
<span class="lineNum">  255</span>              : 	{  </span>
<span class="lineNum">  256</span><span class="lineCov">      3  /   3: 		for (int x = x_border; x &lt; (FULL_DISPLAY_X &#047; 2 + x_border); x++)  </span>
<span class="lineNum">  257</span>              : 		{  </span>
<span class="lineNum">  258</span>              : 			int src_off = y * src_pitch + x;  </span>
<span class="lineNum">  259</span>              : 			int dst_off = ((y * 2 - y_border * 2) * dst_pitch + (x * 2 - x_border * 2));  </span>
<span class="lineNum">  260</span><span class="lineCov">      2  /   2: 			Uint32 v = palette_32[src_pixels[src_off]];  </span>
<span class="lineNum">  261</span>              :   </span>
<span class="lineNum">  262</span><span class="lineCov">      1  /   1: 			dst_pixels[ dst_off ] = v;  </span>
<span class="lineNum">  263</span><span class="lineCov">      1  /   1: 			dst_pixels[ dst_off + 1 ] = v;  </span>
<span class="lineNum">  264</span><span class="lineCov">      1  /   1: 			dst_pixels[ dst_off + dst_pitch ] = v;  </span>
<span class="lineNum">  265</span><span class="lineCov">      1  /   1: 			dst_pixels[ dst_off + dst_pitch + 1] = v;  </span>
<span class="lineNum">  266</span>              : 		}  </span>
<span class="lineNum">  267</span>              : 	}  </span>
<span class="lineNum">  268</span><span class="lineCov">      1  /   1: }  </span>
<span class="lineNum">  269</span>              :   </span>
<span class="lineNum">  270</span><span class="lineNoCov">      0  /   3: void C64Display::Update_16(uint8 *src_pixels)  </span>
<span class="lineNum">  271</span><span class="lineNoCov">      0  /   1: {  </span>
<span class="lineNum">  272</span>              : 	const Uint16 src_pitch = DISPLAY_X;  </span>
<span class="lineNum">  273</span>              :   </span>
<span class="lineNum">  274</span><span class="lineNoCov">      0  /   4: 	const int x_border = (DISPLAY_X - FULL_DISPLAY_X &#047; 2) &#047; 2;  </span>
<span class="lineNum">  275</span><span class="lineNoCov">      0  /   3: 	const int y_border = (DISPLAY_Y - FULL_DISPLAY_Y &#047; 2) &#047; 2;  </span>
<span class="lineNum">  276</span><span class="lineNoCov">      0  /   3: 	Uint16 *dst_pixels = (Uint16*)real_screen-&gt;pixels;  </span>
<span class="lineNum">  277</span><span class="lineNoCov">      0  /   2: 	const Uint16 dst_pitch = real_screen-&gt;pitch &#047; sizeof(Uint16);  </span>
<span class="lineNum">  278</span>              :   </span>
<span class="lineNum">  279</span>              : 	&#047;* Center, double size *&#047;  </span>
<span class="lineNum">  280</span><span class="lineNoCov">      0  /   4: 	for (int y = y_border; y &lt; (FULL_DISPLAY_Y&#047;2) + y_border; y++)  </span>
<span class="lineNum">  281</span>              : 	{  </span>
<span class="lineNum">  282</span><span class="lineNoCov">      0  /   4: 		for (int x = x_border; x &lt; (FULL_DISPLAY_X &#047; 2 + x_border); x++)  </span>
<span class="lineNum">  283</span>              : 		{  </span>
<span class="lineNum">  284</span>              : 			int src_off = y * src_pitch + x;  </span>
<span class="lineNum">  285</span>              : 			int dst_off = ((y * 2 - y_border * 2) * dst_pitch + (x * 2 - x_border * 2));  </span>
<span class="lineNum">  286</span><span class="lineNoCov">      0  /   2: 			Uint16 v = palette_16[src_pixels[src_off]];  </span>
<span class="lineNum">  287</span>              :   </span>
<span class="lineNum">  288</span><span class="lineNoCov">      0  /   1: 			dst_pixels[ dst_off ] = v;  </span>
<span class="lineNum">  289</span><span class="lineNoCov">      0  /   1: 			dst_pixels[ dst_off + 1 ] = v;  </span>
<span class="lineNum">  290</span><span class="lineNoCov">      0  /   1: 			dst_pixels[ dst_off + dst_pitch ] = v;  </span>
<span class="lineNum">  291</span><span class="lineNoCov">      0  /   1: 			dst_pixels[ dst_off + dst_pitch + 1] = v;  </span>
<span class="lineNum">  292</span>              : 		}  </span>
<span class="lineNum">  293</span>              : 	}  </span>
<span class="lineNum">  294</span><span class="lineNoCov">      0  /   1: }  </span>
<span class="lineNum">  295</span>              :   </span>
<span class="lineNum">  296</span>              : void C64Display::Update(uint8 *src_pixels)  </span>
<span class="lineNum">  297</span><span class="lineCov">      2  /   2: {  </span>
<span class="lineNum">  298</span><span class="lineCov">      2  /   2: 	SDL_RenderClear(renderer);  </span>
<span class="lineNum">  299</span>              : 	SDL_LockTexture(screen_texture, NULL,  </span>
<span class="lineNum">  300</span>              : 	                &amp;real_screen-&gt;pixels,  </span>
<span class="lineNum">  301</span><span class="lineCov">      1  /   1: 	                &amp;real_screen-&gt;pitch);  </span>
<span class="lineNum">  302</span>              :   </span>
<span class="lineNum">  303</span><span class="lineCov">      1  /   1: 	if (screen_bits_per_pixel == 16)  </span>
<span class="lineNum">  304</span><span class="lineNoCov">      0  /   1: 		this-&gt;Update_16(src_pixels);  </span>
<span class="lineNum">  305</span>              : 	else  </span>
<span class="lineNum">  306</span><span class="lineCov">      1  /   1: 		this-&gt;Update_32(src_pixels);  </span>
<span class="lineNum">  307</span>              :   </span>
<span class="lineNum">  308</span><span class="lineCov">      1  /   1: 	Gui::gui-&gt;draw(real_screen);  </span>
<span class="lineNum">  309</span>              :   </span>
<span class="lineNum">  310</span><span class="lineCov">      1  /   1: 	SDL_UnlockTexture(screen_texture);  </span>
<span class="lineNum">  311</span><span class="lineCov">      1  /   1: 	SDL_RenderCopy(renderer, screen_texture, NULL, NULL);  </span>
<span class="lineNum">  312</span><span class="lineCov">      2  /   2: 	SDL_RenderPresent(renderer);  </span>
<span class="lineNum">  313</span><span class="lineCov">      1  /   1: }  </span>
<span class="lineNum">  314</span>              :   </span>
<span class="lineNum">  315</span>              : void C64Display::Update()  </span>
<span class="lineNum">  316</span><span class="lineCov">      1  /   1: {  </span>
<span class="lineNum">  317</span><span class="lineCov">      1  /   1: 	this-&gt;Update((Uint8*)screen);  </span>
<span class="lineNum">  318</span><span class="lineCov">      1  /   1: }  </span>
<span class="lineNum">  319</span>              :   </span>
<span class="lineNum">  320</span><span class="lineNoCov">      0  /   1: SDL_Surface *C64Display::SurfaceFromC64Display()  </span>
<span class="lineNum">  321</span><span class="lineCov">      1  /   1: {  </span>
<span class="lineNum">  322</span>              : 	Uint32 rmask,gmask,bmask,amask;  </span>
<span class="lineNum">  323</span>              : 	SDL_Surface *out;  </span>
<span class="lineNum">  324</span>              :   </span>
<span class="lineNum">  325</span>              : #if SDL_BYTEORDER == SDL_BIG_ENDIAN  </span>
<span class="lineNum">  326</span>              :     rmask = 0xff000000;  </span>
<span class="lineNum">  327</span>              :     gmask = 0x00ff0000;  </span>
<span class="lineNum">  328</span>              :     bmask = 0x0000ff00;  </span>
<span class="lineNum">  329</span>              :     amask = 0x000000ff;  </span>
<span class="lineNum">  330</span>              : #else  </span>
<span class="lineNum">  331</span>              :     rmask = 0x000000ff;  </span>
<span class="lineNum">  332</span>              :     gmask = 0x0000ff00;  </span>
<span class="lineNum">  333</span>              :     bmask = 0x00ff0000;  </span>
<span class="lineNum">  334</span>              :     amask = 0xff000000;  </span>
<span class="lineNum">  335</span>              : #endif  </span>
<span class="lineNum">  336</span>              :   </span>
<span class="lineNum">  337</span>              : 	out = SDL_CreateRGBSurface(SDL_SWSURFACE, DISPLAY_X &#047; 2, DISPLAY_Y &#047; 2, 8,  </span>
<span class="lineNum">  338</span><span class="lineCov">      2  /   2: 			rmask, gmask, bmask, amask);  </span>
<span class="lineNum">  339</span><span class="lineCov">      2  /   2: 	if (!out)  </span>
<span class="lineNum">  340</span>              : 		return NULL;  </span>
<span class="lineNum">  341</span>              :   </span>
<span class="lineNum">  342</span><span class="lineNoCov">      0  /   2: 	Uint8 *dst_pixels = (Uint8*)out-&gt;pixels;  </span>
<span class="lineNum">  343</span>              : 	const Uint16 src_pitch = DISPLAY_X;  </span>
<span class="lineNum">  344</span>              :   </span>
<span class="lineNum">  345</span>              : 	&#047;* Draw 1-1 *&#047;  </span>
<span class="lineNum">  346</span><span class="lineNoCov">      0  /   2: 	for (int y = 0; y &lt; DISPLAY_Y &#047; 2; y++)  </span>
<span class="lineNum">  347</span>              : 	{  </span>
<span class="lineNum">  348</span><span class="lineNoCov">      0  /   3: 		for (int x = 0; x &lt; DISPLAY_X &#047; 2; x++)  </span>
<span class="lineNum">  349</span>              : 		{  </span>
<span class="lineNum">  350</span>              : 			int src_off = (y * 2) * src_pitch + (x * 2);  </span>
<span class="lineNum">  351</span><span class="lineNoCov">      0  /   2: 			int dst_off = y * out-&gt;pitch + x;  </span>
<span class="lineNum">  352</span>              : 			Uint8 v = screen[src_off];  </span>
<span class="lineNum">  353</span>              :   </span>
<span class="lineNum">  354</span><span class="lineNoCov">      0  /   3: 			dst_pixels[ dst_off ] = v;  </span>
<span class="lineNum">  355</span>              : 		}  </span>
<span class="lineNum">  356</span>              : 	}  </span>
<span class="lineNum">  357</span><span class="lineNoCov">      0  /   1: 	SDL_SetColors(out, sdl_palette, 0, PALETTE_SIZE);  </span>
<span class="lineNum">  358</span>              :   </span>
<span class="lineNum">  359</span>              : 	return out;  </span>
<span class="lineNum">  360</span><span class="lineCov">      1  /   1: }  </span>
<span class="lineNum">  361</span>              :   </span>
<span class="lineNum">  362</span>              : &#047;*  </span>
<span class="lineNum">  363</span>              :  *  Draw string into surface using the C64 ROM font  </span>
<span class="lineNum">  364</span>              :  *&#047;  </span>
<span class="lineNum">  365</span>              :   </span>
<span class="lineNum">  366</span>              : &#047;*  </span>
<span class="lineNum">  367</span>              :  *  Draw speedometer  </span>
<span class="lineNum">  368</span>              :  *&#047;  </span>
<span class="lineNum">  369</span>              :   </span>
<span class="lineNum">  370</span>              : void C64Display::Speedometer(int speed)  </span>
<span class="lineNum">  371</span><span class="lineNoCov">      0  /   1: {  </span>
<span class="lineNum">  372</span>              : 	static int delay = 0;  </span>
<span class="lineNum">  373</span>              :   </span>
<span class="lineNum">  374</span><span class="lineNoCov">      0  /   1: 	if (delay &gt;= 20) {  </span>
<span class="lineNum">  375</span><span class="lineNoCov">      0  /   1: 		delay = 0;  </span>
<span class="lineNum">  376</span><span class="lineNoCov">      0  /   2: 		sprintf(speedometer_string, &quot;%d%%&quot;, speed);  </span>
<span class="lineNum">  377</span>              : 	} else  </span>
<span class="lineNum">  378</span><span class="lineNoCov">      0  /   1: 		delay++;  </span>
<span class="lineNum">  379</span><span class="lineNoCov">      0  /   2: }  </span>
<span class="lineNum">  380</span>              :   </span>
<span class="lineNum">  381</span>              : void C64Display::NetworkTrafficMeter(float kb_per_s, bool is_throttled)  </span>
<span class="lineNum">  382</span><span class="lineNoCov">      0  /   2: {  </span>
<span class="lineNum">  383</span>              : 	snprintf(this-&gt;networktraffic_string, sizeof(this-&gt;networktraffic_string),  </span>
<span class="lineNum">  384</span><span class="lineNoCov">      0  /   5: 			&quot;%6.2f KB&#047;S%s&quot;, kb_per_s, is_throttled ? &quot; THROTTLED&quot; : &quot;&quot;);  </span>
<span class="lineNum">  385</span><span class="lineNoCov">      0  /   1: }  </span>
<span class="lineNum">  386</span>              :   </span>
<span class="lineNum">  387</span>              : &#047;*  </span>
<span class="lineNum">  388</span>              :  *  Return pointer to bitmap data  </span>
<span class="lineNum">  389</span>              :  *&#047;  </span>
<span class="lineNum">  390</span>              :   </span>
<span class="lineNum">  391</span>              : uint8 *C64Display::BitmapBase(void)  </span>
<span class="lineNum">  392</span><span class="lineCov">      2  /   2: {  </span>
<span class="lineNum">  393</span>              : 	return screen;  </span>
<span class="lineNum">  394</span><span class="lineCov">      2  /   2: }  </span>
<span class="lineNum">  395</span>              :   </span>
<span class="lineNum">  396</span>              :   </span>
<span class="lineNum">  397</span>              : &#047;*  </span>
<span class="lineNum">  398</span>              :  *  Return number of bytes per row  </span>
<span class="lineNum">  399</span>              :  *&#047;  </span>
<span class="lineNum">  400</span>              :   </span>
<span class="lineNum">  401</span>              : int C64Display::BitmapXMod(void)  </span>
<span class="lineNum">  402</span><span class="lineCov">      2  /   2: {  </span>
<span class="lineNum">  403</span>              : 	return DISPLAY_X;  </span>
<span class="lineNum">  404</span><span class="lineCov">      2  /   2: }  </span>
<span class="lineNum">  405</span>              :   </span>
<span class="lineNum">  406</span>              : void C64Display::FakeKeyPress(int kc, uint8 *CIA_key_matrix,  </span>
<span class="lineNum">  407</span>              : 		uint8 *CIA_rev_matrix)  </span>
<span class="lineNum">  408</span><span class="lineNoCov">      0  /   3: {  </span>
<span class="lineNum">  409</span>              : 	&#047;&#047; Clear matrices  </span>
<span class="lineNum">  410</span><span class="lineNoCov">      0  /   2:         for (int i = 0; i &lt; 8; i ++)  </span>
<span class="lineNum">  411</span>              :         {  </span>
<span class="lineNum">  412</span><span class="lineNoCov">      0  /   1:                 CIA_key_matrix[i] = 0xFF;  </span>
<span class="lineNum">  413</span><span class="lineNoCov">      0  /   1:                 CIA_rev_matrix[i] = 0xFF;  </span>
<span class="lineNum">  414</span>              :         }  </span>
<span class="lineNum">  415</span><span class="lineNoCov">      0  /   1:         if (kc != -1)  </span>
<span class="lineNum">  416</span>              :         	this-&gt;UpdateKeyMatrix(kc, false, CIA_key_matrix, CIA_rev_matrix,  </span>
<span class="lineNum">  417</span><span class="lineNoCov">      0  /   1:         			NULL);  </span>
<span class="lineNum">  418</span><span class="lineNoCov">      0  /   1: }  </span>
<span class="lineNum">  419</span>              :   </span>
<span class="lineNum">  420</span>              : void C64Display::UpdateKeyMatrix(int c64_key, bool key_up,  </span>
<span class="lineNum">  421</span>              : 		uint8 *key_matrix, uint8 *rev_matrix, uint8 *joystick)  </span>
<span class="lineNum">  422</span><span class="lineCov">      3  /   3: {  </span>
<span class="lineNum">  423</span><span class="lineCov">      1  /   1: 	bool shifted = c64_key &amp; 0x80;  </span>
<span class="lineNum">  424</span>              : 	int c64_byte;  </span>
<span class="lineNum">  425</span>              : 	int c64_bit;  </span>
<span class="lineNum">  426</span>              :   </span>
<span class="lineNum">  427</span><span class="lineCov">      2  /   2: 	c64_key &amp;= ~0x80;  </span>
<span class="lineNum">  428</span><span class="lineCov">      2  /   2: 	c64_byte = (c64_key &gt;&gt; 3) &amp; 7;  </span>
<span class="lineNum">  429</span><span class="lineCov">      1  /   1: 	c64_bit = c64_key &amp; 7;  </span>
<span class="lineNum">  430</span>              :   </span>
<span class="lineNum">  431</span>              : 	&#047;&#047; Handle joystick emulation  </span>
<span class="lineNum">  432</span><span class="lineCov">      1  /   1: 	if (joystick &amp;&amp; (c64_key &amp; 0x40)) {  </span>
<span class="lineNum">  433</span><span class="lineCov">      1  /   1: 		c64_key &amp;= 0x1f;  </span>
<span class="lineNum">  434</span><span class="lineCov">      1  /   1: 		if (key_up)  </span>
<span class="lineNum">  435</span><span class="lineCov">      1  /   1: 			*joystick |= c64_key;  </span>
<span class="lineNum">  436</span>              : 		else  </span>
<span class="lineNum">  437</span><span class="lineCov">      1  /   1: 			*joystick &amp;= ~c64_key;  </span>
<span class="lineNum">  438</span>              : 		return;  </span>
<span class="lineNum">  439</span>              : 	}  </span>
<span class="lineNum">  440</span>              :   </span>
<span class="lineNum">  441</span><span class="lineCov">      1  /   1: 	if (key_up) {  </span>
<span class="lineNum">  442</span><span class="lineCov">      1  /   1: 		if (shifted) {  </span>
<span class="lineNum">  443</span><span class="lineNoCov">      0  /   1: 			key_matrix[6] |= 0x10;  </span>
<span class="lineNum">  444</span><span class="lineNoCov">      0  /   1: 			rev_matrix[4] |= 0x40;  </span>
<span class="lineNum">  445</span>              : 		}  </span>
<span class="lineNum">  446</span><span class="lineCov">      1  /   1: 		key_matrix[c64_byte] |= (1 &lt;&lt; c64_bit);  </span>
<span class="lineNum">  447</span><span class="lineCov">      1  /   1: 		rev_matrix[c64_bit] |= (1 &lt;&lt; c64_byte);  </span>
<span class="lineNum">  448</span>              : 	} else {  </span>
<span class="lineNum">  449</span><span class="lineCov">      1  /   1: 		if (shifted) {  </span>
<span class="lineNum">  450</span><span class="lineNoCov">      0  /   1: 			key_matrix[6] &amp;= 0xef;  </span>
<span class="lineNum">  451</span><span class="lineNoCov">      0  /   1: 			rev_matrix[4] &amp;= 0xbf;  </span>
<span class="lineNum">  452</span>              : 		}  </span>
<span class="lineNum">  453</span><span class="lineCov">      1  /   1: 		key_matrix[c64_byte] &amp;= ~(1 &lt;&lt; c64_bit);  </span>
<span class="lineNum">  454</span><span class="lineCov">      1  /   1: 		rev_matrix[c64_bit] &amp;= ~(1 &lt;&lt; c64_byte);  </span>
<span class="lineNum">  455</span>              : 	}  </span>
<span class="lineNum">  456</span><span class="lineCov">      4  /   4: }  </span>
<span class="lineNum">  457</span>              :   </span>
<span class="lineNum">  458</span>              : &#047;*  </span>
<span class="lineNum">  459</span>              :  *  Poll the keyboard  </span>
<span class="lineNum">  460</span>              :  *&#047;  </span>
<span class="lineNum">  461</span>              :   </span>
<span class="lineNum">  462</span>              : void C64Display::TranslateKey(SDLKey key, bool key_up, uint8 *key_matrix,  </span>
<span class="lineNum">  463</span>              : 		uint8 *rev_matrix, uint8 *joystick)  </span>
<span class="lineNum">  464</span><span class="lineCov">      3  /   3: {  </span>
<span class="lineNum">  465</span>              : 	static bool shift_on = false;  </span>
<span class="lineNum">  466</span>              : 	int c64_key = -1;  </span>
<span class="lineNum">  467</span>              :   </span>
<span class="lineNum">  468</span><span class="linePartCov">     10  /  35: 	switch (key) {  </span>
<span class="lineNum">  469</span><span class="lineNoCov">      0  /   1: 		case SDLK_a: c64_key = MATRIX(1,2); break;  </span>
<span class="lineNum">  470</span><span class="lineNoCov">      0  /   1: 		case SDLK_b: c64_key = MATRIX(3,4); break;  </span>
<span class="lineNum">  471</span><span class="lineNoCov">      0  /   1: 		case SDLK_c: c64_key = MATRIX(2,4); break;  </span>
<span class="lineNum">  472</span><span class="lineNoCov">      0  /   1: 		case SDLK_d: c64_key = MATRIX(2,2); break;  </span>
<span class="lineNum">  473</span><span class="lineNoCov">      0  /   1: 		case SDLK_e: c64_key = MATRIX(1,6); break;  </span>
<span class="lineNum">  474</span><span class="lineNoCov">      0  /   1: 		case SDLK_f: c64_key = MATRIX(2,5); break;  </span>
<span class="lineNum">  475</span><span class="lineNoCov">      0  /   1: 		case SDLK_g: c64_key = MATRIX(3,2); break;  </span>
<span class="lineNum">  476</span><span class="lineNoCov">      0  /   1: 		case SDLK_h: c64_key = MATRIX(3,5); break;  </span>
<span class="lineNum">  477</span><span class="lineNoCov">      0  /   1: 		case SDLK_i: c64_key = MATRIX(4,1); break;  </span>
<span class="lineNum">  478</span><span class="lineNoCov">      0  /   1: 		case SDLK_j: c64_key = MATRIX(4,2); break;  </span>
<span class="lineNum">  479</span><span class="lineNoCov">      0  /   1: 		case SDLK_k: c64_key = MATRIX(4,5); break;  </span>
<span class="lineNum">  480</span><span class="lineNoCov">      0  /   1: 		case SDLK_l: c64_key = MATRIX(5,2); break;  </span>
<span class="lineNum">  481</span><span class="lineNoCov">      0  /   1: 		case SDLK_m: c64_key = MATRIX(4,4); break;  </span>
<span class="lineNum">  482</span><span class="lineNoCov">      0  /   1: 		case SDLK_n: c64_key = MATRIX(4,7); break;  </span>
<span class="lineNum">  483</span><span class="lineNoCov">      0  /   1: 		case SDLK_o: c64_key = MATRIX(4,6); break;  </span>
<span class="lineNum">  484</span><span class="lineNoCov">      0  /   1: 		case SDLK_p: c64_key = MATRIX(5,1); break;  </span>
<span class="lineNum">  485</span><span class="lineNoCov">      0  /   1: 		case SDLK_q: c64_key = MATRIX(7,6); break;  </span>
<span class="lineNum">  486</span><span class="lineNoCov">      0  /   1: 		case SDLK_r: c64_key = MATRIX(2,1); break;  </span>
<span class="lineNum">  487</span><span class="lineNoCov">      0  /   1: 		case SDLK_s: c64_key = MATRIX(1,5); break;  </span>
<span class="lineNum">  488</span><span class="lineNoCov">      0  /   1: 		case SDLK_t: c64_key = MATRIX(2,6); break;  </span>
<span class="lineNum">  489</span><span class="lineNoCov">      0  /   1: 		case SDLK_u: c64_key = MATRIX(3,6); break;  </span>
<span class="lineNum">  490</span><span class="lineNoCov">      0  /   1: 		case SDLK_v: c64_key = MATRIX(3,7); break;  </span>
<span class="lineNum">  491</span><span class="lineNoCov">      0  /   1: 		case SDLK_w: c64_key = MATRIX(1,1); break;  </span>
<span class="lineNum">  492</span><span class="lineNoCov">      0  /   1: 		case SDLK_x: c64_key = MATRIX(2,7); break;  </span>
<span class="lineNum">  493</span><span class="lineNoCov">      0  /   1: 		case SDLK_y: c64_key = MATRIX(3,1); break;  </span>
<span class="lineNum">  494</span><span class="lineNoCov">      0  /   1: 		case SDLK_z: c64_key = MATRIX(1,4); break;  </span>
<span class="lineNum">  495</span>              :   </span>
<span class="lineNum">  496</span><span class="lineNoCov">      0  /   1: 		case SDLK_0: c64_key = MATRIX(4,3); break;  </span>
<span class="lineNum">  497</span><span class="lineNoCov">      0  /   1: 		case SDLK_1: c64_key = MATRIX(7,0); break;  </span>
<span class="lineNum">  498</span><span class="lineNoCov">      0  /   1: 		case SDLK_2: c64_key = MATRIX(7,3); break;  </span>
<span class="lineNum">  499</span><span class="lineNoCov">      0  /   1: 		case SDLK_3: c64_key = MATRIX(1,0); break;  </span>
<span class="lineNum">  500</span><span class="lineNoCov">      0  /   1: 		case SDLK_4: c64_key = MATRIX(1,3); break;  </span>
<span class="lineNum">  501</span><span class="lineNoCov">      0  /   1: 		case SDLK_5: c64_key = MATRIX(2,0); break;  </span>
<span class="lineNum">  502</span><span class="lineNoCov">      0  /   1: 		case SDLK_6: c64_key = MATRIX(2,3); break;  </span>
<span class="lineNum">  503</span><span class="lineNoCov">      0  /   1: 		case SDLK_7: c64_key = MATRIX(3,0); break;  </span>
<span class="lineNum">  504</span><span class="lineNoCov">      0  /   1: 		case SDLK_8: c64_key = MATRIX(3,3); break;  </span>
<span class="lineNum">  505</span><span class="lineNoCov">      0  /   1: 		case SDLK_9: c64_key = MATRIX(4,0); break;  </span>
<span class="lineNum">  506</span>              :   </span>
<span class="lineNum">  507</span><span class="lineCov">      1  /   1: 		case SDLK_SPACE: c64_key = MATRIX(7,4); break;  </span>
<span class="lineNum">  508</span><span class="lineNoCov">      0  /   1: 		case SDLK_BACKQUOTE: c64_key = MATRIX(7,1); break;  </span>
<span class="lineNum">  509</span><span class="lineNoCov">      0  /   1: 		case SDLK_BACKSLASH: c64_key = MATRIX(6,6); break;  </span>
<span class="lineNum">  510</span><span class="lineNoCov">      0  /   1: 		case SDLK_COMMA: c64_key = MATRIX(5,7); break;  </span>
<span class="lineNum">  511</span><span class="lineNoCov">      0  /   1: 		case SDLK_PERIOD: c64_key = MATRIX(5,4); break;  </span>
<span class="lineNum">  512</span><span class="lineNoCov">      0  /   1: 		case SDLK_MINUS: c64_key = MATRIX(5,0); break;  </span>
<span class="lineNum">  513</span><span class="lineNoCov">      0  /   1: 		case SDLK_EQUALS: c64_key = MATRIX(5,3); break;  </span>
<span class="lineNum">  514</span><span class="lineNoCov">      0  /   1: 		case SDLK_LEFTBRACKET: c64_key = MATRIX(5,6); break;  </span>
<span class="lineNum">  515</span><span class="lineNoCov">      0  /   1: 		case SDLK_RIGHTBRACKET: c64_key = MATRIX(6,1); break;  </span>
<span class="lineNum">  516</span><span class="lineNoCov">      0  /   1: 		case SDLK_SEMICOLON: c64_key = MATRIX(5,5); break;  </span>
<span class="lineNum">  517</span><span class="lineNoCov">      0  /   1: 		case SDLK_QUOTE: c64_key = MATRIX(6,2); break;  </span>
<span class="lineNum">  518</span>              : 		case SDLK_SLASH: c64_key = MATRIX(6,7); break;  </span>
<span class="lineNum">  519</span>              :   </span>
<span class="lineNum">  520</span><span class="lineCov">      1  /   1: 		case SDLK_ESCAPE: c64_key = MATRIX(7,7); break;  </span>
<span class="lineNum">  521</span>              : 		case SDLK_RETURN: c64_key = MATRIX(0,1); break;  </span>
<span class="lineNum">  522</span><span class="lineNoCov">      0  /   1: 		case SDLK_BACKSPACE: case SDLK_DELETE: c64_key = MATRIX(0,0); break;  </span>
<span class="lineNum">  523</span>              : 		case SDLK_INSERT: c64_key = MATRIX(6,3); break;  </span>
<span class="lineNum">  524</span><span class="lineNoCov">      0  /   1: 		case SDLK_HOME: c64_key = MATRIX(6,3); break;  </span>
<span class="lineNum">  525</span>              : 		case SDLK_END: c64_key = MATRIX(6,0); break;  </span>
<span class="lineNum">  526</span><span class="lineNoCov">      0  /   1: 		case SDLK_PAGEUP: c64_key = MATRIX(6,0); break;  </span>
<span class="lineNum">  527</span><span class="lineNoCov">      0  /   1: 		case SDLK_PAGEDOWN: c64_key = MATRIX(6,5); break;  </span>
<span class="lineNum">  528</span>              :   </span>
<span class="lineNum">  529</span>              : 		case SDLK_LCTRL: c64_key = 0x10 | 0x40;  break;  </span>
<span class="lineNum">  530</span><span class="lineNoCov">      0  /   1: 		case SDLK_TAB: c64_key = MATRIX(7,2); break;  </span>
<span class="lineNum">  531</span><span class="lineNoCov">      0  /   1: 		case SDLK_RCTRL: c64_key = MATRIX(7,5); break;  </span>
<span class="lineNum">  532</span><span class="lineNoCov">      0  /   1: 		case SDLK_LSHIFT: c64_key = MATRIX(1,7); break;  </span>
<span class="lineNum">  533</span><span class="lineNoCov">      0  /   1: 		case SDLK_RSHIFT: c64_key = MATRIX(6,4); break;  </span>
<span class="lineNum">  534</span><span class="lineNoCov">      0  /   1: 		case SDLK_LALT: case SDLK_LMETA: c64_key = MATRIX(7,5); break;  </span>
<span class="lineNum">  535</span><span class="lineNoCov">      0  /   1: 		case SDLK_RALT: case SDLK_RMETA: c64_key = MATRIX(7,5); break;  </span>
<span class="lineNum">  536</span>              : 		case SDLK_UP:  </span>
<span class="lineNum">  537</span>              : 		{  </span>
<span class="lineNum">  538</span><span class="lineCov">      1  /   1: 			if (ThePrefs.CursorKeysForJoystick)  </span>
<span class="lineNum">  539</span>              : 				c64_key = 0x01 | 0x40;  </span>
<span class="lineNum">  540</span>              : 			else  </span>
<span class="lineNum">  541</span>              : 				c64_key = MATRIX(0,7) | 0x80;  </span>
<span class="lineNum">  542</span>              : 			break;  </span>
<span class="lineNum">  543</span>              : 		}  </span>
<span class="lineNum">  544</span>              : 		case SDLK_DOWN:  </span>
<span class="lineNum">  545</span>              : 		{  </span>
<span class="lineNum">  546</span><span class="lineCov">      1  /   1: 			if (ThePrefs.CursorKeysForJoystick)  </span>
<span class="lineNum">  547</span>              : 				c64_key = 0x02 | 0x40;  </span>
<span class="lineNum">  548</span>              : 			else  </span>
<span class="lineNum">  549</span>              : 				c64_key = MATRIX(0,7);  </span>
<span class="lineNum">  550</span>              : 			break;  </span>
<span class="lineNum">  551</span>              : 		}  </span>
<span class="lineNum">  552</span>              : 		case SDLK_LEFT:  </span>
<span class="lineNum">  553</span>              : 		{  </span>
<span class="lineNum">  554</span><span class="lineCov">      1  /   1: 			if (ThePrefs.CursorKeysForJoystick)  </span>
<span class="lineNum">  555</span>              : 				c64_key = 0x04 | 0x40;  </span>
<span class="lineNum">  556</span>              : 			else  </span>
<span class="lineNum">  557</span>              : 				c64_key = MATRIX(0,2) | 0x80;  </span>
<span class="lineNum">  558</span>              : 			break;  </span>
<span class="lineNum">  559</span>              : 		}  </span>
<span class="lineNum">  560</span>              : 		case SDLK_RIGHT:  </span>
<span class="lineNum">  561</span>              : 		{  </span>
<span class="lineNum">  562</span><span class="lineCov">      1  /   1: 			if (ThePrefs.CursorKeysForJoystick)  </span>
<span class="lineNum">  563</span>              : 				c64_key = 0x08 | 0x40;  </span>
<span class="lineNum">  564</span>              : 			else  </span>
<span class="lineNum">  565</span>              : 				c64_key = MATRIX(0,2);  </span>
<span class="lineNum">  566</span>              : 			break;  </span>
<span class="lineNum">  567</span>              : 		}  </span>
<span class="lineNum">  568</span><span class="lineNoCov">      0  /   1: 		case SDLK_F1: c64_key = MATRIX(0,4); break;  </span>
<span class="lineNum">  569</span><span class="lineNoCov">      0  /   1: 		case SDLK_F2: c64_key = MATRIX(0,4) | 0x80; break;  </span>
<span class="lineNum">  570</span><span class="lineNoCov">      0  /   1: 		case SDLK_F3: c64_key = MATRIX(0,5); break;  </span>
<span class="lineNum">  571</span><span class="lineNoCov">      0  /   1: 		case SDLK_F4: c64_key = MATRIX(0,5) | 0x80; break;  </span>
<span class="lineNum">  572</span><span class="lineNoCov">      0  /   1: 		case SDLK_F5: c64_key = MATRIX(0,6); break;  </span>
<span class="lineNum">  573</span><span class="lineNoCov">      0  /   1: 		case SDLK_F6: c64_key = MATRIX(0,6) | 0x80; break;  </span>
<span class="lineNum">  574</span><span class="lineNoCov">      0  /   1: 		case SDLK_F7: c64_key = MATRIX(0,3); break;  </span>
<span class="lineNum">  575</span><span class="lineNoCov">      0  /   1: 		case SDLK_F8: c64_key = MATRIX(0,3) | 0x80; break;  </span>
<span class="lineNum">  576</span>              :   </span>
<span class="lineNum">  577</span><span class="lineNoCov">      0  /   1: 		case SDLK_KP0: case SDLK_KP5: c64_key = 0x10 | 0x40; break;  </span>
<span class="lineNum">  578</span><span class="lineNoCov">      0  /   1: 		case SDLK_KP1: c64_key = 0x06 | 0x40; break;  </span>
<span class="lineNum">  579</span><span class="lineNoCov">      0  /   1: 		case SDLK_KP2: c64_key = 0x02 | 0x40; break;  </span>
<span class="lineNum">  580</span><span class="lineNoCov">      0  /   1: 		case SDLK_KP3: c64_key = 0x0a | 0x40; break;  </span>
<span class="lineNum">  581</span><span class="lineNoCov">      0  /   1: 		case SDLK_KP4: c64_key = 0x04 | 0x40; break;  </span>
<span class="lineNum">  582</span><span class="lineNoCov">      0  /   1: 		case SDLK_KP6: c64_key = 0x08 | 0x40; break;  </span>
<span class="lineNum">  583</span><span class="lineNoCov">      0  /   1: 		case SDLK_KP7: c64_key = 0x05 | 0x40; break;  </span>
<span class="lineNum">  584</span><span class="lineNoCov">      0  /   1: 		case SDLK_KP8: c64_key = 0x01 | 0x40; break;  </span>
<span class="lineNum">  585</span><span class="lineNoCov">      0  /   1: 		case SDLK_KP9: c64_key = 0x09 | 0x40; break;  </span>
<span class="lineNum">  586</span>              :   </span>
<span class="lineNum">  587</span><span class="lineNoCov">      0  /   1: 		case SDLK_KP_DIVIDE: c64_key = MATRIX(6,7); break;  </span>
<span class="lineNum">  588</span><span class="lineNoCov">      0  /   1: 		case SDLK_KP_ENTER: c64_key = MATRIX(0,1); break;  </span>
<span class="lineNum">  589</span>              : 		default: break;  </span>
<span class="lineNum">  590</span>              : 	}  </span>
<span class="lineNum">  591</span>              :   </span>
<span class="lineNum">  592</span>              : 	if (c64_key &lt; 0)  </span>
<span class="lineNum">  593</span>              : 		return;  </span>
<span class="lineNum">  594</span>              : 	&#047;* Ugly handling of shift. Sorry about that *&#047;  </span>
<span class="lineNum">  595</span><span class="lineCov">      1  /   1: 	if (!key_up &amp;&amp; (c64_key == MATRIX(1,7) || c64_key == MATRIX(6,4)))  </span>
<span class="lineNum">  596</span><span class="lineNoCov">      0  /   1: 		shift_on = true;  </span>
<span class="lineNum">  597</span><span class="lineCov">      1  /   1: 	else if (c64_key == MATRIX(1,7) || c64_key == MATRIX(6,4))  </span>
<span class="lineNum">  598</span><span class="lineNoCov">      0  /   1: 		shift_on = false;  </span>
<span class="lineNum">  599</span>              :   </span>
<span class="lineNum">  600</span><span class="lineCov">      5  /   5: 	this-&gt;UpdateKeyMatrix(c64_key, key_up, key_matrix, rev_matrix, joystick);  </span>
<span class="lineNum">  601</span><span class="linePartCov">      4  /   5: }  </span>
<span class="lineNum">  602</span>              :   </span>
<span class="lineNum">  603</span>              : const char *C64Display::GetTextMessage()  </span>
<span class="lineNum">  604</span><span class="lineNoCov">      0  /   2: {  </span>
<span class="lineNum">  605</span><span class="lineNoCov">      0  /   1: 	const char *out = this-&gt;text_message_send;  </span>
<span class="lineNum">  606</span>              :   </span>
<span class="lineNum">  607</span><span class="lineNoCov">      0  /   1: 	this-&gt;text_message_send = NULL;  </span>
<span class="lineNum">  608</span>              :   </span>
<span class="lineNum">  609</span>              : 	return out;  </span>
<span class="lineNum">  610</span><span class="lineNoCov">      0  /   1: }  </span>
<span class="lineNum">  611</span>              :   </span>
<span class="lineNum">  612</span>              : class TypeNetworkMessageListener : public KeyboardListener  </span>
<span class="lineNum">  613</span><span class="lineNoCov">      0  /   1: {  </span>
<span class="lineNum">  614</span>              : public:  </span>
<span class="lineNum">  615</span>              : 	TypeNetworkMessageListener(const char **out)  </span>
<span class="lineNum">  616</span><span class="lineNoCov">      0  /   1: 	{  </span>
<span class="lineNum">  617</span>              : 		this-&gt;out = out;  </span>
<span class="lineNum">  618</span>              : 	}  </span>
<span class="lineNum">  619</span>              :   </span>
<span class="lineNum">  620</span><span class="lineNoCov">      0  /   1: 	virtual void stringCallback(const char *str)  </span>
<span class="lineNum">  621</span>              : 	{  </span>
<span class="lineNum">  622</span><span class="lineNoCov">      0  /   2: 		*out = (const char *)xstrdup(str);  </span>
<span class="lineNum">  623</span><span class="lineNoCov">      0  /   1: 		if (strlen(str) &gt; 0)  </span>
<span class="lineNum">  624</span><span class="lineNoCov">      0  /   1: 			Gui::gui-&gt;status_bar-&gt;queueMessage(&quot;Network message sent!&quot;);  </span>
<span class="lineNum">  625</span>              : 		else  </span>
<span class="lineNum">  626</span><span class="lineNoCov">      0  /   1: 			Gui::gui-&gt;status_bar-&gt;queueMessage(&quot;Not sending empty message&quot;);  </span>
<span class="lineNum">  627</span>              : 		&#047;* Remove thyself! *&#047;  </span>
<span class="lineNum">  628</span><span class="lineNoCov">      0  /   2: 		delete this;  </span>
<span class="lineNum">  629</span><span class="lineNoCov">      0  /   2: 	}  </span>
<span class="lineNum">  630</span>              :   </span>
<span class="lineNum">  631</span>              : private:  </span>
<span class="lineNum">  632</span>              : 	const char **out;  </span>
<span class="lineNum">  633</span>              : };  </span>
<span class="lineNum">  634</span>              :   </span>
<span class="lineNum">  635</span>              : void C64Display::TypeNetworkMessage(bool broadcast)  </span>
<span class="lineNum">  636</span><span class="lineNoCov">      0  /   2: {  </span>
<span class="lineNum">  637</span><span class="lineNoCov">      0  /   3: 	TypeNetworkMessageListener *nl = new TypeNetworkMessageListener(&amp;this-&gt;text_message_send);  </span>
<span class="lineNum">  638</span>              :   </span>
<span class="lineNum">  639</span><span class="lineNoCov">      0  /   1: 	this-&gt;text_message_broadcast = broadcast;  </span>
<span class="lineNum">  640</span><span class="lineNoCov">      0  /   1: 	Gui::gui-&gt;status_bar-&gt;queueMessage(&quot;Type message to send to peer&quot;);  </span>
<span class="lineNum">  641</span><span class="lineNoCov">      0  /   1: 	VirtualKeyboard::kbd-&gt;registerListener(nl);  </span>
<span class="lineNum">  642</span><span class="lineNoCov">      0  /   3: 	VirtualKeyboard::kbd-&gt;activate();  </span>
<span class="lineNum">  643</span><span class="lineNoCov">      0  /   2: }  </span>
<span class="lineNum">  644</span>              :   </span>
<span class="lineNum">  645</span>              :   </span>
<span class="lineNum">  646</span>              : void C64Display::PollKeyboard(uint8 *key_matrix, uint8 *rev_matrix, uint8 *joystick)  </span>
<span class="lineNum">  647</span><span class="lineCov">      2  /   2: {  </span>
<span class="lineNum">  648</span>              : 	SDL_Event event;  </span>
<span class="lineNum">  649</span><span class="linePartCov">      1  /   2: 	while (SDL_PollEvent(&amp;event)) {  </span>
<span class="lineNum">  650</span><span class="lineCov">      1  /   1: 		Gui::gui-&gt;pushEvent(&amp;event);  </span>
<span class="lineNum">  651</span>              :   </span>
<span class="lineNum">  652</span>              : 		&#047;* Ignore keyboard input while the menu is active *&#047;  </span>
<span class="lineNum">  653</span><span class="lineCov">      1  /   1: 		if (Gui::gui-&gt;is_active || Gui::gui-&gt;kbd)  </span>
<span class="lineNum">  654</span>              : 			continue;  </span>
<span class="lineNum">  655</span>              :   </span>
<span class="lineNum">  656</span><span class="lineCov">      1  /   1: 		switch (event.type) {  </span>
<span class="lineNum">  657</span>              :   </span>
<span class="lineNum">  658</span>              : 			&#047;&#047; Key pressed  </span>
<span class="lineNum">  659</span>              : 			case SDL_KEYDOWN:  </span>
<span class="lineNum">  660</span><span class="lineCov">      2  /   2: 				switch (event.key.keysym.sym) {  </span>
<span class="lineNum">  661</span>              :   </span>
<span class="lineNum">  662</span>              : 					case SDLK_F10:	&#047;&#047; F10&#047;ScrLk: Enter text (for network taunts)  </span>
<span class="lineNum">  663</span>              : 					case SDLK_SCROLLOCK:  </span>
<span class="lineNum">  664</span><span class="lineNoCov">      0  /   1: 						if (TheC64-&gt;network_connection_type == CLIENT ||  </span>
<span class="lineNum">  665</span>              : 								TheC64-&gt;network_connection_type == MASTER)  </span>
<span class="lineNum">  666</span><span class="lineNoCov">      0  /   1: 							this-&gt;TypeNetworkMessage();  </span>
<span class="lineNum">  667</span>              : 						break;  </span>
<span class="lineNum">  668</span>              :   </span>
<span class="lineNum">  669</span>              : 					case SDLK_F11:	&#047;&#047; F11: NMI (Restore)  </span>
<span class="lineNum">  670</span><span class="lineNoCov">      0  /   1: 						TheC64-&gt;NMI();  </span>
<span class="lineNum">  671</span><span class="lineNoCov">      0  /   1: 						break;  </span>
<span class="lineNum">  672</span>              :   </span>
<span class="lineNum">  673</span>              : 					case SDLK_F12:	&#047;&#047; F12: Reset  </span>
<span class="lineNum">  674</span><span class="lineNoCov">      0  /   1: 						TheC64-&gt;Reset();  </span>
<span class="lineNum">  675</span><span class="lineNoCov">      0  /   1: 						break;  </span>
<span class="lineNum">  676</span>              :   </span>
<span class="lineNum">  677</span>              : 					case SDLK_HOME:	&#047;&#047; Home: Pause and enter menu  </span>
<span class="lineNum">  678</span><span class="lineCov">      1  /   1: 						Gui::gui-&gt;activate();  </span>
<span class="lineNum">  679</span><span class="lineCov">      1  /   1: 						break;  </span>
<span class="lineNum">  680</span>              :   </span>
<span class="lineNum">  681</span>              : 					case SDLK_KP_PLUS:	&#047;&#047; &#039;+&#039; on keypad: Increase SkipFrames  </span>
<span class="lineNum">  682</span><span class="lineNoCov">      0  /   1: 						ThePrefs.SkipFrames++;  </span>
<span class="lineNum">  683</span><span class="lineNoCov">      0  /   1: 						break;  </span>
<span class="lineNum">  684</span>              :   </span>
<span class="lineNum">  685</span>              : 					case SDLK_KP_MINUS:	&#047;&#047; &#039;-&#039; on keypad: Decrease SkipFrames  </span>
<span class="lineNum">  686</span><span class="lineNoCov">      0  /   1: 						if (ThePrefs.SkipFrames &gt; 1)  </span>
<span class="lineNum">  687</span><span class="lineNoCov">      0  /   1: 							ThePrefs.SkipFrames--;  </span>
<span class="lineNum">  688</span>              : 						break;  </span>
<span class="lineNum">  689</span>              :   </span>
<span class="lineNum">  690</span>              : 					case SDLK_KP_MULTIPLY:	&#047;&#047; &#039;*&#039; on keypad: Toggle speed limiter  </span>
<span class="lineNum">  691</span><span class="lineNoCov">      0  /   1: 						ThePrefs.LimitSpeed = !ThePrefs.LimitSpeed;  </span>
<span class="lineNum">  692</span><span class="lineNoCov">      0  /   1: 						break;  </span>
<span class="lineNum">  693</span>              :   </span>
<span class="lineNum">  694</span>              : 					default:  </span>
<span class="lineNum">  695</span><span class="lineCov">      1  /   1: 						TranslateKey(event.key.keysym.sym, false, key_matrix, rev_matrix, joystick);  </span>
<span class="lineNum">  696</span><span class="lineCov">      1  /   1: 						break;  </span>
<span class="lineNum">  697</span>              : 				}  </span>
<span class="lineNum">  698</span>              : 				break;  </span>
<span class="lineNum">  699</span>              :   </span>
<span class="lineNum">  700</span>              : 			&#047;&#047; Key released  </span>
<span class="lineNum">  701</span>              : 			case SDL_KEYUP:  </span>
<span class="lineNum">  702</span><span class="lineCov">      1  /   1: 				TranslateKey(event.key.keysym.sym, true, key_matrix, rev_matrix, joystick);  </span>
<span class="lineNum">  703</span><span class="lineCov">      1  /   1: 				break;  </span>
<span class="lineNum">  704</span>              :   </span>
<span class="lineNum">  705</span>              : 			&#047;&#047; Quit Frodo  </span>
<span class="lineNum">  706</span>              : 			case SDL_QUIT:  </span>
<span class="lineNum">  707</span><span class="lineNoCov">      0  /   1: 				quit_requested = true;  </span>
<span class="lineNum">  708</span>              : 				break;  </span>
<span class="lineNum">  709</span>              : 		}  </span>
<span class="lineNum">  710</span>              : 	}  </span>
<span class="lineNum">  711</span>              : #if defined(GEKKO)  </span>
<span class="lineNum">  712</span>              : 	if (SYS_ResetButtonDown() != 0)  </span>
<span class="lineNum">  713</span>              : 		quit_requested = true;  </span>
<span class="lineNum">  714</span>              : #endif  </span>
<span class="lineNum">  715</span><span class="linePartCov">      1  /   2: }  </span>
<span class="lineNum">  716</span>              :   </span>
<span class="lineNum">  717</span>              :   </span>
<span class="lineNum">  718</span>              : &#047;*  </span>
<span class="lineNum">  719</span>              :  *  Check if NumLock is down (for switching the joystick keyboard emulation)  </span>
<span class="lineNum">  720</span>              :  *&#047;  </span>
<span class="lineNum">  721</span>              :   </span>
<span class="lineNum">  722</span>              : bool C64Display::NumLock(void)  </span>
<span class="lineNum">  723</span><span class="lineNoCov">      0  /   2: {  </span>
<span class="lineNum">  724</span>              : 	return num_locked;  </span>
<span class="lineNum">  725</span><span class="lineNoCov">      0  /   2: }  </span>
<span class="lineNum">  726</span>              :   </span>
<span class="lineNum">  727</span>              :   </span>
<span class="lineNum">  728</span>              : &#047;*  </span>
<span class="lineNum">  729</span>              :  *  Open&#047;close joystick drivers given old and new state of  </span>
<span class="lineNum">  730</span>              :  *  joystick preferences  </span>
<span class="lineNum">  731</span>              :  *&#047;  </span>
<span class="lineNum">  732</span>              : void C64::open_joystick(int port)  </span>
<span class="lineNum">  733</span><span class="lineCov">      2  /   2: {  </span>
<span class="lineNum">  734</span><span class="lineCov">      1  /   1: 	joy_minx[port] = joy_miny[port] = -32767;	&#047;&#047; Reset calibration  </span>
<span class="lineNum">  735</span><span class="lineCov">      1  /   1: 	joy_maxx[port] = joy_maxy[port] = 32768;  </span>
<span class="lineNum">  736</span><span class="lineCov">      2  /   2: 	joy[port] = SDL_JoystickOpen(port);  </span>
<span class="lineNum">  737</span><span class="lineCov">      2  /   2: 	if (joy[port] == NULL)  </span>
<span class="lineNum">  738</span><span class="lineCov">      1  /   1: 		LOG(&quot;Couldn&#039;t open joystick %d&#092;n&quot;, port + 1);  </span>
<span class="lineNum">  739</span><span class="linePartCov">      1  /   2: }  </span>
<span class="lineNum">  740</span>              :   </span>
<span class="lineNum">  741</span>              : void C64::close_joystick(int port)  </span>
<span class="lineNum">  742</span><span class="lineCov">      2  /   2: {  </span>
<span class="lineNum">  743</span><span class="lineCov">      1  /   1: 	if (joy[port]) {  </span>
<span class="lineNum">  744</span><span class="lineNoCov">      0  /   1: 		SDL_JoystickClose(joy[port]);  </span>
<span class="lineNum">  745</span><span class="lineNoCov">      0  /   1: 		joy[port] = NULL;  </span>
<span class="lineNum">  746</span>              : 	}  </span>
<span class="lineNum">  747</span><span class="lineCov">      1  /   1: }  </span>
<span class="lineNum">  748</span>              :   </span>
<span class="lineNum">  749</span>              : &#047;* The implementation principles are borrowed from UAE *&#047;  </span>
<span class="lineNum">  750</span>              : uint8 C64::poll_joystick_axes(int port, bool *has_event)  </span>
<span class="lineNum">  751</span><span class="lineNoCov">      0  /   1: {  </span>
<span class="lineNum">  752</span><span class="lineNoCov">      0  /   1: 	SDL_Joystick *js = joy[port];  </span>
<span class="lineNum">  753</span>              : 	unsigned int i, axes;  </span>
<span class="lineNum">  754</span><span class="lineNoCov">      0  /   1: 	uint8 out = 0xff;  </span>
<span class="lineNum">  755</span>              :   </span>
<span class="lineNum">  756</span><span class="lineNoCov">      0  /   2: 	axes = SDL_JoystickNumAxes (js);  </span>
<span class="lineNum">  757</span><span class="lineNoCov">      0  /   4: 	for (i = 0; i &lt; axes; i++) {  </span>
<span class="lineNum">  758</span>              : 		int axis;  </span>
<span class="lineNum">  759</span>              :   </span>
<span class="lineNum">  760</span><span class="lineNoCov">      0  /   1: 		if (ThePrefs.JoystickAxes[i] == JOY_NONE)  </span>
<span class="lineNum">  761</span>              : 			continue;  </span>
<span class="lineNum">  762</span>              :   </span>
<span class="lineNum">  763</span><span class="lineNoCov">      0  /   2: 		axis = SDL_JoystickGetAxis (js, i);  </span>
<span class="lineNum">  764</span>              :   </span>
<span class="lineNum">  765</span>              : 		&#047;* Assume horizontal *&#047;  </span>
<span class="lineNum">  766</span><span class="lineNoCov">      0  /   4: 		int *max_axis = &amp;this-&gt;joy_maxx[port];  </span>
<span class="lineNum">  767</span><span class="lineNoCov">      0  /   2: 		int *min_axis = &amp;this-&gt;joy_minx[port];  </span>
<span class="lineNum">  768</span><span class="lineNoCov">      0  /   1: 		uint8 neg_val = 0xfb;  </span>
<span class="lineNum">  769</span><span class="lineNoCov">      0  /   1: 		uint8 pos_val = 0xf7;  </span>
<span class="lineNum">  770</span><span class="lineNoCov">      0  /   1: 		event_t gui_neg_val = KEY_LEFT;  </span>
<span class="lineNum">  771</span><span class="lineNoCov">      0  /   1: 		event_t gui_pos_val = KEY_RIGHT;  </span>
<span class="lineNum">  772</span>              :   </span>
<span class="lineNum">  773</span><span class="lineNoCov">      0  /   2: 		if (ThePrefs.JoystickAxes[i] == JOY_VERT)  </span>
<span class="lineNum">  774</span>              : 		{  </span>
<span class="lineNum">  775</span><span class="lineNoCov">      0  /   6: 			max_axis = &amp;this-&gt;joy_maxy[port];  </span>
<span class="lineNum">  776</span><span class="lineNoCov">      0  /   2: 			min_axis = &amp;this-&gt;joy_miny[port];  </span>
<span class="lineNum">  777</span><span class="lineNoCov">      0  /   1: 			neg_val = 0xfe;  </span>
<span class="lineNum">  778</span><span class="lineNoCov">      0  /   1: 			pos_val = 0xfd;  </span>
<span class="lineNum">  779</span><span class="lineNoCov">      0  /   1: 			gui_neg_val = KEY_UP;  </span>
<span class="lineNum">  780</span><span class="lineNoCov">      0  /   1: 			gui_pos_val = KEY_DOWN;  </span>
<span class="lineNum">  781</span>              : 		}  </span>
<span class="lineNum">  782</span>              :   </span>
<span class="lineNum">  783</span>              : 		&#047;* Dynamic joystick calibration *&#047;  </span>
<span class="lineNum">  784</span><span class="lineNoCov">      0  /   1: 		if (axis &gt; *max_axis)  </span>
<span class="lineNum">  785</span><span class="lineNoCov">      0  /   1: 			*max_axis = axis;  </span>
<span class="lineNum">  786</span><span class="lineNoCov">      0  /   1: 		if (axis &lt; *min_axis)  </span>
<span class="lineNum">  787</span><span class="lineNoCov">      0  /   1: 			*min_axis = axis;  </span>
<span class="lineNum">  788</span>              :   </span>
<span class="lineNum">  789</span>              : 		&#047;* Too small as of yet *&#047;  </span>
<span class="lineNum">  790</span><span class="lineNoCov">      0  /   1: 		if (*max_axis - *min_axis &lt; 1000)  </span>
<span class="lineNum">  791</span>              : 			continue;  </span>
<span class="lineNum">  792</span>              :   </span>
<span class="lineNum">  793</span><span class="lineNoCov">      0  /   1: 		if (axis &lt; (*min_axis + (*max_axis - *min_axis)&#047;3)) {  </span>
<span class="lineNum">  794</span><span class="lineNoCov">      0  /   1: 			out &amp;= neg_val;  </span>
<span class="lineNum">  795</span><span class="lineNoCov">      0  /   1: 			Gui::gui-&gt;pushJoystickEvent(gui_neg_val);  </span>
<span class="lineNum">  796</span>              : 			*has_event = true;  </span>
<span class="lineNum">  797</span>              : 		}  </span>
<span class="lineNum">  798</span><span class="lineNoCov">      0  /   1: 		else if (axis &gt; (*min_axis + 2*(*max_axis - *min_axis)&#047;3)) {  </span>
<span class="lineNum">  799</span><span class="lineNoCov">      0  /   1: 			out &amp;= pos_val;  </span>
<span class="lineNum">  800</span><span class="lineNoCov">      0  /   2: 			Gui::gui-&gt;pushJoystickEvent(gui_pos_val);  </span>
<span class="lineNum">  801</span><span class="lineNoCov">      0  /   1: 			*has_event = true;  </span>
<span class="lineNum">  802</span>              : 		}  </span>
<span class="lineNum">  803</span>              : 	}  </span>
<span class="lineNum">  804</span>              :   </span>
<span class="lineNum">  805</span>              : 	return out;  </span>
<span class="lineNum">  806</span><span class="lineNoCov">      0  /   1: }  </span>
<span class="lineNum">  807</span>              :   </span>
<span class="lineNum">  808</span>              : uint8 C64::poll_joystick_hats(int port, bool *has_event)  </span>
<span class="lineNum">  809</span><span class="lineNoCov">      0  /   1: {  </span>
<span class="lineNum">  810</span><span class="lineNoCov">      0  /   1: 	SDL_Joystick *js = joy[port];  </span>
<span class="lineNum">  811</span>              : 	unsigned int i, hats;  </span>
<span class="lineNum">  812</span><span class="lineNoCov">      0  /   1: 	uint8 out = 0xff;  </span>
<span class="lineNum">  813</span>              :   </span>
<span class="lineNum">  814</span><span class="lineNoCov">      0  /   2: 	hats = SDL_JoystickNumHats(js);  </span>
<span class="lineNum">  815</span><span class="lineNoCov">      0  /   5: 	for (i = 0; i &lt; hats; i++) {  </span>
<span class="lineNum">  816</span>              :   </span>
<span class="lineNum">  817</span><span class="lineNoCov">      0  /   2: 		Uint8 v = SDL_JoystickGetHat (js, i);  </span>
<span class="lineNum">  818</span>              : 		Uint8 up_mask    = 0xfe;  </span>
<span class="lineNum">  819</span>              : 		Uint8 down_mask  = 0xfd;  </span>
<span class="lineNum">  820</span>              : 		Uint8 left_mask  = 0xfb;  </span>
<span class="lineNum">  821</span>              : 		Uint8 right_mask = 0xf7;  </span>
<span class="lineNum">  822</span>              : 		event_t up_ev    = KEY_UP;  </span>
<span class="lineNum">  823</span>              : 		event_t down_ev  = KEY_DOWN;  </span>
<span class="lineNum">  824</span>              : 		event_t left_ev  = KEY_LEFT;  </span>
<span class="lineNum">  825</span><span class="lineNoCov">      0  /   4: 		event_t right_ev = KEY_RIGHT;  </span>
<span class="lineNum">  826</span>              :   </span>
<span class="lineNum">  827</span>              : 		if (ThePrefs.MenuJoystickHats[i] == HAT_ROTATED_90)  </span>
<span class="lineNum">  828</span>              : 		{  </span>
<span class="lineNum">  829</span>              : 			up_mask    = 0xf7;  </span>
<span class="lineNum">  830</span>              : 			down_mask  = 0xfb;  </span>
<span class="lineNum">  831</span>              : 			left_mask  = 0xfe;  </span>
<span class="lineNum">  832</span>              : 			right_mask = 0xfd;  </span>
<span class="lineNum">  833</span>              : 			up_ev    = KEY_RIGHT;  </span>
<span class="lineNum">  834</span>              : 			down_ev  = KEY_LEFT;  </span>
<span class="lineNum">  835</span>              : 			left_ev  = KEY_UP;  </span>
<span class="lineNum">  836</span>              : 			right_ev = KEY_DOWN;  </span>
<span class="lineNum">  837</span>              : 		}  </span>
<span class="lineNum">  838</span>              :   </span>
<span class="lineNum">  839</span><span class="lineNoCov">      0  /   3: 		if ((v &amp; (SDL_HAT_UP | SDL_HAT_DOWN | SDL_HAT_LEFT | SDL_HAT_RIGHT)) == 0)  </span>
<span class="lineNum">  840</span>              : 			continue;  </span>
<span class="lineNum">  841</span><span class="lineNoCov">      0  /   2: 		*has_event = true;  </span>
<span class="lineNum">  842</span>              :   </span>
<span class="lineNum">  843</span><span class="lineNoCov">      0  /   2: 		if (v &amp; SDL_HAT_UP) {  </span>
<span class="lineNum">  844</span><span class="lineNoCov">      0  /   1: 			out &amp;= up_mask;  </span>
<span class="lineNum">  845</span><span class="lineNoCov">      0  /   2: 			Gui::gui-&gt;pushJoystickEvent(up_ev);  </span>
<span class="lineNum">  846</span>              : 		}  </span>
<span class="lineNum">  847</span><span class="lineNoCov">      0  /   3: 		if (v &amp; SDL_HAT_DOWN) {  </span>
<span class="lineNum">  848</span><span class="lineNoCov">      0  /   1: 			out &amp;= down_mask;  </span>
<span class="lineNum">  849</span><span class="lineNoCov">      0  /   2: 			Gui::gui-&gt;pushJoystickEvent(down_ev);  </span>
<span class="lineNum">  850</span>              : 		}  </span>
<span class="lineNum">  851</span><span class="lineNoCov">      0  /   2: 		if (v &amp; SDL_HAT_LEFT) {  </span>
<span class="lineNum">  852</span><span class="lineNoCov">      0  /   2: 			out &amp;= left_mask;  </span>
<span class="lineNum">  853</span><span class="lineNoCov">      0  /   3: 			Gui::gui-&gt;pushJoystickEvent(left_ev);  </span>
<span class="lineNum">  854</span>              : 		}  </span>
<span class="lineNum">  855</span><span class="lineNoCov">      0  /   2: 		if (v &amp; SDL_HAT_RIGHT) {  </span>
<span class="lineNum">  856</span><span class="lineNoCov">      0  /   2: 			out &amp;= right_mask;  </span>
<span class="lineNum">  857</span><span class="lineNoCov">      0  /   1: 			Gui::gui-&gt;pushJoystickEvent(right_ev);  </span>
<span class="lineNum">  858</span>              : 		}  </span>
<span class="lineNum">  859</span>              : 	}  </span>
<span class="lineNum">  860</span>              :   </span>
<span class="lineNum">  861</span>              : 	return out;  </span>
<span class="lineNum">  862</span><span class="lineNoCov">      0  /   1: }  </span>
<span class="lineNum">  863</span>              :   </span>
<span class="lineNum">  864</span>              : uint8 C64::poll_joystick_buttons(int port, uint8 *table, bool *has_event)  </span>
<span class="lineNum">  865</span><span class="lineNoCov">      0  /   2: {  </span>
<span class="lineNum">  866</span><span class="lineNoCov">      0  /   1: 	SDL_Joystick *js = joy[port];  </span>
<span class="lineNum">  867</span>              : 	uint8 out = 0xff;  </span>
<span class="lineNum">  868</span>              : 	int i;  </span>
<span class="lineNum">  869</span>              :   </span>
<span class="lineNum">  870</span><span class="lineNoCov">      0  /   3: 	for (i = 0; i &lt; SDL_JoystickNumButtons (js); i++) {  </span>
<span class="lineNum">  871</span><span class="lineNoCov">      0  /   2: 		bool cur = SDL_JoystickGetButton (js, i) ? true : false;  </span>
<span class="lineNum">  872</span><span class="lineNoCov">      0  /   1: 		int kc = ThePrefs.JoystickButtons[i];  </span>
<span class="lineNum">  873</span><span class="lineNoCov">      0  /   1: 		event_t ev = (event_t)ThePrefs.MenuJoystickButtons[i];  </span>
<span class="lineNum">  874</span>              :   </span>
<span class="lineNum">  875</span><span class="lineNoCov">      0  /   1: 		if (cur &amp;&amp; ev != EVENT_NONE)  </span>
<span class="lineNum">  876</span>              : 		{  </span>
<span class="lineNum">  877</span><span class="lineNoCov">      0  /   1: 			Gui::gui-&gt;pushJoystickEvent(ev);  </span>
<span class="lineNum">  878</span><span class="lineNoCov">      0  /   1: 			*has_event = true;  </span>
<span class="lineNum">  879</span>              : 		}  </span>
<span class="lineNum">  880</span><span class="lineNoCov">      0  /   1: 		if (kc == JOY_NONE)  </span>
<span class="lineNum">  881</span>              : 			continue;  </span>
<span class="lineNum">  882</span>              :   </span>
<span class="lineNum">  883</span><span class="lineNoCov">      0  /   1: 		if (table[kc] == 0)  </span>
<span class="lineNum">  884</span><span class="lineNoCov">      0  /   1: 			table[kc] = cur ? 2 : 1;  </span>
<span class="lineNum">  885</span>              : 		&#047;* Special case for joysticks: Each button can be pressed multiple times *&#047;  </span>
<span class="lineNum">  886</span><span class="lineNoCov">      0  /   1: 		if ((kc &amp; 0x40) &amp;&amp; cur)  </span>
<span class="lineNum">  887</span><span class="lineNoCov">      0  /   1: 			table[kc] = 2;  </span>
<span class="lineNum">  888</span>              : 	}  </span>
<span class="lineNum">  889</span>              :   </span>
<span class="lineNum">  890</span>              : 	return out;  </span>
<span class="lineNum">  891</span><span class="lineNoCov">      0  /   1: }  </span>
<span class="lineNum">  892</span>              :   </span>
<span class="lineNum">  893</span>              : &#047;*  </span>
<span class="lineNum">  894</span>              :  *  Poll joystick port, return CIA mask  </span>
<span class="lineNum">  895</span>              :  *&#047;  </span>
<span class="lineNum">  896</span><span class="lineNoCov">      0  /   2: uint8 C64::poll_joystick(int port)  </span>
<span class="lineNum">  897</span><span class="lineCov">      3  /   3: {  </span>
<span class="lineNum">  898</span><span class="lineCov">      1  /   1: 	bool has_event = false;  </span>
<span class="lineNum">  899</span><span class="lineCov">      1  /   1: 	uint8 out = 0xff;  </span>
<span class="lineNum">  900</span>              : 	static uint8 last_table_ports[2][0xff];  </span>
<span class="lineNum">  901</span>              : 	uint8 table_ports[2][0xff];  </span>
<span class="lineNum">  902</span>              : 	uint8 *last_table = last_table_ports[port];  </span>
<span class="lineNum">  903</span><span class="lineNoCov">      0  /   3: 	uint8 *table = table_ports[port];  </span>
<span class="lineNum">  904</span>              :   </span>
<span class="lineNum">  905</span><span class="lineCov">      1  /   1: 	if (!joy[port])  </span>
<span class="lineNum">  906</span><span class="lineCov">      1  /   1: 		return out;  </span>
<span class="lineNum">  907</span>              :   </span>
<span class="lineNum">  908</span>              : 	memset(table, 0, 0xff);  </span>
<span class="lineNum">  909</span>              :   </span>
<span class="lineNum">  910</span><span class="lineNoCov">      0  /   2: 	out &amp;= this-&gt;poll_joystick_axes(port, &amp;has_event);  </span>
<span class="lineNum">  911</span><span class="lineNoCov">      0  /   3: 	out &amp;= this-&gt;poll_joystick_hats(port, &amp;has_event);  </span>
<span class="lineNum">  912</span><span class="lineNoCov">      0  /   2: 	out &amp;= this-&gt;poll_joystick_buttons(port, table, &amp;has_event);  </span>
<span class="lineNum">  913</span>              :   </span>
<span class="lineNum">  914</span><span class="lineNoCov">      0  /   1: 	if (!has_event)  </span>
<span class="lineNum">  915</span><span class="lineNoCov">      0  /   1: 		Gui::gui-&gt;pushJoystickEvent(EVENT_NONE);  </span>
<span class="lineNum">  916</span>              :   </span>
<span class="lineNum">  917</span>              : 	&#047;* No joystick input when the Gui is active *&#047;  </span>
<span class="lineNum">  918</span><span class="lineNoCov">      0  /   3: 	if (Gui::gui-&gt;is_active || Gui::gui-&gt;kbd)  </span>
<span class="lineNum">  919</span><span class="lineNoCov">      0  /   1: 		return 0xff;  </span>
<span class="lineNum">  920</span>              :   </span>
<span class="lineNum">  921</span>              : 	&#047;* Handle keyboard codes *&#047;  </span>
<span class="lineNum">  922</span><span class="lineNoCov">      0  /   1: 	for (int i = 0; i &lt; 0x51; i++)  </span>
<span class="lineNum">  923</span>              : 	{  </span>
<span class="lineNum">  924</span><span class="lineNoCov">      0  /   1: 		if (table[i] == 0)  </span>
<span class="lineNum">  925</span>              : 			continue;  </span>
<span class="lineNum">  926</span><span class="lineNoCov">      0  /   1: 		if ( !(i &amp; 0x40) &amp;&amp; table[i] == last_table[i] )  </span>
<span class="lineNum">  927</span>              : 			continue;  </span>
<span class="lineNum">  928</span>              :   </span>
<span class="lineNum">  929</span>              : 		TheDisplay-&gt;UpdateKeyMatrix(i, table[i] == 1,  </span>
<span class="lineNum">  930</span><span class="lineNoCov">      0  /   3: 				TheCIA1-&gt;KeyMatrix, TheCIA1-&gt;RevMatrix,	&amp;out);  </span>
<span class="lineNum">  931</span>              : 	}  </span>
<span class="lineNum">  932</span>              :   </span>
<span class="lineNum">  933</span>              : 	memcpy(last_table, table, 0xff);  </span>
<span class="lineNum">  934</span>              :   </span>
<span class="lineNum">  935</span><span class="lineNoCov">      0  /   1: 	return out;  </span>
<span class="lineNum">  936</span><span class="linePartCov">      1  /   2: }  </span>
<span class="lineNum">  937</span>              :   </span>
<span class="lineNum">  938</span>              :   </span>
<span class="lineNum">  939</span>              : &#047;*  </span>
<span class="lineNum">  940</span>              :  *  Allocate C64 colors  </span>
<span class="lineNum">  941</span>              :  *&#047;  </span>
<span class="lineNum">  942</span>              :   </span>
<span class="lineNum">  943</span>              : void C64Display::InitColors(uint8 *colors)  </span>
<span class="lineNum">  944</span><span class="lineCov">      3  /   3: {  </span>
<span class="lineNum">  945</span><span class="lineCov">      2  /   2: 	for (int i=0; i&lt;16; i++) {  </span>
<span class="lineNum">  946</span><span class="lineCov">      1  /   1: 		sdl_palette[i].r = palette_red[i];  </span>
<span class="lineNum">  947</span><span class="lineCov">      1  /   1: 		sdl_palette[i].g = palette_green[i];  </span>
<span class="lineNum">  948</span><span class="lineCov">      1  /   1: 		sdl_palette[i].b = palette_blue[i];  </span>
<span class="lineNum">  949</span>              : 	}  </span>
<span class="lineNum">  950</span><span class="lineCov">      1  /   1: 	sdl_palette[fill_gray].r = sdl_palette[fill_gray].g = sdl_palette[fill_gray].b = 0xd0;  </span>
<span class="lineNum">  951</span><span class="lineCov">      1  /   1: 	sdl_palette[shine_gray].r = sdl_palette[shine_gray].g = sdl_palette[shine_gray].b = 0xf0;  </span>
<span class="lineNum">  952</span><span class="lineCov">      1  /   1: 	sdl_palette[shadow_gray].r = sdl_palette[shadow_gray].g = sdl_palette[shadow_gray].b = 0x80;  </span>
<span class="lineNum">  953</span><span class="lineCov">      1  /   1: 	sdl_palette[red].r = 0xf0;  </span>
<span class="lineNum">  954</span><span class="lineCov">      1  /   1: 	sdl_palette[red].g = sdl_palette[red].b = 0;  </span>
<span class="lineNum">  955</span><span class="lineCov">      1  /   1: 	sdl_palette[green].g = 0xf0;  </span>
<span class="lineNum">  956</span><span class="lineCov">      3  /   3: 	sdl_palette[green].r = sdl_palette[green].b = 0;  </span>
<span class="lineNum">  957</span>              :   </span>
<span class="lineNum">  958</span><span class="lineCov">      3  /   3:  	for (int i = 0; i &lt; PALETTE_SIZE; i++) {  </span>
<span class="lineNum">  959</span>              :  		int rs = pixel_format-&gt;Rshift;  </span>
<span class="lineNum">  960</span>              :  		int gs = pixel_format-&gt;Gshift;  </span>
<span class="lineNum">  961</span>              :  		int bs = pixel_format-&gt;Bshift;  </span>
<span class="lineNum">  962</span>              :  		int rl = pixel_format-&gt;Rloss;  </span>
<span class="lineNum">  963</span>              :  		int gl = pixel_format-&gt;Gloss;  </span>
<span class="lineNum">  964</span>              :  		int bl = pixel_format-&gt;Bloss;  </span>
<span class="lineNum">  965</span>              :  		int rm = pixel_format-&gt;Rmask;  </span>
<span class="lineNum">  966</span>              :  		int gm = pixel_format-&gt;Gmask;  </span>
<span class="lineNum">  967</span>              :  		int bm = pixel_format-&gt;Bmask;  </span>
<span class="lineNum">  968</span><span class="lineCov">      1  /   1:  		uint32 r = palette_red[i] &amp; 0xff;  </span>
<span class="lineNum">  969</span><span class="lineCov">      1  /   1:  		uint32 g = palette_green[i] &amp; 0xff;  </span>
<span class="lineNum">  970</span><span class="lineCov">      1  /   1:  		uint32 b = palette_blue[i] &amp; 0xff;  </span>
<span class="lineNum">  971</span>              :   </span>
<span class="lineNum">  972</span><span class="lineCov">      5  /   5: 		palette_16[i] = (((r &gt;&gt; rl) &lt;&lt; rs) &amp; rm) | (((g &gt;&gt; gl) &lt;&lt; gs) &amp; gm) | (((b &gt;&gt; bl) &lt;&lt; bs) &amp; bm);  </span>
<span class="lineNum">  973</span><span class="lineCov">      4  /   4: 		palette_32[i] = (((r &gt;&gt; rl) &lt;&lt; rs) &amp; rm) | (((g &gt;&gt; gl) &lt;&lt; gs) &amp; gm) | (((b &gt;&gt; bl) &lt;&lt; bs) &amp; bm);  </span>
<span class="lineNum">  974</span>              : 	}  </span>
<span class="lineNum">  975</span>              :   </span>
<span class="lineNum">  976</span><span class="lineCov">      1  /   1: 	for (int i=0; i&lt;256; i++)  </span>
<span class="lineNum">  977</span><span class="lineCov">      1  /   1: 		colors[i] = i &amp; 0x0f;  </span>
<span class="lineNum">  978</span><span class="lineCov">      1  /   1: }  </span>
<span class="lineNum">  979</span>              :   </span>
<span class="lineNum">  980</span>              :   </span>
<span class="lineNum">  981</span>              : &#047;*  </span>
<span class="lineNum">  982</span>              :  *  Show a requester (error message)  </span>
<span class="lineNum">  983</span>              :  *&#047;  </span>
<span class="lineNum">  984</span>              :   </span>
<span class="lineNum">  985</span>              : long int ShowRequester(const char *a, const char *b, const char *)  </span>
<span class="lineNum">  986</span><span class="lineNoCov">      0  /   1: {  </span>
<span class="lineNum">  987</span>              : 	printf(&quot;%s: %s&#092;n&quot;, a, b);  </span>
<span class="lineNum">  988</span>              : 	return 1;  </span>
<span class="lineNum">  989</span><span class="lineNoCov">      0  /   2: }  </span>
</pre>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr><td class="versionInfo">Generated by: <a href="http://simonkagstrom.github.com/kcov/index.html">Kcov</a> (based on <a href="http://bcov.sourceforge.net">bcov</a>)</td></tr>
</table>
<br/>
</body>
</html>
