<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Coverage - ./frodo</title>
  <link rel="stylesheet" type="text/css" href="bcov.css"/>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="title">Coverage Report</td></tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr>
    <td width="100%">
      <table cellpadding="1" border="0" width="100%">
        <tr>
          <td class="headerItem" width="20%">Command:</td>
          <td class="headerValue" width="80%" colspan=6>./frodo</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Date:</td>
          <td class="headerValue" width="15%">2010-11-27 09:09:09</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Instrumented&nbsp;lines:</td>
          <td class="headerValue" width="10%">12</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Code&nbsp;covered:</td>
          <td class="coverPerLeftHi" width="15%">75.0 %</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Executed&nbsp;lines:</td>
          <td class="headerValue" width="10%">9</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
</table>
<pre class="source">
<span class="lineNum">      1 </span>              : // Vector implementation -*- C++ -*- </span>
<span class="lineNum">      2 </span>              :  </span>
<span class="lineNum">      3 </span>              : // Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 </span>
<span class="lineNum">      4 </span>              : // Free Software Foundation, Inc. </span>
<span class="lineNum">      5 </span>              : // </span>
<span class="lineNum">      6 </span>              : // This file is part of the GNU ISO C++ Library.  This library is free </span>
<span class="lineNum">      7 </span>              : // software; you can redistribute it and/or modify it under the </span>
<span class="lineNum">      8 </span>              : // terms of the GNU General Public License as published by the </span>
<span class="lineNum">      9 </span>              : // Free Software Foundation; either version 3, or (at your option) </span>
<span class="lineNum">     10 </span>              : // any later version. </span>
<span class="lineNum">     11 </span>              :  </span>
<span class="lineNum">     12 </span>              : // This library is distributed in the hope that it will be useful, </span>
<span class="lineNum">     13 </span>              : // but WITHOUT ANY WARRANTY; without even the implied warranty of </span>
<span class="lineNum">     14 </span>              : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the </span>
<span class="lineNum">     15 </span>              : // GNU General Public License for more details. </span>
<span class="lineNum">     16 </span>              :  </span>
<span class="lineNum">     17 </span>              : // Under Section 7 of GPL version 3, you are granted additional </span>
<span class="lineNum">     18 </span>              : // permissions described in the GCC Runtime Library Exception, version </span>
<span class="lineNum">     19 </span>              : // 3.1, as published by the Free Software Foundation. </span>
<span class="lineNum">     20 </span>              :  </span>
<span class="lineNum">     21 </span>              : // You should have received a copy of the GNU General Public License and </span>
<span class="lineNum">     22 </span>              : // a copy of the GCC Runtime Library Exception along with this program; </span>
<span class="lineNum">     23 </span>              : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see </span>
<span class="lineNum">     24 </span>              : // &lt;http://www.gnu.org/licenses/&gt;. </span>
<span class="lineNum">     25 </span>              :  </span>
<span class="lineNum">     26 </span>              : /* </span>
<span class="lineNum">     27 </span>              :  * </span>
<span class="lineNum">     28 </span>              :  * Copyright (c) 1994 </span>
<span class="lineNum">     29 </span>              :  * Hewlett-Packard Company </span>
<span class="lineNum">     30 </span>              :  * </span>
<span class="lineNum">     31 </span>              :  * Permission to use, copy, modify, distribute and sell this software </span>
<span class="lineNum">     32 </span>              :  * and its documentation for any purpose is hereby granted without fee, </span>
<span class="lineNum">     33 </span>              :  * provided that the above copyright notice appear in all copies and </span>
<span class="lineNum">     34 </span>              :  * that both that copyright notice and this permission notice appear </span>
<span class="lineNum">     35 </span>              :  * in supporting documentation.  Hewlett-Packard Company makes no </span>
<span class="lineNum">     36 </span>              :  * representations about the suitability of this software for any </span>
<span class="lineNum">     37 </span>              :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty. </span>
<span class="lineNum">     38 </span>              :  * </span>
<span class="lineNum">     39 </span>              :  * </span>
<span class="lineNum">     40 </span>              :  * Copyright (c) 1996 </span>
<span class="lineNum">     41 </span>              :  * Silicon Graphics Computer Systems, Inc. </span>
<span class="lineNum">     42 </span>              :  * </span>
<span class="lineNum">     43 </span>              :  * Permission to use, copy, modify, distribute and sell this software </span>
<span class="lineNum">     44 </span>              :  * and its documentation for any purpose is hereby granted without fee, </span>
<span class="lineNum">     45 </span>              :  * provided that the above copyright notice appear in all copies and </span>
<span class="lineNum">     46 </span>              :  * that both that copyright notice and this permission notice appear </span>
<span class="lineNum">     47 </span>              :  * in supporting documentation.  Silicon Graphics makes no </span>
<span class="lineNum">     48 </span>              :  * representations about the suitability of this  software for any </span>
<span class="lineNum">     49 </span>              :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty. </span>
<span class="lineNum">     50 </span>              :  */ </span>
<span class="lineNum">     51 </span>              :  </span>
<span class="lineNum">     52 </span>              : /** @file stl_vector.h </span>
<span class="lineNum">     53 </span>              :  *  This is an internal header file, included by other library headers. </span>
<span class="lineNum">     54 </span>              :  *  You should not attempt to use it directly. </span>
<span class="lineNum">     55 </span>              :  */ </span>
<span class="lineNum">     56 </span>              :  </span>
<span class="lineNum">     57 </span>              : #ifndef _STL_VECTOR_H </span>
<span class="lineNum">     58 </span>              : #define _STL_VECTOR_H 1 </span>
<span class="lineNum">     59 </span>              :  </span>
<span class="lineNum">     60 </span>              : #include &lt;bits/stl_iterator_base_funcs.h&gt; </span>
<span class="lineNum">     61 </span>              : #include &lt;bits/functexcept.h&gt; </span>
<span class="lineNum">     62 </span>              : #include &lt;bits/concept_check.h&gt; </span>
<span class="lineNum">     63 </span>              : #include &lt;initializer_list&gt; </span>
<span class="lineNum">     64 </span>              :  </span>
<span class="lineNum">     65 </span>              : _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D) </span>
<span class="lineNum">     66 </span>              :  </span>
<span class="lineNum">     67 </span>              :   /// See bits/stl_deque.h's _Deque_base for an explanation. </span>
<span class="lineNum">     68 </span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">     69 </span>              :     struct _Vector_base </span>
<span class="lineNum">     70 </span>              :     { </span>
<span class="lineNum">     71 </span>              :       typedef typename _Alloc::template rebind&lt;_Tp&gt;::other _Tp_alloc_type; </span>
<span class="lineNum">     72 </span>              :  </span>
<span class="lineNum">     73 </span>              :       struct _Vector_impl  </span>
<span class="lineNum">     74 </span>              :       : public _Tp_alloc_type </span>
<span class="lineNum">     75 </span>              :       { </span>
<span class="lineNum">     76 </span>              : 	typename _Tp_alloc_type::pointer _M_start; </span>
<span class="lineNum">     77 </span>              : 	typename _Tp_alloc_type::pointer _M_finish; </span>
<span class="lineNum">     78 </span>              : 	typename _Tp_alloc_type::pointer _M_end_of_storage; </span>
<span class="lineNum">     79 </span>              :  </span>
<span class="lineNum">     80 </span>              : 	_Vector_impl() </span>
<span class="lineNum">     81 </span><span class="linePartCov">    2 / 4     : 	: _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0) </span>
<span class="lineNum">     82 </span>              : 	{ } </span>
<span class="lineNum">     83 </span>              :  </span>
<span class="lineNum">     84 </span>              : 	_Vector_impl(_Tp_alloc_type const&amp; __a) </span>
<span class="lineNum">     85 </span>              : 	: _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0) </span>
<span class="lineNum">     86 </span>              : 	{ } </span>
<span class="lineNum">     87 </span>              :       }; </span>
<span class="lineNum">     88 </span>              :        </span>
<span class="lineNum">     89 </span>              :     public: </span>
<span class="lineNum">     90 </span>              :       typedef _Alloc allocator_type; </span>
<span class="lineNum">     91 </span>              :  </span>
<span class="lineNum">     92 </span>              :       _Tp_alloc_type&amp; </span>
<span class="lineNum">     93 </span>              :       _M_get_Tp_allocator() </span>
<span class="lineNum">     94 </span>              :       { return *static_cast&lt;_Tp_alloc_type*&gt;(&amp;this-&gt;_M_impl); } </span>
<span class="lineNum">     95 </span>              :  </span>
<span class="lineNum">     96 </span>              :       const _Tp_alloc_type&amp; </span>
<span class="lineNum">     97 </span>              :       _M_get_Tp_allocator() const </span>
<span class="lineNum">     98 </span>              :       { return *static_cast&lt;const _Tp_alloc_type*&gt;(&amp;this-&gt;_M_impl); } </span>
<span class="lineNum">     99 </span>              :  </span>
<span class="lineNum">    100 </span>              :       allocator_type </span>
<span class="lineNum">    101 </span>              :       get_allocator() const </span>
<span class="lineNum">    102 </span>              :       { return allocator_type(_M_get_Tp_allocator()); } </span>
<span class="lineNum">    103 </span>              :  </span>
<span class="lineNum">    104 </span>              :       _Vector_base() </span>
<span class="lineNum">    105 </span>              :       : _M_impl() { } </span>
<span class="lineNum">    106 </span>              :  </span>
<span class="lineNum">    107 </span>              :       _Vector_base(const allocator_type&amp; __a) </span>
<span class="lineNum">    108 </span>              :       : _M_impl(__a) { } </span>
<span class="lineNum">    109 </span>              :  </span>
<span class="lineNum">    110 </span>              :       _Vector_base(size_t __n, const allocator_type&amp; __a) </span>
<span class="lineNum">    111 </span>              :       : _M_impl(__a) </span>
<span class="lineNum">    112 </span>              :       { </span>
<span class="lineNum">    113 </span>              : 	this-&gt;_M_impl._M_start = this-&gt;_M_allocate(__n); </span>
<span class="lineNum">    114 </span>              : 	this-&gt;_M_impl._M_finish = this-&gt;_M_impl._M_start; </span>
<span class="lineNum">    115 </span>              : 	this-&gt;_M_impl._M_end_of_storage = this-&gt;_M_impl._M_start + __n; </span>
<span class="lineNum">    116 </span>              :       } </span>
<span class="lineNum">    117 </span>              :  </span>
<span class="lineNum">    118 </span>              : #ifdef __GXX_EXPERIMENTAL_CXX0X__ </span>
<span class="lineNum">    119 </span>              :       _Vector_base(_Vector_base&amp;&amp; __x) </span>
<span class="lineNum">    120 </span>              :       : _M_impl(__x._M_get_Tp_allocator()) </span>
<span class="lineNum">    121 </span>              :       { </span>
<span class="lineNum">    122 </span>              : 	this-&gt;_M_impl._M_start = __x._M_impl._M_start; </span>
<span class="lineNum">    123 </span>              : 	this-&gt;_M_impl._M_finish = __x._M_impl._M_finish; </span>
<span class="lineNum">    124 </span>              : 	this-&gt;_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage; </span>
<span class="lineNum">    125 </span>              : 	__x._M_impl._M_start = 0; </span>
<span class="lineNum">    126 </span>              : 	__x._M_impl._M_finish = 0; </span>
<span class="lineNum">    127 </span>              : 	__x._M_impl._M_end_of_storage = 0; </span>
<span class="lineNum">    128 </span>              :       } </span>
<span class="lineNum">    129 </span>              : #endif </span>
<span class="lineNum">    130 </span>              :  </span>
<span class="lineNum">    131 </span>              :       ~_Vector_base() </span>
<span class="lineNum">    132 </span><span class="linePartCov">    1 / 3     :       { _M_deallocate(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_end_of_storage </span>
<span class="lineNum">    133 </span>              : 		      - this-&gt;_M_impl._M_start); } </span>
<span class="lineNum">    134 </span>              :  </span>
<span class="lineNum">    135 </span>              :     public: </span>
<span class="lineNum">    136 </span>              :       _Vector_impl _M_impl; </span>
<span class="lineNum">    137 </span>              :  </span>
<span class="lineNum">    138 </span>              :       typename _Tp_alloc_type::pointer </span>
<span class="lineNum">    139 </span>              :       _M_allocate(size_t __n) </span>
<span class="lineNum">    140 </span><span class="linePartCov">    1 / 8     :       { return __n != 0 ? _M_impl.allocate(__n) : 0; } </span>
<span class="lineNum">    141 </span>              :  </span>
<span class="lineNum">    142 </span>              :       void </span>
<span class="lineNum">    143 </span>              :       _M_deallocate(typename _Tp_alloc_type::pointer __p, size_t __n) </span>
<span class="lineNum">    144 </span>              :       { </span>
<span class="lineNum">    145 </span><span class="linePartCov">    2 / 6     : 	if (__p) </span>
<span class="lineNum">    146 </span>              : 	  _M_impl.deallocate(__p, __n); </span>
<span class="lineNum">    147 </span>              :       } </span>
<span class="lineNum">    148 </span>              :     }; </span>
<span class="lineNum">    149 </span>              :  </span>
<span class="lineNum">    150 </span>              :  </span>
<span class="lineNum">    151 </span>              :   /** </span>
<span class="lineNum">    152 </span>              :    *  @brief A standard container which offers fixed time access to </span>
<span class="lineNum">    153 </span>              :    *  individual elements in any order. </span>
<span class="lineNum">    154 </span>              :    * </span>
<span class="lineNum">    155 </span>              :    *  @ingroup sequences </span>
<span class="lineNum">    156 </span>              :    * </span>
<span class="lineNum">    157 </span>              :    *  Meets the requirements of a &lt;a href=&quot;tables.html#65&quot;&gt;container&lt;/a&gt;, a </span>
<span class="lineNum">    158 </span>              :    *  &lt;a href=&quot;tables.html#66&quot;&gt;reversible container&lt;/a&gt;, and a </span>
<span class="lineNum">    159 </span>              :    *  &lt;a href=&quot;tables.html#67&quot;&gt;sequence&lt;/a&gt;, including the </span>
<span class="lineNum">    160 </span>              :    *  &lt;a href=&quot;tables.html#68&quot;&gt;optional sequence requirements&lt;/a&gt; with the </span>
<span class="lineNum">    161 </span>              :    *  %exception of @c push_front and @c pop_front. </span>
<span class="lineNum">    162 </span>              :    * </span>
<span class="lineNum">    163 </span>              :    *  In some terminology a %vector can be described as a dynamic </span>
<span class="lineNum">    164 </span>              :    *  C-style array, it offers fast and efficient access to individual </span>
<span class="lineNum">    165 </span>              :    *  elements in any order and saves the user from worrying about </span>
<span class="lineNum">    166 </span>              :    *  memory and size allocation.  Subscripting ( @c [] ) access is </span>
<span class="lineNum">    167 </span>              :    *  also provided as with C-style arrays. </span>
<span class="lineNum">    168 </span>              :   */ </span>
<span class="lineNum">    169 </span>              :   template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt; &gt; </span>
<span class="lineNum">    170 </span>              :     class vector : protected _Vector_base&lt;_Tp, _Alloc&gt; </span>
<span class="lineNum">    171 </span>              :     { </span>
<span class="lineNum">    172 </span>              :       // Concept requirements. </span>
<span class="lineNum">    173 </span>              :       typedef typename _Alloc::value_type                _Alloc_value_type; </span>
<span class="lineNum">    174 </span>              :       __glibcxx_class_requires(_Tp, _SGIAssignableConcept) </span>
<span class="lineNum">    175 </span>              :       __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept) </span>
<span class="lineNum">    176 </span>              :        </span>
<span class="lineNum">    177 </span>              :       typedef _Vector_base&lt;_Tp, _Alloc&gt;			 _Base; </span>
<span class="lineNum">    178 </span>              :       typedef typename _Base::_Tp_alloc_type		 _Tp_alloc_type; </span>
<span class="lineNum">    179 </span>              :  </span>
<span class="lineNum">    180 </span>              :     public: </span>
<span class="lineNum">    181 </span>              :       typedef _Tp					 value_type; </span>
<span class="lineNum">    182 </span>              :       typedef typename _Tp_alloc_type::pointer           pointer; </span>
<span class="lineNum">    183 </span>              :       typedef typename _Tp_alloc_type::const_pointer     const_pointer; </span>
<span class="lineNum">    184 </span>              :       typedef typename _Tp_alloc_type::reference         reference; </span>
<span class="lineNum">    185 </span>              :       typedef typename _Tp_alloc_type::const_reference   const_reference; </span>
<span class="lineNum">    186 </span>              :       typedef __gnu_cxx::__normal_iterator&lt;pointer, vector&gt; iterator; </span>
<span class="lineNum">    187 </span>              :       typedef __gnu_cxx::__normal_iterator&lt;const_pointer, vector&gt; </span>
<span class="lineNum">    188 </span>              :       const_iterator; </span>
<span class="lineNum">    189 </span>              :       typedef std::reverse_iterator&lt;const_iterator&gt;  const_reverse_iterator; </span>
<span class="lineNum">    190 </span>              :       typedef std::reverse_iterator&lt;iterator&gt;		 reverse_iterator; </span>
<span class="lineNum">    191 </span>              :       typedef size_t					 size_type; </span>
<span class="lineNum">    192 </span>              :       typedef ptrdiff_t					 difference_type; </span>
<span class="lineNum">    193 </span>              :       typedef _Alloc                        		 allocator_type; </span>
<span class="lineNum">    194 </span>              :  </span>
<span class="lineNum">    195 </span>              :     protected: </span>
<span class="lineNum">    196 </span>              :       using _Base::_M_allocate; </span>
<span class="lineNum">    197 </span>              :       using _Base::_M_deallocate; </span>
<span class="lineNum">    198 </span>              :       using _Base::_M_impl; </span>
<span class="lineNum">    199 </span>              :       using _Base::_M_get_Tp_allocator; </span>
<span class="lineNum">    200 </span>              :  </span>
<span class="lineNum">    201 </span>              :     public: </span>
<span class="lineNum">    202 </span>              :       // [23.2.4.1] construct/copy/destroy </span>
<span class="lineNum">    203 </span>              :       // (assign() and get_allocator() are also listed in this section) </span>
<span class="lineNum">    204 </span>              :       /** </span>
<span class="lineNum">    205 </span>              :        *  @brief  Default constructor creates no elements. </span>
<span class="lineNum">    206 </span>              :        */ </span>
<span class="lineNum">    207 </span>              :       vector() </span>
<span class="lineNum">    208 </span>              :       : _Base() { } </span>
<span class="lineNum">    209 </span>              :  </span>
<span class="lineNum">    210 </span>              :       /** </span>
<span class="lineNum">    211 </span>              :        *  @brief  Creates a %vector with no elements. </span>
<span class="lineNum">    212 </span>              :        *  @param  a  An allocator object. </span>
<span class="lineNum">    213 </span>              :        */ </span>
<span class="lineNum">    214 </span>              :       explicit </span>
<span class="lineNum">    215 </span>              :       vector(const allocator_type&amp; __a) </span>
<span class="lineNum">    216 </span>              :       : _Base(__a) { } </span>
<span class="lineNum">    217 </span>              :  </span>
<span class="lineNum">    218 </span>              :       /** </span>
<span class="lineNum">    219 </span>              :        *  @brief  Creates a %vector with copies of an exemplar element. </span>
<span class="lineNum">    220 </span>              :        *  @param  n  The number of elements to initially create. </span>
<span class="lineNum">    221 </span>              :        *  @param  value  An element to copy. </span>
<span class="lineNum">    222 </span>              :        *  @param  a  An allocator. </span>
<span class="lineNum">    223 </span>              :        * </span>
<span class="lineNum">    224 </span>              :        *  This constructor fills the %vector with @a n copies of @a value. </span>
<span class="lineNum">    225 </span>              :        */ </span>
<span class="lineNum">    226 </span>              :       explicit </span>
<span class="lineNum">    227 </span>              :       vector(size_type __n, const value_type&amp; __value = value_type(), </span>
<span class="lineNum">    228 </span>              : 	     const allocator_type&amp; __a = allocator_type()) </span>
<span class="lineNum">    229 </span>              :       : _Base(__n, __a) </span>
<span class="lineNum">    230 </span>              :       { _M_fill_initialize(__n, __value); } </span>
<span class="lineNum">    231 </span>              :  </span>
<span class="lineNum">    232 </span>              :       /** </span>
<span class="lineNum">    233 </span>              :        *  @brief  %Vector copy constructor. </span>
<span class="lineNum">    234 </span>              :        *  @param  x  A %vector of identical element and allocator types. </span>
<span class="lineNum">    235 </span>              :        * </span>
<span class="lineNum">    236 </span>              :        *  The newly-created %vector uses a copy of the allocation </span>
<span class="lineNum">    237 </span>              :        *  object used by @a x.  All the elements of @a x are copied, </span>
<span class="lineNum">    238 </span>              :        *  but any extra memory in </span>
<span class="lineNum">    239 </span>              :        *  @a x (for fast expansion) will not be copied. </span>
<span class="lineNum">    240 </span>              :        */ </span>
<span class="lineNum">    241 </span>              :       vector(const vector&amp; __x) </span>
<span class="lineNum">    242 </span>              :       : _Base(__x.size(), __x._M_get_Tp_allocator()) </span>
<span class="lineNum">    243 </span>              :       { this-&gt;_M_impl._M_finish = </span>
<span class="lineNum">    244 </span>              : 	  std::__uninitialized_copy_a(__x.begin(), __x.end(), </span>
<span class="lineNum">    245 </span>              : 				      this-&gt;_M_impl._M_start, </span>
<span class="lineNum">    246 </span>              : 				      _M_get_Tp_allocator()); </span>
<span class="lineNum">    247 </span>              :       } </span>
<span class="lineNum">    248 </span>              :  </span>
<span class="lineNum">    249 </span>              : #ifdef __GXX_EXPERIMENTAL_CXX0X__ </span>
<span class="lineNum">    250 </span>              :       /** </span>
<span class="lineNum">    251 </span>              :        *  @brief  %Vector move constructor. </span>
<span class="lineNum">    252 </span>              :        *  @param  x  A %vector of identical element and allocator types. </span>
<span class="lineNum">    253 </span>              :        * </span>
<span class="lineNum">    254 </span>              :        *  The newly-created %vector contains the exact contents of @a x. </span>
<span class="lineNum">    255 </span>              :        *  The contents of @a x are a valid, but unspecified %vector. </span>
<span class="lineNum">    256 </span>              :        */ </span>
<span class="lineNum">    257 </span>              :       vector(vector&amp;&amp; __x) </span>
<span class="lineNum">    258 </span>              :       : _Base(std::forward&lt;_Base&gt;(__x)) { } </span>
<span class="lineNum">    259 </span>              :  </span>
<span class="lineNum">    260 </span>              :       /** </span>
<span class="lineNum">    261 </span>              :        *  @brief  Builds a %vector from an initializer list. </span>
<span class="lineNum">    262 </span>              :        *  @param  l  An initializer_list. </span>
<span class="lineNum">    263 </span>              :        *  @param  a  An allocator. </span>
<span class="lineNum">    264 </span>              :        * </span>
<span class="lineNum">    265 </span>              :        *  Create a %vector consisting of copies of the elements in the </span>
<span class="lineNum">    266 </span>              :        *  initializer_list @a l. </span>
<span class="lineNum">    267 </span>              :        * </span>
<span class="lineNum">    268 </span>              :        *  This will call the element type's copy constructor N times </span>
<span class="lineNum">    269 </span>              :        *  (where N is @a l.size()) and do no memory reallocation. </span>
<span class="lineNum">    270 </span>              :        */ </span>
<span class="lineNum">    271 </span>              :       vector(initializer_list&lt;value_type&gt; __l, </span>
<span class="lineNum">    272 </span>              : 	     const allocator_type&amp; __a = allocator_type()) </span>
<span class="lineNum">    273 </span>              :       : _Base(__a) </span>
<span class="lineNum">    274 </span>              :       { </span>
<span class="lineNum">    275 </span>              : 	_M_range_initialize(__l.begin(), __l.end(), </span>
<span class="lineNum">    276 </span>              : 			    random_access_iterator_tag()); </span>
<span class="lineNum">    277 </span>              :       } </span>
<span class="lineNum">    278 </span>              : #endif </span>
<span class="lineNum">    279 </span>              :  </span>
<span class="lineNum">    280 </span>              :       /** </span>
<span class="lineNum">    281 </span>              :        *  @brief  Builds a %vector from a range. </span>
<span class="lineNum">    282 </span>              :        *  @param  first  An input iterator. </span>
<span class="lineNum">    283 </span>              :        *  @param  last  An input iterator. </span>
<span class="lineNum">    284 </span>              :        *  @param  a  An allocator. </span>
<span class="lineNum">    285 </span>              :        * </span>
<span class="lineNum">    286 </span>              :        *  Create a %vector consisting of copies of the elements from </span>
<span class="lineNum">    287 </span>              :        *  [first,last). </span>
<span class="lineNum">    288 </span>              :        * </span>
<span class="lineNum">    289 </span>              :        *  If the iterators are forward, bidirectional, or </span>
<span class="lineNum">    290 </span>              :        *  random-access, then this will call the elements' copy </span>
<span class="lineNum">    291 </span>              :        *  constructor N times (where N is distance(first,last)) and do </span>
<span class="lineNum">    292 </span>              :        *  no memory reallocation.  But if only input iterators are </span>
<span class="lineNum">    293 </span>              :        *  used, then this will do at most 2N calls to the copy </span>
<span class="lineNum">    294 </span>              :        *  constructor, and logN memory reallocations. </span>
<span class="lineNum">    295 </span>              :        */ </span>
<span class="lineNum">    296 </span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">    297 </span>              :         vector(_InputIterator __first, _InputIterator __last, </span>
<span class="lineNum">    298 </span>              : 	       const allocator_type&amp; __a = allocator_type()) </span>
<span class="lineNum">    299 </span>              : 	: _Base(__a) </span>
<span class="lineNum">    300 </span>              :         { </span>
<span class="lineNum">    301 </span>              : 	  // Check whether it's an integral type.  If so, it's not an iterator. </span>
<span class="lineNum">    302 </span>              : 	  typedef typename std::__is_integer&lt;_InputIterator&gt;::__type _Integral; </span>
<span class="lineNum">    303 </span>              : 	  _M_initialize_dispatch(__first, __last, _Integral()); </span>
<span class="lineNum">    304 </span>              : 	} </span>
<span class="lineNum">    305 </span>              :  </span>
<span class="lineNum">    306 </span>              :       /** </span>
<span class="lineNum">    307 </span>              :        *  The dtor only erases the elements, and note that if the </span>
<span class="lineNum">    308 </span>              :        *  elements themselves are pointers, the pointed-to memory is </span>
<span class="lineNum">    309 </span>              :        *  not touched in any way.  Managing the pointer is the user's </span>
<span class="lineNum">    310 </span>              :        *  responsibility. </span>
<span class="lineNum">    311 </span>              :        */ </span>
<span class="lineNum">    312 </span>              :       ~vector() </span>
<span class="lineNum">    313 </span>              :       { std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">    314 </span>              : 		      _M_get_Tp_allocator()); } </span>
<span class="lineNum">    315 </span>              :  </span>
<span class="lineNum">    316 </span>              :       /** </span>
<span class="lineNum">    317 </span>              :        *  @brief  %Vector assignment operator. </span>
<span class="lineNum">    318 </span>              :        *  @param  x  A %vector of identical element and allocator types. </span>
<span class="lineNum">    319 </span>              :        * </span>
<span class="lineNum">    320 </span>              :        *  All the elements of @a x are copied, but any extra memory in </span>
<span class="lineNum">    321 </span>              :        *  @a x (for fast expansion) will not be copied.  Unlike the </span>
<span class="lineNum">    322 </span>              :        *  copy constructor, the allocator object is not copied. </span>
<span class="lineNum">    323 </span>              :        */ </span>
<span class="lineNum">    324 </span>              :       vector&amp; </span>
<span class="lineNum">    325 </span>              :       operator=(const vector&amp; __x); </span>
<span class="lineNum">    326 </span>              :  </span>
<span class="lineNum">    327 </span>              : #ifdef __GXX_EXPERIMENTAL_CXX0X__ </span>
<span class="lineNum">    328 </span>              :       /** </span>
<span class="lineNum">    329 </span>              :        *  @brief  %Vector move assignment operator. </span>
<span class="lineNum">    330 </span>              :        *  @param  x  A %vector of identical element and allocator types. </span>
<span class="lineNum">    331 </span>              :        * </span>
<span class="lineNum">    332 </span>              :        *  The contents of @a x are moved into this %vector (without copying). </span>
<span class="lineNum">    333 </span>              :        *  @a x is a valid, but unspecified %vector. </span>
<span class="lineNum">    334 </span>              :        */ </span>
<span class="lineNum">    335 </span>              :       vector&amp; </span>
<span class="lineNum">    336 </span>              :       operator=(vector&amp;&amp; __x) </span>
<span class="lineNum">    337 </span>              :       { </span>
<span class="lineNum">    338 </span>              : 	// NB: DR 675. </span>
<span class="lineNum">    339 </span>              : 	this-&gt;clear(); </span>
<span class="lineNum">    340 </span>              : 	this-&gt;swap(__x);  </span>
<span class="lineNum">    341 </span>              : 	return *this; </span>
<span class="lineNum">    342 </span>              :       } </span>
<span class="lineNum">    343 </span>              :  </span>
<span class="lineNum">    344 </span>              :       /** </span>
<span class="lineNum">    345 </span>              :        *  @brief  %Vector list assignment operator. </span>
<span class="lineNum">    346 </span>              :        *  @param  l  An initializer_list. </span>
<span class="lineNum">    347 </span>              :        * </span>
<span class="lineNum">    348 </span>              :        *  This function fills a %vector with copies of the elements in the </span>
<span class="lineNum">    349 </span>              :        *  initializer list @a l. </span>
<span class="lineNum">    350 </span>              :        * </span>
<span class="lineNum">    351 </span>              :        *  Note that the assignment completely changes the %vector and </span>
<span class="lineNum">    352 </span>              :        *  that the resulting %vector's size is the same as the number </span>
<span class="lineNum">    353 </span>              :        *  of elements assigned.  Old data may be lost. </span>
<span class="lineNum">    354 </span>              :        */ </span>
<span class="lineNum">    355 </span>              :       vector&amp; </span>
<span class="lineNum">    356 </span>              :       operator=(initializer_list&lt;value_type&gt; __l) </span>
<span class="lineNum">    357 </span>              :       { </span>
<span class="lineNum">    358 </span>              : 	this-&gt;assign(__l.begin(), __l.end()); </span>
<span class="lineNum">    359 </span>              : 	return *this; </span>
<span class="lineNum">    360 </span>              :       } </span>
<span class="lineNum">    361 </span>              : #endif </span>
<span class="lineNum">    362 </span>              :  </span>
<span class="lineNum">    363 </span>              :       /** </span>
<span class="lineNum">    364 </span>              :        *  @brief  Assigns a given value to a %vector. </span>
<span class="lineNum">    365 </span>              :        *  @param  n  Number of elements to be assigned. </span>
<span class="lineNum">    366 </span>              :        *  @param  val  Value to be assigned. </span>
<span class="lineNum">    367 </span>              :        * </span>
<span class="lineNum">    368 </span>              :        *  This function fills a %vector with @a n copies of the given </span>
<span class="lineNum">    369 </span>              :        *  value.  Note that the assignment completely changes the </span>
<span class="lineNum">    370 </span>              :        *  %vector and that the resulting %vector's size is the same as </span>
<span class="lineNum">    371 </span>              :        *  the number of elements assigned.  Old data may be lost. </span>
<span class="lineNum">    372 </span>              :        */ </span>
<span class="lineNum">    373 </span>              :       void </span>
<span class="lineNum">    374 </span>              :       assign(size_type __n, const value_type&amp; __val) </span>
<span class="lineNum">    375 </span>              :       { _M_fill_assign(__n, __val); } </span>
<span class="lineNum">    376 </span>              :  </span>
<span class="lineNum">    377 </span>              :       /** </span>
<span class="lineNum">    378 </span>              :        *  @brief  Assigns a range to a %vector. </span>
<span class="lineNum">    379 </span>              :        *  @param  first  An input iterator. </span>
<span class="lineNum">    380 </span>              :        *  @param  last   An input iterator. </span>
<span class="lineNum">    381 </span>              :        * </span>
<span class="lineNum">    382 </span>              :        *  This function fills a %vector with copies of the elements in the </span>
<span class="lineNum">    383 </span>              :        *  range [first,last). </span>
<span class="lineNum">    384 </span>              :        * </span>
<span class="lineNum">    385 </span>              :        *  Note that the assignment completely changes the %vector and </span>
<span class="lineNum">    386 </span>              :        *  that the resulting %vector's size is the same as the number </span>
<span class="lineNum">    387 </span>              :        *  of elements assigned.  Old data may be lost. </span>
<span class="lineNum">    388 </span>              :        */ </span>
<span class="lineNum">    389 </span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">    390 </span>              :         void </span>
<span class="lineNum">    391 </span>              :         assign(_InputIterator __first, _InputIterator __last) </span>
<span class="lineNum">    392 </span>              :         { </span>
<span class="lineNum">    393 </span>              : 	  // Check whether it's an integral type.  If so, it's not an iterator. </span>
<span class="lineNum">    394 </span>              : 	  typedef typename std::__is_integer&lt;_InputIterator&gt;::__type _Integral; </span>
<span class="lineNum">    395 </span>              : 	  _M_assign_dispatch(__first, __last, _Integral()); </span>
<span class="lineNum">    396 </span>              : 	} </span>
<span class="lineNum">    397 </span>              :  </span>
<span class="lineNum">    398 </span>              : #ifdef __GXX_EXPERIMENTAL_CXX0X__ </span>
<span class="lineNum">    399 </span>              :       /** </span>
<span class="lineNum">    400 </span>              :        *  @brief  Assigns an initializer list to a %vector. </span>
<span class="lineNum">    401 </span>              :        *  @param  l  An initializer_list. </span>
<span class="lineNum">    402 </span>              :        * </span>
<span class="lineNum">    403 </span>              :        *  This function fills a %vector with copies of the elements in the </span>
<span class="lineNum">    404 </span>              :        *  initializer list @a l. </span>
<span class="lineNum">    405 </span>              :        * </span>
<span class="lineNum">    406 </span>              :        *  Note that the assignment completely changes the %vector and </span>
<span class="lineNum">    407 </span>              :        *  that the resulting %vector's size is the same as the number </span>
<span class="lineNum">    408 </span>              :        *  of elements assigned.  Old data may be lost. </span>
<span class="lineNum">    409 </span>              :        */ </span>
<span class="lineNum">    410 </span>              :       void </span>
<span class="lineNum">    411 </span>              :       assign(initializer_list&lt;value_type&gt; __l) </span>
<span class="lineNum">    412 </span>              :       { this-&gt;assign(__l.begin(), __l.end()); } </span>
<span class="lineNum">    413 </span>              : #endif </span>
<span class="lineNum">    414 </span>              :  </span>
<span class="lineNum">    415 </span>              :       /// Get a copy of the memory allocation object. </span>
<span class="lineNum">    416 </span>              :       using _Base::get_allocator; </span>
<span class="lineNum">    417 </span>              :  </span>
<span class="lineNum">    418 </span>              :       // iterators </span>
<span class="lineNum">    419 </span>              :       /** </span>
<span class="lineNum">    420 </span>              :        *  Returns a read/write iterator that points to the first </span>
<span class="lineNum">    421 </span>              :        *  element in the %vector.  Iteration is done in ordinary </span>
<span class="lineNum">    422 </span>              :        *  element order. </span>
<span class="lineNum">    423 </span>              :        */ </span>
<span class="lineNum">    424 </span>              :       iterator </span>
<span class="lineNum">    425 </span>              :       begin() </span>
<span class="lineNum">    426 </span>              :       { return iterator(this-&gt;_M_impl._M_start); } </span>
<span class="lineNum">    427 </span>              :  </span>
<span class="lineNum">    428 </span>              :       /** </span>
<span class="lineNum">    429 </span>              :        *  Returns a read-only (constant) iterator that points to the </span>
<span class="lineNum">    430 </span>              :        *  first element in the %vector.  Iteration is done in ordinary </span>
<span class="lineNum">    431 </span>              :        *  element order. </span>
<span class="lineNum">    432 </span>              :        */ </span>
<span class="lineNum">    433 </span>              :       const_iterator </span>
<span class="lineNum">    434 </span>              :       begin() const </span>
<span class="lineNum">    435 </span>              :       { return const_iterator(this-&gt;_M_impl._M_start); } </span>
<span class="lineNum">    436 </span>              :  </span>
<span class="lineNum">    437 </span>              :       /** </span>
<span class="lineNum">    438 </span>              :        *  Returns a read/write iterator that points one past the last </span>
<span class="lineNum">    439 </span>              :        *  element in the %vector.  Iteration is done in ordinary </span>
<span class="lineNum">    440 </span>              :        *  element order. </span>
<span class="lineNum">    441 </span>              :        */ </span>
<span class="lineNum">    442 </span>              :       iterator </span>
<span class="lineNum">    443 </span>              :       end() </span>
<span class="lineNum">    444 </span>              :       { return iterator(this-&gt;_M_impl._M_finish); } </span>
<span class="lineNum">    445 </span>              :  </span>
<span class="lineNum">    446 </span>              :       /** </span>
<span class="lineNum">    447 </span>              :        *  Returns a read-only (constant) iterator that points one past </span>
<span class="lineNum">    448 </span>              :        *  the last element in the %vector.  Iteration is done in </span>
<span class="lineNum">    449 </span>              :        *  ordinary element order. </span>
<span class="lineNum">    450 </span>              :        */ </span>
<span class="lineNum">    451 </span>              :       const_iterator </span>
<span class="lineNum">    452 </span>              :       end() const </span>
<span class="lineNum">    453 </span>              :       { return const_iterator(this-&gt;_M_impl._M_finish); } </span>
<span class="lineNum">    454 </span>              :  </span>
<span class="lineNum">    455 </span>              :       /** </span>
<span class="lineNum">    456 </span>              :        *  Returns a read/write reverse iterator that points to the </span>
<span class="lineNum">    457 </span>              :        *  last element in the %vector.  Iteration is done in reverse </span>
<span class="lineNum">    458 </span>              :        *  element order. </span>
<span class="lineNum">    459 </span>              :        */ </span>
<span class="lineNum">    460 </span>              :       reverse_iterator </span>
<span class="lineNum">    461 </span>              :       rbegin() </span>
<span class="lineNum">    462 </span>              :       { return reverse_iterator(end()); } </span>
<span class="lineNum">    463 </span>              :  </span>
<span class="lineNum">    464 </span>              :       /** </span>
<span class="lineNum">    465 </span>              :        *  Returns a read-only (constant) reverse iterator that points </span>
<span class="lineNum">    466 </span>              :        *  to the last element in the %vector.  Iteration is done in </span>
<span class="lineNum">    467 </span>              :        *  reverse element order. </span>
<span class="lineNum">    468 </span>              :        */ </span>
<span class="lineNum">    469 </span>              :       const_reverse_iterator </span>
<span class="lineNum">    470 </span>              :       rbegin() const </span>
<span class="lineNum">    471 </span>              :       { return const_reverse_iterator(end()); } </span>
<span class="lineNum">    472 </span>              :  </span>
<span class="lineNum">    473 </span>              :       /** </span>
<span class="lineNum">    474 </span>              :        *  Returns a read/write reverse iterator that points to one </span>
<span class="lineNum">    475 </span>              :        *  before the first element in the %vector.  Iteration is done </span>
<span class="lineNum">    476 </span>              :        *  in reverse element order. </span>
<span class="lineNum">    477 </span>              :        */ </span>
<span class="lineNum">    478 </span>              :       reverse_iterator </span>
<span class="lineNum">    479 </span>              :       rend() </span>
<span class="lineNum">    480 </span>              :       { return reverse_iterator(begin()); } </span>
<span class="lineNum">    481 </span>              :  </span>
<span class="lineNum">    482 </span>              :       /** </span>
<span class="lineNum">    483 </span>              :        *  Returns a read-only (constant) reverse iterator that points </span>
<span class="lineNum">    484 </span>              :        *  to one before the first element in the %vector.  Iteration </span>
<span class="lineNum">    485 </span>              :        *  is done in reverse element order. </span>
<span class="lineNum">    486 </span>              :        */ </span>
<span class="lineNum">    487 </span>              :       const_reverse_iterator </span>
<span class="lineNum">    488 </span>              :       rend() const </span>
<span class="lineNum">    489 </span>              :       { return const_reverse_iterator(begin()); } </span>
<span class="lineNum">    490 </span>              :  </span>
<span class="lineNum">    491 </span>              : #ifdef __GXX_EXPERIMENTAL_CXX0X__ </span>
<span class="lineNum">    492 </span>              :       /** </span>
<span class="lineNum">    493 </span>              :        *  Returns a read-only (constant) iterator that points to the </span>
<span class="lineNum">    494 </span>              :        *  first element in the %vector.  Iteration is done in ordinary </span>
<span class="lineNum">    495 </span>              :        *  element order. </span>
<span class="lineNum">    496 </span>              :        */ </span>
<span class="lineNum">    497 </span>              :       const_iterator </span>
<span class="lineNum">    498 </span>              :       cbegin() const </span>
<span class="lineNum">    499 </span>              :       { return const_iterator(this-&gt;_M_impl._M_start); } </span>
<span class="lineNum">    500 </span>              :  </span>
<span class="lineNum">    501 </span>              :       /** </span>
<span class="lineNum">    502 </span>              :        *  Returns a read-only (constant) iterator that points one past </span>
<span class="lineNum">    503 </span>              :        *  the last element in the %vector.  Iteration is done in </span>
<span class="lineNum">    504 </span>              :        *  ordinary element order. </span>
<span class="lineNum">    505 </span>              :        */ </span>
<span class="lineNum">    506 </span>              :       const_iterator </span>
<span class="lineNum">    507 </span>              :       cend() const </span>
<span class="lineNum">    508 </span>              :       { return const_iterator(this-&gt;_M_impl._M_finish); } </span>
<span class="lineNum">    509 </span>              :  </span>
<span class="lineNum">    510 </span>              :       /** </span>
<span class="lineNum">    511 </span>              :        *  Returns a read-only (constant) reverse iterator that points </span>
<span class="lineNum">    512 </span>              :        *  to the last element in the %vector.  Iteration is done in </span>
<span class="lineNum">    513 </span>              :        *  reverse element order. </span>
<span class="lineNum">    514 </span>              :        */ </span>
<span class="lineNum">    515 </span>              :       const_reverse_iterator </span>
<span class="lineNum">    516 </span>              :       crbegin() const </span>
<span class="lineNum">    517 </span>              :       { return const_reverse_iterator(end()); } </span>
<span class="lineNum">    518 </span>              :  </span>
<span class="lineNum">    519 </span>              :       /** </span>
<span class="lineNum">    520 </span>              :        *  Returns a read-only (constant) reverse iterator that points </span>
<span class="lineNum">    521 </span>              :        *  to one before the first element in the %vector.  Iteration </span>
<span class="lineNum">    522 </span>              :        *  is done in reverse element order. </span>
<span class="lineNum">    523 </span>              :        */ </span>
<span class="lineNum">    524 </span>              :       const_reverse_iterator </span>
<span class="lineNum">    525 </span>              :       crend() const </span>
<span class="lineNum">    526 </span>              :       { return const_reverse_iterator(begin()); } </span>
<span class="lineNum">    527 </span>              : #endif </span>
<span class="lineNum">    528 </span>              :  </span>
<span class="lineNum">    529 </span>              :       // [23.2.4.2] capacity </span>
<span class="lineNum">    530 </span>              :       /**  Returns the number of elements in the %vector.  */ </span>
<span class="lineNum">    531 </span>              :       size_type </span>
<span class="lineNum">    532 </span>              :       size() const </span>
<span class="lineNum">    533 </span><span class="linePartCov">    1 / 3     :       { return size_type(this-&gt;_M_impl._M_finish - this-&gt;_M_impl._M_start); } </span>
<span class="lineNum">    534 </span>              :  </span>
<span class="lineNum">    535 </span>              :       /**  Returns the size() of the largest possible %vector.  */ </span>
<span class="lineNum">    536 </span>              :       size_type </span>
<span class="lineNum">    537 </span>              :       max_size() const </span>
<span class="lineNum">    538 </span>              :       { return _M_get_Tp_allocator().max_size(); } </span>
<span class="lineNum">    539 </span>              :  </span>
<span class="lineNum">    540 </span>              :       /** </span>
<span class="lineNum">    541 </span>              :        *  @brief  Resizes the %vector to the specified number of elements. </span>
<span class="lineNum">    542 </span>              :        *  @param  new_size  Number of elements the %vector should contain. </span>
<span class="lineNum">    543 </span>              :        *  @param  x  Data with which new elements should be populated. </span>
<span class="lineNum">    544 </span>              :        * </span>
<span class="lineNum">    545 </span>              :        *  This function will %resize the %vector to the specified </span>
<span class="lineNum">    546 </span>              :        *  number of elements.  If the number is smaller than the </span>
<span class="lineNum">    547 </span>              :        *  %vector's current size the %vector is truncated, otherwise </span>
<span class="lineNum">    548 </span>              :        *  the %vector is extended and new elements are populated with </span>
<span class="lineNum">    549 </span>              :        *  given data. </span>
<span class="lineNum">    550 </span>              :        */ </span>
<span class="lineNum">    551 </span>              :       void </span>
<span class="lineNum">    552 </span>              :       resize(size_type __new_size, value_type __x = value_type()) </span>
<span class="lineNum">    553 </span>              :       { </span>
<span class="lineNum">    554 </span>              : 	if (__new_size &lt; size()) </span>
<span class="lineNum">    555 </span>              : 	  _M_erase_at_end(this-&gt;_M_impl._M_start + __new_size); </span>
<span class="lineNum">    556 </span>              : 	else </span>
<span class="lineNum">    557 </span>              : 	  insert(end(), __new_size - size(), __x); </span>
<span class="lineNum">    558 </span>              :       } </span>
<span class="lineNum">    559 </span>              :  </span>
<span class="lineNum">    560 </span>              :       /** </span>
<span class="lineNum">    561 </span>              :        *  Returns the total number of elements that the %vector can </span>
<span class="lineNum">    562 </span>              :        *  hold before needing to allocate more memory. </span>
<span class="lineNum">    563 </span>              :        */ </span>
<span class="lineNum">    564 </span>              :       size_type </span>
<span class="lineNum">    565 </span>              :       capacity() const </span>
<span class="lineNum">    566 </span>              :       { return size_type(this-&gt;_M_impl._M_end_of_storage </span>
<span class="lineNum">    567 </span><span class="lineCov">    2 / 2     : 			 - this-&gt;_M_impl._M_start); } </span>
<span class="lineNum">    568 </span>              :  </span>
<span class="lineNum">    569 </span>              :       /** </span>
<span class="lineNum">    570 </span>              :        *  Returns true if the %vector is empty.  (Thus begin() would </span>
<span class="lineNum">    571 </span>              :        *  equal end().) </span>
<span class="lineNum">    572 </span>              :        */ </span>
<span class="lineNum">    573 </span>              :       bool </span>
<span class="lineNum">    574 </span>              :       empty() const </span>
<span class="lineNum">    575 </span>              :       { return begin() == end(); } </span>
<span class="lineNum">    576 </span>              :  </span>
<span class="lineNum">    577 </span>              :       /** </span>
<span class="lineNum">    578 </span>              :        *  @brief  Attempt to preallocate enough memory for specified number of </span>
<span class="lineNum">    579 </span>              :        *          elements. </span>
<span class="lineNum">    580 </span>              :        *  @param  n  Number of elements required. </span>
<span class="lineNum">    581 </span>              :        *  @throw  std::length_error  If @a n exceeds @c max_size(). </span>
<span class="lineNum">    582 </span>              :        * </span>
<span class="lineNum">    583 </span>              :        *  This function attempts to reserve enough memory for the </span>
<span class="lineNum">    584 </span>              :        *  %vector to hold the specified number of elements.  If the </span>
<span class="lineNum">    585 </span>              :        *  number requested is more than max_size(), length_error is </span>
<span class="lineNum">    586 </span>              :        *  thrown. </span>
<span class="lineNum">    587 </span>              :        * </span>
<span class="lineNum">    588 </span>              :        *  The advantage of this function is that if optimal code is a </span>
<span class="lineNum">    589 </span>              :        *  necessity and the user can determine the number of elements </span>
<span class="lineNum">    590 </span>              :        *  that will be required, the user can reserve the memory in </span>
<span class="lineNum">    591 </span>              :        *  %advance, and thus prevent a possible reallocation of memory </span>
<span class="lineNum">    592 </span>              :        *  and copying of %vector data. </span>
<span class="lineNum">    593 </span>              :        */ </span>
<span class="lineNum">    594 </span>              :       void </span>
<span class="lineNum">    595 </span>              :       reserve(size_type __n); </span>
<span class="lineNum">    596 </span>              :  </span>
<span class="lineNum">    597 </span>              :       // element access </span>
<span class="lineNum">    598 </span>              :       /** </span>
<span class="lineNum">    599 </span>              :        *  @brief  Subscript access to the data contained in the %vector. </span>
<span class="lineNum">    600 </span>              :        *  @param n The index of the element for which data should be </span>
<span class="lineNum">    601 </span>              :        *  accessed. </span>
<span class="lineNum">    602 </span>              :        *  @return  Read/write reference to data. </span>
<span class="lineNum">    603 </span>              :        * </span>
<span class="lineNum">    604 </span>              :        *  This operator allows for easy, array-style, data access. </span>
<span class="lineNum">    605 </span>              :        *  Note that data access with this operator is unchecked and </span>
<span class="lineNum">    606 </span>              :        *  out_of_range lookups are not defined. (For checked lookups </span>
<span class="lineNum">    607 </span>              :        *  see at().) </span>
<span class="lineNum">    608 </span>              :        */ </span>
<span class="lineNum">    609 </span>              :       reference </span>
<span class="lineNum">    610 </span>              :       operator[](size_type __n) </span>
<span class="lineNum">    611 </span>              :       { return *(this-&gt;_M_impl._M_start + __n); } </span>
<span class="lineNum">    612 </span>              :  </span>
<span class="lineNum">    613 </span>              :       /** </span>
<span class="lineNum">    614 </span>              :        *  @brief  Subscript access to the data contained in the %vector. </span>
<span class="lineNum">    615 </span>              :        *  @param n The index of the element for which data should be </span>
<span class="lineNum">    616 </span>              :        *  accessed. </span>
<span class="lineNum">    617 </span>              :        *  @return  Read-only (constant) reference to data. </span>
<span class="lineNum">    618 </span>              :        * </span>
<span class="lineNum">    619 </span>              :        *  This operator allows for easy, array-style, data access. </span>
<span class="lineNum">    620 </span>              :        *  Note that data access with this operator is unchecked and </span>
<span class="lineNum">    621 </span>              :        *  out_of_range lookups are not defined. (For checked lookups </span>
<span class="lineNum">    622 </span>              :        *  see at().) </span>
<span class="lineNum">    623 </span>              :        */ </span>
<span class="lineNum">    624 </span>              :       const_reference </span>
<span class="lineNum">    625 </span>              :       operator[](size_type __n) const </span>
<span class="lineNum">    626 </span>              :       { return *(this-&gt;_M_impl._M_start + __n); } </span>
<span class="lineNum">    627 </span>              :  </span>
<span class="lineNum">    628 </span>              :     protected: </span>
<span class="lineNum">    629 </span>              :       /// Safety check used only from at(). </span>
<span class="lineNum">    630 </span>              :       void </span>
<span class="lineNum">    631 </span>              :       _M_range_check(size_type __n) const </span>
<span class="lineNum">    632 </span>              :       { </span>
<span class="lineNum">    633 </span>              : 	if (__n &gt;= this-&gt;size()) </span>
<span class="lineNum">    634 </span>              : 	  __throw_out_of_range(__N(&quot;vector::_M_range_check&quot;)); </span>
<span class="lineNum">    635 </span>              :       } </span>
<span class="lineNum">    636 </span>              :  </span>
<span class="lineNum">    637 </span>              :     public: </span>
<span class="lineNum">    638 </span>              :       /** </span>
<span class="lineNum">    639 </span>              :        *  @brief  Provides access to the data contained in the %vector. </span>
<span class="lineNum">    640 </span>              :        *  @param n The index of the element for which data should be </span>
<span class="lineNum">    641 </span>              :        *  accessed. </span>
<span class="lineNum">    642 </span>              :        *  @return  Read/write reference to data. </span>
<span class="lineNum">    643 </span>              :        *  @throw  std::out_of_range  If @a n is an invalid index. </span>
<span class="lineNum">    644 </span>              :        * </span>
<span class="lineNum">    645 </span>              :        *  This function provides for safer data access.  The parameter </span>
<span class="lineNum">    646 </span>              :        *  is first checked that it is in the range of the vector.  The </span>
<span class="lineNum">    647 </span>              :        *  function throws out_of_range if the check fails. </span>
<span class="lineNum">    648 </span>              :        */ </span>
<span class="lineNum">    649 </span>              :       reference </span>
<span class="lineNum">    650 </span>              :       at(size_type __n) </span>
<span class="lineNum">    651 </span>              :       { </span>
<span class="lineNum">    652 </span>              : 	_M_range_check(__n); </span>
<span class="lineNum">    653 </span>              : 	return (*this)[__n];  </span>
<span class="lineNum">    654 </span>              :       } </span>
<span class="lineNum">    655 </span>              :  </span>
<span class="lineNum">    656 </span>              :       /** </span>
<span class="lineNum">    657 </span>              :        *  @brief  Provides access to the data contained in the %vector. </span>
<span class="lineNum">    658 </span>              :        *  @param n The index of the element for which data should be </span>
<span class="lineNum">    659 </span>              :        *  accessed. </span>
<span class="lineNum">    660 </span>              :        *  @return  Read-only (constant) reference to data. </span>
<span class="lineNum">    661 </span>              :        *  @throw  std::out_of_range  If @a n is an invalid index. </span>
<span class="lineNum">    662 </span>              :        * </span>
<span class="lineNum">    663 </span>              :        *  This function provides for safer data access.  The parameter </span>
<span class="lineNum">    664 </span>              :        *  is first checked that it is in the range of the vector.  The </span>
<span class="lineNum">    665 </span>              :        *  function throws out_of_range if the check fails. </span>
<span class="lineNum">    666 </span>              :        */ </span>
<span class="lineNum">    667 </span>              :       const_reference </span>
<span class="lineNum">    668 </span>              :       at(size_type __n) const </span>
<span class="lineNum">    669 </span>              :       { </span>
<span class="lineNum">    670 </span>              : 	_M_range_check(__n); </span>
<span class="lineNum">    671 </span>              : 	return (*this)[__n]; </span>
<span class="lineNum">    672 </span>              :       } </span>
<span class="lineNum">    673 </span>              :  </span>
<span class="lineNum">    674 </span>              :       /** </span>
<span class="lineNum">    675 </span>              :        *  Returns a read/write reference to the data at the first </span>
<span class="lineNum">    676 </span>              :        *  element of the %vector. </span>
<span class="lineNum">    677 </span>              :        */ </span>
<span class="lineNum">    678 </span>              :       reference </span>
<span class="lineNum">    679 </span>              :       front() </span>
<span class="lineNum">    680 </span>              :       { return *begin(); } </span>
<span class="lineNum">    681 </span>              :  </span>
<span class="lineNum">    682 </span>              :       /** </span>
<span class="lineNum">    683 </span>              :        *  Returns a read-only (constant) reference to the data at the first </span>
<span class="lineNum">    684 </span>              :        *  element of the %vector. </span>
<span class="lineNum">    685 </span>              :        */ </span>
<span class="lineNum">    686 </span>              :       const_reference </span>
<span class="lineNum">    687 </span>              :       front() const </span>
<span class="lineNum">    688 </span>              :       { return *begin(); } </span>
<span class="lineNum">    689 </span>              :  </span>
<span class="lineNum">    690 </span>              :       /** </span>
<span class="lineNum">    691 </span>              :        *  Returns a read/write reference to the data at the last </span>
<span class="lineNum">    692 </span>              :        *  element of the %vector. </span>
<span class="lineNum">    693 </span>              :        */ </span>
<span class="lineNum">    694 </span>              :       reference </span>
<span class="lineNum">    695 </span>              :       back() </span>
<span class="lineNum">    696 </span>              :       { return *(end() - 1); } </span>
<span class="lineNum">    697 </span>              :        </span>
<span class="lineNum">    698 </span>              :       /** </span>
<span class="lineNum">    699 </span>              :        *  Returns a read-only (constant) reference to the data at the </span>
<span class="lineNum">    700 </span>              :        *  last element of the %vector. </span>
<span class="lineNum">    701 </span>              :        */ </span>
<span class="lineNum">    702 </span>              :       const_reference </span>
<span class="lineNum">    703 </span>              :       back() const </span>
<span class="lineNum">    704 </span>              :       { return *(end() - 1); } </span>
<span class="lineNum">    705 </span>              :  </span>
<span class="lineNum">    706 </span>              :       // _GLIBCXX_RESOLVE_LIB_DEFECTS </span>
<span class="lineNum">    707 </span>              :       // DR 464. Suggestion for new member functions in standard containers. </span>
<span class="lineNum">    708 </span>              :       // data access </span>
<span class="lineNum">    709 </span>              :       /** </span>
<span class="lineNum">    710 </span>              :        *   Returns a pointer such that [data(), data() + size()) is a valid </span>
<span class="lineNum">    711 </span>              :        *   range.  For a non-empty %vector, data() == &amp;front(). </span>
<span class="lineNum">    712 </span>              :        */ </span>
<span class="lineNum">    713 </span>              :       pointer </span>
<span class="lineNum">    714 </span>              :       data() </span>
<span class="lineNum">    715 </span>              :       { return pointer(this-&gt;_M_impl._M_start); } </span>
<span class="lineNum">    716 </span>              :  </span>
<span class="lineNum">    717 </span>              :       const_pointer </span>
<span class="lineNum">    718 </span>              :       data() const </span>
<span class="lineNum">    719 </span>              :       { return const_pointer(this-&gt;_M_impl._M_start); } </span>
<span class="lineNum">    720 </span>              :  </span>
<span class="lineNum">    721 </span>              :       // [23.2.4.3] modifiers </span>
<span class="lineNum">    722 </span>              :       /** </span>
<span class="lineNum">    723 </span>              :        *  @brief  Add data to the end of the %vector. </span>
<span class="lineNum">    724 </span>              :        *  @param  x  Data to be added. </span>
<span class="lineNum">    725 </span>              :        * </span>
<span class="lineNum">    726 </span>              :        *  This is a typical stack operation.  The function creates an </span>
<span class="lineNum">    727 </span>              :        *  element at the end of the %vector and assigns the given data </span>
<span class="lineNum">    728 </span>              :        *  to it.  Due to the nature of a %vector this operation can be </span>
<span class="lineNum">    729 </span>              :        *  done in constant time if the %vector has preallocated space </span>
<span class="lineNum">    730 </span>              :        *  available. </span>
<span class="lineNum">    731 </span>              :        */ </span>
<span class="lineNum">    732 </span>              :       void </span>
<span class="lineNum">    733 </span>              :       push_back(const value_type&amp; __x) </span>
<span class="lineNum">    734 </span>              :       { </span>
<span class="lineNum">    735 </span><span class="linePartCov">    2 / 8     : 	if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage) </span>
<span class="lineNum">    736 </span>              : 	  { </span>
<span class="lineNum">    737 </span>              : 	    this-&gt;_M_impl.construct(this-&gt;_M_impl._M_finish, __x); </span>
<span class="lineNum">    738 </span><span class="linePartCov">    3 / 7     : 	    ++this-&gt;_M_impl._M_finish; </span>
<span class="lineNum">    739 </span>              : 	  } </span>
<span class="lineNum">    740 </span>              : 	else </span>
<span class="lineNum">    741 </span><span class="lineNoCov">    0 / 4     : 	  _M_insert_aux(end(), __x); </span>
<span class="lineNum">    742 </span>              :       } </span>
<span class="lineNum">    743 </span>              :  </span>
<span class="lineNum">    744 </span>              : #ifdef __GXX_EXPERIMENTAL_CXX0X__ </span>
<span class="lineNum">    745 </span>              :       void </span>
<span class="lineNum">    746 </span>              :       push_back(value_type&amp;&amp; __x) </span>
<span class="lineNum">    747 </span>              :       { emplace_back(std::move(__x)); } </span>
<span class="lineNum">    748 </span>              :  </span>
<span class="lineNum">    749 </span>              :       template&lt;typename... _Args&gt; </span>
<span class="lineNum">    750 </span>              :         void </span>
<span class="lineNum">    751 </span>              :         emplace_back(_Args&amp;&amp;... __args); </span>
<span class="lineNum">    752 </span>              : #endif </span>
<span class="lineNum">    753 </span>              :  </span>
<span class="lineNum">    754 </span>              :       /** </span>
<span class="lineNum">    755 </span>              :        *  @brief  Removes last element. </span>
<span class="lineNum">    756 </span>              :        * </span>
<span class="lineNum">    757 </span>              :        *  This is a typical stack operation. It shrinks the %vector by one. </span>
<span class="lineNum">    758 </span>              :        * </span>
<span class="lineNum">    759 </span>              :        *  Note that no data is returned, and if the last element's </span>
<span class="lineNum">    760 </span>              :        *  data is needed, it should be retrieved before pop_back() is </span>
<span class="lineNum">    761 </span>              :        *  called. </span>
<span class="lineNum">    762 </span>              :        */ </span>
<span class="lineNum">    763 </span>              :       void </span>
<span class="lineNum">    764 </span>              :       pop_back() </span>
<span class="lineNum">    765 </span>              :       { </span>
<span class="lineNum">    766 </span>              : 	--this-&gt;_M_impl._M_finish; </span>
<span class="lineNum">    767 </span>              : 	this-&gt;_M_impl.destroy(this-&gt;_M_impl._M_finish); </span>
<span class="lineNum">    768 </span>              :       } </span>
<span class="lineNum">    769 </span>              :  </span>
<span class="lineNum">    770 </span>              : #ifdef __GXX_EXPERIMENTAL_CXX0X__ </span>
<span class="lineNum">    771 </span>              :       /** </span>
<span class="lineNum">    772 </span>              :        *  @brief  Inserts an object in %vector before specified iterator. </span>
<span class="lineNum">    773 </span>              :        *  @param  position  An iterator into the %vector. </span>
<span class="lineNum">    774 </span>              :        *  @param  args  Arguments. </span>
<span class="lineNum">    775 </span>              :        *  @return  An iterator that points to the inserted data. </span>
<span class="lineNum">    776 </span>              :        * </span>
<span class="lineNum">    777 </span>              :        *  This function will insert an object of type T constructed </span>
<span class="lineNum">    778 </span>              :        *  with T(std::forward&lt;Args&gt;(args)...) before the specified location. </span>
<span class="lineNum">    779 </span>              :        *  Note that this kind of operation could be expensive for a %vector </span>
<span class="lineNum">    780 </span>              :        *  and if it is frequently used the user should consider using </span>
<span class="lineNum">    781 </span>              :        *  std::list. </span>
<span class="lineNum">    782 </span>              :        */ </span>
<span class="lineNum">    783 </span>              :       template&lt;typename... _Args&gt; </span>
<span class="lineNum">    784 </span>              :         iterator </span>
<span class="lineNum">    785 </span>              :         emplace(iterator __position, _Args&amp;&amp;... __args); </span>
<span class="lineNum">    786 </span>              : #endif </span>
<span class="lineNum">    787 </span>              :  </span>
<span class="lineNum">    788 </span>              :       /** </span>
<span class="lineNum">    789 </span>              :        *  @brief  Inserts given value into %vector before specified iterator. </span>
<span class="lineNum">    790 </span>              :        *  @param  position  An iterator into the %vector. </span>
<span class="lineNum">    791 </span>              :        *  @param  x  Data to be inserted. </span>
<span class="lineNum">    792 </span>              :        *  @return  An iterator that points to the inserted data. </span>
<span class="lineNum">    793 </span>              :        * </span>
<span class="lineNum">    794 </span>              :        *  This function will insert a copy of the given value before </span>
<span class="lineNum">    795 </span>              :        *  the specified location.  Note that this kind of operation </span>
<span class="lineNum">    796 </span>              :        *  could be expensive for a %vector and if it is frequently </span>
<span class="lineNum">    797 </span>              :        *  used the user should consider using std::list. </span>
<span class="lineNum">    798 </span>              :        */ </span>
<span class="lineNum">    799 </span>              :       iterator </span>
<span class="lineNum">    800 </span>              :       insert(iterator __position, const value_type&amp; __x); </span>
<span class="lineNum">    801 </span>              :  </span>
<span class="lineNum">    802 </span>              : #ifdef __GXX_EXPERIMENTAL_CXX0X__ </span>
<span class="lineNum">    803 </span>              :       /** </span>
<span class="lineNum">    804 </span>              :        *  @brief  Inserts given rvalue into %vector before specified iterator. </span>
<span class="lineNum">    805 </span>              :        *  @param  position  An iterator into the %vector. </span>
<span class="lineNum">    806 </span>              :        *  @param  x  Data to be inserted. </span>
<span class="lineNum">    807 </span>              :        *  @return  An iterator that points to the inserted data. </span>
<span class="lineNum">    808 </span>              :        * </span>
<span class="lineNum">    809 </span>              :        *  This function will insert a copy of the given rvalue before </span>
<span class="lineNum">    810 </span>              :        *  the specified location.  Note that this kind of operation </span>
<span class="lineNum">    811 </span>              :        *  could be expensive for a %vector and if it is frequently </span>
<span class="lineNum">    812 </span>              :        *  used the user should consider using std::list. </span>
<span class="lineNum">    813 </span>              :        */ </span>
<span class="lineNum">    814 </span>              :       iterator </span>
<span class="lineNum">    815 </span>              :       insert(iterator __position, value_type&amp;&amp; __x) </span>
<span class="lineNum">    816 </span>              :       { return emplace(__position, std::move(__x)); } </span>
<span class="lineNum">    817 </span>              :  </span>
<span class="lineNum">    818 </span>              :       /** </span>
<span class="lineNum">    819 </span>              :        *  @brief  Inserts an initializer_list into the %vector. </span>
<span class="lineNum">    820 </span>              :        *  @param  position  An iterator into the %vector. </span>
<span class="lineNum">    821 </span>              :        *  @param  l  An initializer_list. </span>
<span class="lineNum">    822 </span>              :        * </span>
<span class="lineNum">    823 </span>              :        *  This function will insert copies of the data in the  </span>
<span class="lineNum">    824 </span>              :        *  initializer_list @a l into the %vector before the location </span>
<span class="lineNum">    825 </span>              :        *  specified by @a position. </span>
<span class="lineNum">    826 </span>              :        * </span>
<span class="lineNum">    827 </span>              :        *  Note that this kind of operation could be expensive for a </span>
<span class="lineNum">    828 </span>              :        *  %vector and if it is frequently used the user should </span>
<span class="lineNum">    829 </span>              :        *  consider using std::list. </span>
<span class="lineNum">    830 </span>              :        */ </span>
<span class="lineNum">    831 </span>              :       void </span>
<span class="lineNum">    832 </span>              :       insert(iterator __position, initializer_list&lt;value_type&gt; __l) </span>
<span class="lineNum">    833 </span>              :       { this-&gt;insert(__position, __l.begin(), __l.end()); } </span>
<span class="lineNum">    834 </span>              : #endif </span>
<span class="lineNum">    835 </span>              :  </span>
<span class="lineNum">    836 </span>              :       /** </span>
<span class="lineNum">    837 </span>              :        *  @brief  Inserts a number of copies of given data into the %vector. </span>
<span class="lineNum">    838 </span>              :        *  @param  position  An iterator into the %vector. </span>
<span class="lineNum">    839 </span>              :        *  @param  n  Number of elements to be inserted. </span>
<span class="lineNum">    840 </span>              :        *  @param  x  Data to be inserted. </span>
<span class="lineNum">    841 </span>              :        * </span>
<span class="lineNum">    842 </span>              :        *  This function will insert a specified number of copies of </span>
<span class="lineNum">    843 </span>              :        *  the given data before the location specified by @a position. </span>
<span class="lineNum">    844 </span>              :        * </span>
<span class="lineNum">    845 </span>              :        *  Note that this kind of operation could be expensive for a </span>
<span class="lineNum">    846 </span>              :        *  %vector and if it is frequently used the user should </span>
<span class="lineNum">    847 </span>              :        *  consider using std::list. </span>
<span class="lineNum">    848 </span>              :        */ </span>
<span class="lineNum">    849 </span>              :       void </span>
<span class="lineNum">    850 </span>              :       insert(iterator __position, size_type __n, const value_type&amp; __x) </span>
<span class="lineNum">    851 </span>              :       { _M_fill_insert(__position, __n, __x); } </span>
<span class="lineNum">    852 </span>              :  </span>
<span class="lineNum">    853 </span>              :       /** </span>
<span class="lineNum">    854 </span>              :        *  @brief  Inserts a range into the %vector. </span>
<span class="lineNum">    855 </span>              :        *  @param  position  An iterator into the %vector. </span>
<span class="lineNum">    856 </span>              :        *  @param  first  An input iterator. </span>
<span class="lineNum">    857 </span>              :        *  @param  last   An input iterator. </span>
<span class="lineNum">    858 </span>              :        * </span>
<span class="lineNum">    859 </span>              :        *  This function will insert copies of the data in the range </span>
<span class="lineNum">    860 </span>              :        *  [first,last) into the %vector before the location specified </span>
<span class="lineNum">    861 </span>              :        *  by @a pos. </span>
<span class="lineNum">    862 </span>              :        * </span>
<span class="lineNum">    863 </span>              :        *  Note that this kind of operation could be expensive for a </span>
<span class="lineNum">    864 </span>              :        *  %vector and if it is frequently used the user should </span>
<span class="lineNum">    865 </span>              :        *  consider using std::list. </span>
<span class="lineNum">    866 </span>              :        */ </span>
<span class="lineNum">    867 </span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">    868 </span>              :         void </span>
<span class="lineNum">    869 </span>              :         insert(iterator __position, _InputIterator __first, </span>
<span class="lineNum">    870 </span>              : 	       _InputIterator __last) </span>
<span class="lineNum">    871 </span>              :         { </span>
<span class="lineNum">    872 </span>              : 	  // Check whether it's an integral type.  If so, it's not an iterator. </span>
<span class="lineNum">    873 </span>              : 	  typedef typename std::__is_integer&lt;_InputIterator&gt;::__type _Integral; </span>
<span class="lineNum">    874 </span>              : 	  _M_insert_dispatch(__position, __first, __last, _Integral()); </span>
<span class="lineNum">    875 </span>              : 	} </span>
<span class="lineNum">    876 </span>              :  </span>
<span class="lineNum">    877 </span>              :       /** </span>
<span class="lineNum">    878 </span>              :        *  @brief  Remove element at given position. </span>
<span class="lineNum">    879 </span>              :        *  @param  position  Iterator pointing to element to be erased. </span>
<span class="lineNum">    880 </span>              :        *  @return  An iterator pointing to the next element (or end()). </span>
<span class="lineNum">    881 </span>              :        * </span>
<span class="lineNum">    882 </span>              :        *  This function will erase the element at the given position and thus </span>
<span class="lineNum">    883 </span>              :        *  shorten the %vector by one. </span>
<span class="lineNum">    884 </span>              :        * </span>
<span class="lineNum">    885 </span>              :        *  Note This operation could be expensive and if it is </span>
<span class="lineNum">    886 </span>              :        *  frequently used the user should consider using std::list. </span>
<span class="lineNum">    887 </span>              :        *  The user is also cautioned that this function only erases </span>
<span class="lineNum">    888 </span>              :        *  the element, and that if the element is itself a pointer, </span>
<span class="lineNum">    889 </span>              :        *  the pointed-to memory is not touched in any way.  Managing </span>
<span class="lineNum">    890 </span>              :        *  the pointer is the user's responsibility. </span>
<span class="lineNum">    891 </span>              :        */ </span>
<span class="lineNum">    892 </span>              :       iterator </span>
<span class="lineNum">    893 </span>              :       erase(iterator __position); </span>
<span class="lineNum">    894 </span>              :  </span>
<span class="lineNum">    895 </span>              :       /** </span>
<span class="lineNum">    896 </span>              :        *  @brief  Remove a range of elements. </span>
<span class="lineNum">    897 </span>              :        *  @param  first  Iterator pointing to the first element to be erased. </span>
<span class="lineNum">    898 </span>              :        *  @param  last  Iterator pointing to one past the last element to be </span>
<span class="lineNum">    899 </span>              :        *                erased. </span>
<span class="lineNum">    900 </span>              :        *  @return  An iterator pointing to the element pointed to by @a last </span>
<span class="lineNum">    901 </span>              :        *           prior to erasing (or end()). </span>
<span class="lineNum">    902 </span>              :        * </span>
<span class="lineNum">    903 </span>              :        *  This function will erase the elements in the range [first,last) and </span>
<span class="lineNum">    904 </span>              :        *  shorten the %vector accordingly. </span>
<span class="lineNum">    905 </span>              :        * </span>
<span class="lineNum">    906 </span>              :        *  Note This operation could be expensive and if it is </span>
<span class="lineNum">    907 </span>              :        *  frequently used the user should consider using std::list. </span>
<span class="lineNum">    908 </span>              :        *  The user is also cautioned that this function only erases </span>
<span class="lineNum">    909 </span>              :        *  the elements, and that if the elements themselves are </span>
<span class="lineNum">    910 </span>              :        *  pointers, the pointed-to memory is not touched in any way. </span>
<span class="lineNum">    911 </span>              :        *  Managing the pointer is the user's responsibility. </span>
<span class="lineNum">    912 </span>              :        */ </span>
<span class="lineNum">    913 </span>              :       iterator </span>
<span class="lineNum">    914 </span>              :       erase(iterator __first, iterator __last); </span>
<span class="lineNum">    915 </span>              :  </span>
<span class="lineNum">    916 </span>              :       /** </span>
<span class="lineNum">    917 </span>              :        *  @brief  Swaps data with another %vector. </span>
<span class="lineNum">    918 </span>              :        *  @param  x  A %vector of the same element and allocator types. </span>
<span class="lineNum">    919 </span>              :        * </span>
<span class="lineNum">    920 </span>              :        *  This exchanges the elements between two vectors in constant time. </span>
<span class="lineNum">    921 </span>              :        *  (Three pointers, so it should be quite fast.) </span>
<span class="lineNum">    922 </span>              :        *  Note that the global std::swap() function is specialized such that </span>
<span class="lineNum">    923 </span>              :        *  std::swap(v1,v2) will feed to this function. </span>
<span class="lineNum">    924 </span>              :        */ </span>
<span class="lineNum">    925 </span>              :       void </span>
<span class="lineNum">    926 </span>              : #ifdef __GXX_EXPERIMENTAL_CXX0X__ </span>
<span class="lineNum">    927 </span>              :       swap(vector&amp;&amp; __x) </span>
<span class="lineNum">    928 </span>              : #else </span>
<span class="lineNum">    929 </span>              :       swap(vector&amp; __x) </span>
<span class="lineNum">    930 </span>              : #endif </span>
<span class="lineNum">    931 </span>              :       { </span>
<span class="lineNum">    932 </span>              : 	std::swap(this-&gt;_M_impl._M_start, __x._M_impl._M_start); </span>
<span class="lineNum">    933 </span>              : 	std::swap(this-&gt;_M_impl._M_finish, __x._M_impl._M_finish); </span>
<span class="lineNum">    934 </span>              : 	std::swap(this-&gt;_M_impl._M_end_of_storage, </span>
<span class="lineNum">    935 </span>              : 		  __x._M_impl._M_end_of_storage); </span>
<span class="lineNum">    936 </span>              :  </span>
<span class="lineNum">    937 </span>              : 	// _GLIBCXX_RESOLVE_LIB_DEFECTS </span>
<span class="lineNum">    938 </span>              : 	// 431. Swapping containers with unequal allocators. </span>
<span class="lineNum">    939 </span>              : 	std::__alloc_swap&lt;_Tp_alloc_type&gt;::_S_do_it(_M_get_Tp_allocator(), </span>
<span class="lineNum">    940 </span>              : 						    __x._M_get_Tp_allocator()); </span>
<span class="lineNum">    941 </span>              :       } </span>
<span class="lineNum">    942 </span>              :  </span>
<span class="lineNum">    943 </span>              :       /** </span>
<span class="lineNum">    944 </span>              :        *  Erases all the elements.  Note that this function only erases the </span>
<span class="lineNum">    945 </span>              :        *  elements, and that if the elements themselves are pointers, the </span>
<span class="lineNum">    946 </span>              :        *  pointed-to memory is not touched in any way.  Managing the pointer is </span>
<span class="lineNum">    947 </span>              :        *  the user's responsibility. </span>
<span class="lineNum">    948 </span>              :        */ </span>
<span class="lineNum">    949 </span>              :       void </span>
<span class="lineNum">    950 </span>              :       clear() </span>
<span class="lineNum">    951 </span>              :       { _M_erase_at_end(this-&gt;_M_impl._M_start); } </span>
<span class="lineNum">    952 </span>              :  </span>
<span class="lineNum">    953 </span>              :     protected: </span>
<span class="lineNum">    954 </span>              :       /** </span>
<span class="lineNum">    955 </span>              :        *  Memory expansion handler.  Uses the member allocation function to </span>
<span class="lineNum">    956 </span>              :        *  obtain @a n bytes of memory, and then copies [first,last) into it. </span>
<span class="lineNum">    957 </span>              :        */ </span>
<span class="lineNum">    958 </span>              :       template&lt;typename _ForwardIterator&gt; </span>
<span class="lineNum">    959 </span>              :         pointer </span>
<span class="lineNum">    960 </span>              :         _M_allocate_and_copy(size_type __n, </span>
<span class="lineNum">    961 </span>              : 			     _ForwardIterator __first, _ForwardIterator __last) </span>
<span class="lineNum">    962 </span>              :         { </span>
<span class="lineNum">    963 </span>              : 	  pointer __result = this-&gt;_M_allocate(__n); </span>
<span class="lineNum">    964 </span>              : 	  __try </span>
<span class="lineNum">    965 </span>              : 	    { </span>
<span class="lineNum">    966 </span>              : 	      std::__uninitialized_copy_a(__first, __last, __result, </span>
<span class="lineNum">    967 </span>              : 					  _M_get_Tp_allocator()); </span>
<span class="lineNum">    968 </span>              : 	      return __result; </span>
<span class="lineNum">    969 </span>              : 	    } </span>
<span class="lineNum">    970 </span>              : 	  __catch(...) </span>
<span class="lineNum">    971 </span>              : 	    { </span>
<span class="lineNum">    972 </span>              : 	      _M_deallocate(__result, __n); </span>
<span class="lineNum">    973 </span>              : 	      __throw_exception_again; </span>
<span class="lineNum">    974 </span>              : 	    } </span>
<span class="lineNum">    975 </span>              : 	} </span>
<span class="lineNum">    976 </span>              :  </span>
<span class="lineNum">    977 </span>              :  </span>
<span class="lineNum">    978 </span>              :       // Internal constructor functions follow. </span>
<span class="lineNum">    979 </span>              :  </span>
<span class="lineNum">    980 </span>              :       // Called by the range constructor to implement [23.1.1]/9 </span>
<span class="lineNum">    981 </span>              :  </span>
<span class="lineNum">    982 </span>              :       // _GLIBCXX_RESOLVE_LIB_DEFECTS </span>
<span class="lineNum">    983 </span>              :       // 438. Ambiguity in the &quot;do the right thing&quot; clause </span>
<span class="lineNum">    984 </span>              :       template&lt;typename _Integer&gt; </span>
<span class="lineNum">    985 </span>              :         void </span>
<span class="lineNum">    986 </span>              :         _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type) </span>
<span class="lineNum">    987 </span>              :         { </span>
<span class="lineNum">    988 </span>              : 	  this-&gt;_M_impl._M_start = _M_allocate(static_cast&lt;size_type&gt;(__n)); </span>
<span class="lineNum">    989 </span>              : 	  this-&gt;_M_impl._M_end_of_storage = </span>
<span class="lineNum">    990 </span>              : 	    this-&gt;_M_impl._M_start + static_cast&lt;size_type&gt;(__n); </span>
<span class="lineNum">    991 </span>              : 	  _M_fill_initialize(static_cast&lt;size_type&gt;(__n), __value); </span>
<span class="lineNum">    992 </span>              : 	} </span>
<span class="lineNum">    993 </span>              :  </span>
<span class="lineNum">    994 </span>              :       // Called by the range constructor to implement [23.1.1]/9 </span>
<span class="lineNum">    995 </span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">    996 </span>              :         void </span>
<span class="lineNum">    997 </span>              :         _M_initialize_dispatch(_InputIterator __first, _InputIterator __last, </span>
<span class="lineNum">    998 </span>              : 			       __false_type) </span>
<span class="lineNum">    999 </span>              :         { </span>
<span class="lineNum">   1000 </span>              : 	  typedef typename std::iterator_traits&lt;_InputIterator&gt;:: </span>
<span class="lineNum">   1001 </span>              : 	    iterator_category _IterCategory; </span>
<span class="lineNum">   1002 </span>              : 	  _M_range_initialize(__first, __last, _IterCategory()); </span>
<span class="lineNum">   1003 </span>              : 	} </span>
<span class="lineNum">   1004 </span>              :  </span>
<span class="lineNum">   1005 </span>              :       // Called by the second initialize_dispatch above </span>
<span class="lineNum">   1006 </span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">   1007 </span>              :         void </span>
<span class="lineNum">   1008 </span>              :         _M_range_initialize(_InputIterator __first, </span>
<span class="lineNum">   1009 </span>              : 			    _InputIterator __last, std::input_iterator_tag) </span>
<span class="lineNum">   1010 </span>              :         { </span>
<span class="lineNum">   1011 </span>              : 	  for (; __first != __last; ++__first) </span>
<span class="lineNum">   1012 </span>              : 	    push_back(*__first); </span>
<span class="lineNum">   1013 </span>              : 	} </span>
<span class="lineNum">   1014 </span>              :  </span>
<span class="lineNum">   1015 </span>              :       // Called by the second initialize_dispatch above </span>
<span class="lineNum">   1016 </span>              :       template&lt;typename _ForwardIterator&gt; </span>
<span class="lineNum">   1017 </span>              :         void </span>
<span class="lineNum">   1018 </span>              :         _M_range_initialize(_ForwardIterator __first, </span>
<span class="lineNum">   1019 </span>              : 			    _ForwardIterator __last, std::forward_iterator_tag) </span>
<span class="lineNum">   1020 </span>              :         { </span>
<span class="lineNum">   1021 </span>              : 	  const size_type __n = std::distance(__first, __last); </span>
<span class="lineNum">   1022 </span>              : 	  this-&gt;_M_impl._M_start = this-&gt;_M_allocate(__n); </span>
<span class="lineNum">   1023 </span>              : 	  this-&gt;_M_impl._M_end_of_storage = this-&gt;_M_impl._M_start + __n; </span>
<span class="lineNum">   1024 </span>              : 	  this-&gt;_M_impl._M_finish = </span>
<span class="lineNum">   1025 </span>              : 	    std::__uninitialized_copy_a(__first, __last, </span>
<span class="lineNum">   1026 </span>              : 					this-&gt;_M_impl._M_start, </span>
<span class="lineNum">   1027 </span>              : 					_M_get_Tp_allocator()); </span>
<span class="lineNum">   1028 </span>              : 	} </span>
<span class="lineNum">   1029 </span>              :  </span>
<span class="lineNum">   1030 </span>              :       // Called by the first initialize_dispatch above and by the </span>
<span class="lineNum">   1031 </span>              :       // vector(n,value,a) constructor. </span>
<span class="lineNum">   1032 </span>              :       void </span>
<span class="lineNum">   1033 </span>              :       _M_fill_initialize(size_type __n, const value_type&amp; __value) </span>
<span class="lineNum">   1034 </span>              :       { </span>
<span class="lineNum">   1035 </span>              : 	std::__uninitialized_fill_n_a(this-&gt;_M_impl._M_start, __n, __value,  </span>
<span class="lineNum">   1036 </span>              : 				      _M_get_Tp_allocator()); </span>
<span class="lineNum">   1037 </span>              : 	this-&gt;_M_impl._M_finish = this-&gt;_M_impl._M_end_of_storage; </span>
<span class="lineNum">   1038 </span>              :       } </span>
<span class="lineNum">   1039 </span>              :  </span>
<span class="lineNum">   1040 </span>              :  </span>
<span class="lineNum">   1041 </span>              :       // Internal assign functions follow.  The *_aux functions do the actual </span>
<span class="lineNum">   1042 </span>              :       // assignment work for the range versions. </span>
<span class="lineNum">   1043 </span>              :  </span>
<span class="lineNum">   1044 </span>              :       // Called by the range assign to implement [23.1.1]/9 </span>
<span class="lineNum">   1045 </span>              :  </span>
<span class="lineNum">   1046 </span>              :       // _GLIBCXX_RESOLVE_LIB_DEFECTS </span>
<span class="lineNum">   1047 </span>              :       // 438. Ambiguity in the &quot;do the right thing&quot; clause </span>
<span class="lineNum">   1048 </span>              :       template&lt;typename _Integer&gt; </span>
<span class="lineNum">   1049 </span>              :         void </span>
<span class="lineNum">   1050 </span>              :         _M_assign_dispatch(_Integer __n, _Integer __val, __true_type) </span>
<span class="lineNum">   1051 </span>              :         { _M_fill_assign(__n, __val); } </span>
<span class="lineNum">   1052 </span>              :  </span>
<span class="lineNum">   1053 </span>              :       // Called by the range assign to implement [23.1.1]/9 </span>
<span class="lineNum">   1054 </span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">   1055 </span>              :         void </span>
<span class="lineNum">   1056 </span>              :         _M_assign_dispatch(_InputIterator __first, _InputIterator __last, </span>
<span class="lineNum">   1057 </span>              : 			   __false_type) </span>
<span class="lineNum">   1058 </span>              :         { </span>
<span class="lineNum">   1059 </span>              : 	  typedef typename std::iterator_traits&lt;_InputIterator&gt;:: </span>
<span class="lineNum">   1060 </span>              : 	    iterator_category _IterCategory; </span>
<span class="lineNum">   1061 </span>              : 	  _M_assign_aux(__first, __last, _IterCategory()); </span>
<span class="lineNum">   1062 </span>              : 	} </span>
<span class="lineNum">   1063 </span>              :  </span>
<span class="lineNum">   1064 </span>              :       // Called by the second assign_dispatch above </span>
<span class="lineNum">   1065 </span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">   1066 </span>              :         void </span>
<span class="lineNum">   1067 </span>              :         _M_assign_aux(_InputIterator __first, _InputIterator __last, </span>
<span class="lineNum">   1068 </span>              : 		      std::input_iterator_tag); </span>
<span class="lineNum">   1069 </span>              :  </span>
<span class="lineNum">   1070 </span>              :       // Called by the second assign_dispatch above </span>
<span class="lineNum">   1071 </span>              :       template&lt;typename _ForwardIterator&gt; </span>
<span class="lineNum">   1072 </span>              :         void </span>
<span class="lineNum">   1073 </span>              :         _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, </span>
<span class="lineNum">   1074 </span>              : 		      std::forward_iterator_tag); </span>
<span class="lineNum">   1075 </span>              :  </span>
<span class="lineNum">   1076 </span>              :       // Called by assign(n,t), and the range assign when it turns out </span>
<span class="lineNum">   1077 </span>              :       // to be the same thing. </span>
<span class="lineNum">   1078 </span>              :       void </span>
<span class="lineNum">   1079 </span>              :       _M_fill_assign(size_type __n, const value_type&amp; __val); </span>
<span class="lineNum">   1080 </span>              :  </span>
<span class="lineNum">   1081 </span>              :  </span>
<span class="lineNum">   1082 </span>              :       // Internal insert functions follow. </span>
<span class="lineNum">   1083 </span>              :  </span>
<span class="lineNum">   1084 </span>              :       // Called by the range insert to implement [23.1.1]/9 </span>
<span class="lineNum">   1085 </span>              :  </span>
<span class="lineNum">   1086 </span>              :       // _GLIBCXX_RESOLVE_LIB_DEFECTS </span>
<span class="lineNum">   1087 </span>              :       // 438. Ambiguity in the &quot;do the right thing&quot; clause </span>
<span class="lineNum">   1088 </span>              :       template&lt;typename _Integer&gt; </span>
<span class="lineNum">   1089 </span>              :         void </span>
<span class="lineNum">   1090 </span>              :         _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val, </span>
<span class="lineNum">   1091 </span>              : 			   __true_type) </span>
<span class="lineNum">   1092 </span>              :         { _M_fill_insert(__pos, __n, __val); } </span>
<span class="lineNum">   1093 </span>              :  </span>
<span class="lineNum">   1094 </span>              :       // Called by the range insert to implement [23.1.1]/9 </span>
<span class="lineNum">   1095 </span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">   1096 </span>              :         void </span>
<span class="lineNum">   1097 </span>              :         _M_insert_dispatch(iterator __pos, _InputIterator __first, </span>
<span class="lineNum">   1098 </span>              : 			   _InputIterator __last, __false_type) </span>
<span class="lineNum">   1099 </span>              :         { </span>
<span class="lineNum">   1100 </span>              : 	  typedef typename std::iterator_traits&lt;_InputIterator&gt;:: </span>
<span class="lineNum">   1101 </span>              : 	    iterator_category _IterCategory; </span>
<span class="lineNum">   1102 </span>              : 	  _M_range_insert(__pos, __first, __last, _IterCategory()); </span>
<span class="lineNum">   1103 </span>              : 	} </span>
<span class="lineNum">   1104 </span>              :  </span>
<span class="lineNum">   1105 </span>              :       // Called by the second insert_dispatch above </span>
<span class="lineNum">   1106 </span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">   1107 </span>              :         void </span>
<span class="lineNum">   1108 </span>              :         _M_range_insert(iterator __pos, _InputIterator __first, </span>
<span class="lineNum">   1109 </span>              : 			_InputIterator __last, std::input_iterator_tag); </span>
<span class="lineNum">   1110 </span>              :  </span>
<span class="lineNum">   1111 </span>              :       // Called by the second insert_dispatch above </span>
<span class="lineNum">   1112 </span>              :       template&lt;typename _ForwardIterator&gt; </span>
<span class="lineNum">   1113 </span>              :         void </span>
<span class="lineNum">   1114 </span>              :         _M_range_insert(iterator __pos, _ForwardIterator __first, </span>
<span class="lineNum">   1115 </span>              : 			_ForwardIterator __last, std::forward_iterator_tag); </span>
<span class="lineNum">   1116 </span>              :  </span>
<span class="lineNum">   1117 </span>              :       // Called by insert(p,n,x), and the range insert when it turns out to be </span>
<span class="lineNum">   1118 </span>              :       // the same thing. </span>
<span class="lineNum">   1119 </span>              :       void </span>
<span class="lineNum">   1120 </span>              :       _M_fill_insert(iterator __pos, size_type __n, const value_type&amp; __x); </span>
<span class="lineNum">   1121 </span>              :  </span>
<span class="lineNum">   1122 </span>              :       // Called by insert(p,x) </span>
<span class="lineNum">   1123 </span>              : #ifndef __GXX_EXPERIMENTAL_CXX0X__ </span>
<span class="lineNum">   1124 </span>              :       void </span>
<span class="lineNum">   1125 </span>              :       _M_insert_aux(iterator __position, const value_type&amp; __x); </span>
<span class="lineNum">   1126 </span>              : #else </span>
<span class="lineNum">   1127 </span>              :       template&lt;typename... _Args&gt; </span>
<span class="lineNum">   1128 </span>              :         void </span>
<span class="lineNum">   1129 </span>              :         _M_insert_aux(iterator __position, _Args&amp;&amp;... __args); </span>
<span class="lineNum">   1130 </span>              : #endif </span>
<span class="lineNum">   1131 </span>              :  </span>
<span class="lineNum">   1132 </span>              :       // Called by the latter. </span>
<span class="lineNum">   1133 </span>              :       size_type </span>
<span class="lineNum">   1134 </span>              :       _M_check_len(size_type __n, const char* __s) const </span>
<span class="lineNum">   1135 </span>              :       { </span>
<span class="lineNum">   1136 </span>              : 	if (max_size() - size() &lt; __n) </span>
<span class="lineNum">   1137 </span>              : 	  __throw_length_error(__N(__s)); </span>
<span class="lineNum">   1138 </span>              :  </span>
<span class="lineNum">   1139 </span><span class="lineNoCov">    0 / 2     : 	const size_type __len = size() + std::max(size(), __n); </span>
<span class="lineNum">   1140 </span><span class="lineNoCov">    0 / 4     : 	return (__len &lt; size() || __len &gt; max_size()) ? max_size() : __len; </span>
<span class="lineNum">   1141 </span>              :       } </span>
<span class="lineNum">   1142 </span>              :  </span>
<span class="lineNum">   1143 </span>              :       // Internal erase functions follow. </span>
<span class="lineNum">   1144 </span>              :  </span>
<span class="lineNum">   1145 </span>              :       // Called by erase(q1,q2), clear(), resize(), _M_fill_assign, </span>
<span class="lineNum">   1146 </span>              :       // _M_assign_aux. </span>
<span class="lineNum">   1147 </span>              :       void </span>
<span class="lineNum">   1148 </span>              :       _M_erase_at_end(pointer __pos) </span>
<span class="lineNum">   1149 </span>              :       { </span>
<span class="lineNum">   1150 </span>              : 	std::_Destroy(__pos, this-&gt;_M_impl._M_finish, _M_get_Tp_allocator()); </span>
<span class="lineNum">   1151 </span><span class="linePartCov">    2 / 4     : 	this-&gt;_M_impl._M_finish = __pos; </span>
<span class="lineNum">   1152 </span>              :       } </span>
<span class="lineNum">   1153 </span>              :     }; </span>
<span class="lineNum">   1154 </span>              :  </span>
<span class="lineNum">   1155 </span>              :  </span>
<span class="lineNum">   1156 </span>              :   /** </span>
<span class="lineNum">   1157 </span>              :    *  @brief  Vector equality comparison. </span>
<span class="lineNum">   1158 </span>              :    *  @param  x  A %vector. </span>
<span class="lineNum">   1159 </span>              :    *  @param  y  A %vector of the same type as @a x. </span>
<span class="lineNum">   1160 </span>              :    *  @return  True iff the size and elements of the vectors are equal. </span>
<span class="lineNum">   1161 </span>              :    * </span>
<span class="lineNum">   1162 </span>              :    *  This is an equivalence relation.  It is linear in the size of the </span>
<span class="lineNum">   1163 </span>              :    *  vectors.  Vectors are considered equivalent if their sizes are equal, </span>
<span class="lineNum">   1164 </span>              :    *  and if corresponding elements compare equal. </span>
<span class="lineNum">   1165 </span>              :   */ </span>
<span class="lineNum">   1166 </span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">   1167 </span>              :     inline bool </span>
<span class="lineNum">   1168 </span>              :     operator==(const vector&lt;_Tp, _Alloc&gt;&amp; __x, const vector&lt;_Tp, _Alloc&gt;&amp; __y) </span>
<span class="lineNum">   1169 </span>              :     { return (__x.size() == __y.size() </span>
<span class="lineNum">   1170 </span>              : 	      &amp;&amp; std::equal(__x.begin(), __x.end(), __y.begin())); } </span>
<span class="lineNum">   1171 </span>              :  </span>
<span class="lineNum">   1172 </span>              :   /** </span>
<span class="lineNum">   1173 </span>              :    *  @brief  Vector ordering relation. </span>
<span class="lineNum">   1174 </span>              :    *  @param  x  A %vector. </span>
<span class="lineNum">   1175 </span>              :    *  @param  y  A %vector of the same type as @a x. </span>
<span class="lineNum">   1176 </span>              :    *  @return  True iff @a x is lexicographically less than @a y. </span>
<span class="lineNum">   1177 </span>              :    * </span>
<span class="lineNum">   1178 </span>              :    *  This is a total ordering relation.  It is linear in the size of the </span>
<span class="lineNum">   1179 </span>              :    *  vectors.  The elements must be comparable with @c &lt;. </span>
<span class="lineNum">   1180 </span>              :    * </span>
<span class="lineNum">   1181 </span>              :    *  See std::lexicographical_compare() for how the determination is made. </span>
<span class="lineNum">   1182 </span>              :   */ </span>
<span class="lineNum">   1183 </span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">   1184 </span>              :     inline bool </span>
<span class="lineNum">   1185 </span>              :     operator&lt;(const vector&lt;_Tp, _Alloc&gt;&amp; __x, const vector&lt;_Tp, _Alloc&gt;&amp; __y) </span>
<span class="lineNum">   1186 </span>              :     { return std::lexicographical_compare(__x.begin(), __x.end(), </span>
<span class="lineNum">   1187 </span>              : 					  __y.begin(), __y.end()); } </span>
<span class="lineNum">   1188 </span>              :  </span>
<span class="lineNum">   1189 </span>              :   /// Based on operator== </span>
<span class="lineNum">   1190 </span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">   1191 </span>              :     inline bool </span>
<span class="lineNum">   1192 </span>              :     operator!=(const vector&lt;_Tp, _Alloc&gt;&amp; __x, const vector&lt;_Tp, _Alloc&gt;&amp; __y) </span>
<span class="lineNum">   1193 </span>              :     { return !(__x == __y); } </span>
<span class="lineNum">   1194 </span>              :  </span>
<span class="lineNum">   1195 </span>              :   /// Based on operator&lt; </span>
<span class="lineNum">   1196 </span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">   1197 </span>              :     inline bool </span>
<span class="lineNum">   1198 </span>              :     operator&gt;(const vector&lt;_Tp, _Alloc&gt;&amp; __x, const vector&lt;_Tp, _Alloc&gt;&amp; __y) </span>
<span class="lineNum">   1199 </span>              :     { return __y &lt; __x; } </span>
<span class="lineNum">   1200 </span>              :  </span>
<span class="lineNum">   1201 </span>              :   /// Based on operator&lt; </span>
<span class="lineNum">   1202 </span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">   1203 </span>              :     inline bool </span>
<span class="lineNum">   1204 </span>              :     operator&lt;=(const vector&lt;_Tp, _Alloc&gt;&amp; __x, const vector&lt;_Tp, _Alloc&gt;&amp; __y) </span>
<span class="lineNum">   1205 </span>              :     { return !(__y &lt; __x); } </span>
<span class="lineNum">   1206 </span>              :  </span>
<span class="lineNum">   1207 </span>              :   /// Based on operator&lt; </span>
<span class="lineNum">   1208 </span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">   1209 </span>              :     inline bool </span>
<span class="lineNum">   1210 </span>              :     operator&gt;=(const vector&lt;_Tp, _Alloc&gt;&amp; __x, const vector&lt;_Tp, _Alloc&gt;&amp; __y) </span>
<span class="lineNum">   1211 </span>              :     { return !(__x &lt; __y); } </span>
<span class="lineNum">   1212 </span>              :  </span>
<span class="lineNum">   1213 </span>              :   /// See std::vector::swap(). </span>
<span class="lineNum">   1214 </span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">   1215 </span>              :     inline void </span>
<span class="lineNum">   1216 </span>              :     swap(vector&lt;_Tp, _Alloc&gt;&amp; __x, vector&lt;_Tp, _Alloc&gt;&amp; __y) </span>
<span class="lineNum">   1217 </span>              :     { __x.swap(__y); } </span>
<span class="lineNum">   1218 </span>              :  </span>
<span class="lineNum">   1219 </span>              : #ifdef __GXX_EXPERIMENTAL_CXX0X__ </span>
<span class="lineNum">   1220 </span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">   1221 </span>              :     inline void </span>
<span class="lineNum">   1222 </span>              :     swap(vector&lt;_Tp, _Alloc&gt;&amp;&amp; __x, vector&lt;_Tp, _Alloc&gt;&amp; __y) </span>
<span class="lineNum">   1223 </span>              :     { __x.swap(__y); } </span>
<span class="lineNum">   1224 </span>              :  </span>
<span class="lineNum">   1225 </span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">   1226 </span>              :     inline void </span>
<span class="lineNum">   1227 </span>              :     swap(vector&lt;_Tp, _Alloc&gt;&amp; __x, vector&lt;_Tp, _Alloc&gt;&amp;&amp; __y) </span>
<span class="lineNum">   1228 </span>              :     { __x.swap(__y); } </span>
<span class="lineNum">   1229 </span>              : #endif </span>
<span class="lineNum">   1230 </span>              :  </span>
<span class="lineNum">   1231 </span>              : _GLIBCXX_END_NESTED_NAMESPACE </span>
<span class="lineNum">   1232 </span>              :  </span>
<span class="lineNum">   1233 </span>              : #endif /* _STL_VECTOR_H */ </span>
</pre>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr><td class="versionInfo">Generated by: <a href="http://simonkagstrom.github.com/kcov/index.html">Kcov</a> (based on <a href="http://bcov.sourceforge.net">bcov</a>)</td></tr>
</table>
<br/>
</body>
</html>
