<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Coverage - kcov</title>
  <link rel="stylesheet" type="text/css" href="bcov.css"/>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="title">Coverage Report</td></tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr>
    <td width="100%">
      <table cellpadding="1" border="0" width="100%">
        <tr>
          <td class="headerItem" width="20%">Command:</td>
          <td class="headerValue" width="80%" colspan=6>kcov</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Date:</td>
          <td class="headerValue" width="15%">2014-03-01 10:11:51</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Instrumented&nbsp;lines:</td>
          <td class="headerValue" width="10%">36</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Code&nbsp;covered:</td>
          <td class="coverPerLeftHi" width="15%">86.1%</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Executed&nbsp;lines:</td>
          <td class="headerValue" width="10%">31</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
</table>
<pre class="source">
<span class="lineNum">    1</span>              : &#047;&#047; Components for manipulating sequences of characters -*- C++ -*- </span>
<span class="lineNum">    2</span>              :  </span>
<span class="lineNum">    3</span>              : &#047;&#047; Copyright (C) 1997-2013 Free Software Foundation, Inc. </span>
<span class="lineNum">    4</span>              : &#047;&#047; </span>
<span class="lineNum">    5</span>              : &#047;&#047; This file is part of the GNU ISO C++ Library.  This library is free </span>
<span class="lineNum">    6</span>              : &#047;&#047; software; you can redistribute it and&#047;or modify it under the </span>
<span class="lineNum">    7</span>              : &#047;&#047; terms of the GNU General Public License as published by the </span>
<span class="lineNum">    8</span>              : &#047;&#047; Free Software Foundation; either version 3, or (at your option) </span>
<span class="lineNum">    9</span>              : &#047;&#047; any later version. </span>
<span class="lineNum">   10</span>              :  </span>
<span class="lineNum">   11</span>              : &#047;&#047; This library is distributed in the hope that it will be useful, </span>
<span class="lineNum">   12</span>              : &#047;&#047; but WITHOUT ANY WARRANTY; without even the implied warranty of </span>
<span class="lineNum">   13</span>              : &#047;&#047; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the </span>
<span class="lineNum">   14</span>              : &#047;&#047; GNU General Public License for more details. </span>
<span class="lineNum">   15</span>              :  </span>
<span class="lineNum">   16</span>              : &#047;&#047; Under Section 7 of GPL version 3, you are granted additional </span>
<span class="lineNum">   17</span>              : &#047;&#047; permissions described in the GCC Runtime Library Exception, version </span>
<span class="lineNum">   18</span>              : &#047;&#047; 3.1, as published by the Free Software Foundation. </span>
<span class="lineNum">   19</span>              :  </span>
<span class="lineNum">   20</span>              : &#047;&#047; You should have received a copy of the GNU General Public License and </span>
<span class="lineNum">   21</span>              : &#047;&#047; a copy of the GCC Runtime Library Exception along with this program; </span>
<span class="lineNum">   22</span>              : &#047;&#047; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see </span>
<span class="lineNum">   23</span>              : &#047;&#047; &lt;http:&#047;&#047;www.gnu.org&#047;licenses&#047;&gt;. </span>
<span class="lineNum">   24</span>              :  </span>
<span class="lineNum">   25</span>              : &#047;** @file bits&#047;basic_string.h </span>
<span class="lineNum">   26</span>              :  *  This is an internal header file, included by other library headers. </span>
<span class="lineNum">   27</span>              :  *  Do not attempt to use it directly. @headername{string} </span>
<span class="lineNum">   28</span>              :  *&#047; </span>
<span class="lineNum">   29</span>              :  </span>
<span class="lineNum">   30</span>              : &#047;&#047; </span>
<span class="lineNum">   31</span>              : &#047;&#047; ISO C++ 14882: 21 Strings library </span>
<span class="lineNum">   32</span>              : &#047;&#047; </span>
<span class="lineNum">   33</span>              :  </span>
<span class="lineNum">   34</span>              : #ifndef _BASIC_STRING_H </span>
<span class="lineNum">   35</span>              : #define _BASIC_STRING_H 1 </span>
<span class="lineNum">   36</span>              :  </span>
<span class="lineNum">   37</span>              : #pragma GCC system_header </span>
<span class="lineNum">   38</span>              :  </span>
<span class="lineNum">   39</span>              : #include &lt;ext&#047;atomicity.h&gt; </span>
<span class="lineNum">   40</span>              : #include &lt;debug&#047;debug.h&gt; </span>
<span class="lineNum">   41</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">   42</span>              : #include &lt;initializer_list&gt; </span>
<span class="lineNum">   43</span>              : #endif </span>
<span class="lineNum">   44</span>              :  </span>
<span class="lineNum">   45</span>              : namespace std _GLIBCXX_VISIBILITY(default) </span>
<span class="lineNum">   46</span>              : { </span>
<span class="lineNum">   47</span>              : _GLIBCXX_BEGIN_NAMESPACE_VERSION </span>
<span class="lineNum">   48</span>              :  </span>
<span class="lineNum">   49</span>              :   &#047;** </span>
<span class="lineNum">   50</span>              :    *  @class basic_string basic_string.h &lt;string&gt; </span>
<span class="lineNum">   51</span>              :    *  @brief  Managing sequences of characters and character-like objects. </span>
<span class="lineNum">   52</span>              :    * </span>
<span class="lineNum">   53</span>              :    *  @ingroup strings </span>
<span class="lineNum">   54</span>              :    *  @ingroup sequences </span>
<span class="lineNum">   55</span>              :    * </span>
<span class="lineNum">   56</span>              :    *  @tparam _CharT  Type of character </span>
<span class="lineNum">   57</span>              :    *  @tparam _Traits  Traits for character type, defaults to </span>
<span class="lineNum">   58</span>              :    *                   char_traits&lt;_CharT&gt;. </span>
<span class="lineNum">   59</span>              :    *  @tparam _Alloc  Allocator type, defaults to allocator&lt;_CharT&gt;. </span>
<span class="lineNum">   60</span>              :    * </span>
<span class="lineNum">   61</span>              :    *  Meets the requirements of a &lt;a href=&quot;tables.html#65&quot;&gt;container&lt;&#047;a&gt;, a </span>
<span class="lineNum">   62</span>              :    *  &lt;a href=&quot;tables.html#66&quot;&gt;reversible container&lt;&#047;a&gt;, and a </span>
<span class="lineNum">   63</span>              :    *  &lt;a href=&quot;tables.html#67&quot;&gt;sequence&lt;&#047;a&gt;.  Of the </span>
<span class="lineNum">   64</span>              :    *  &lt;a href=&quot;tables.html#68&quot;&gt;optional sequence requirements&lt;&#047;a&gt;, only </span>
<span class="lineNum">   65</span>              :    *  @c push_back, @c at, and @c %array access are supported. </span>
<span class="lineNum">   66</span>              :    * </span>
<span class="lineNum">   67</span>              :    *  @doctodo </span>
<span class="lineNum">   68</span>              :    * </span>
<span class="lineNum">   69</span>              :    * </span>
<span class="lineNum">   70</span>              :    *  Documentation?  What&#039;s that? </span>
<span class="lineNum">   71</span>              :    *  Nathan Myers &lt;ncm@cantrip.org&gt;. </span>
<span class="lineNum">   72</span>              :    * </span>
<span class="lineNum">   73</span>              :    *  A string looks like this: </span>
<span class="lineNum">   74</span>              :    * </span>
<span class="lineNum">   75</span>              :    *  @code </span>
<span class="lineNum">   76</span>              :    *                                        [_Rep] </span>
<span class="lineNum">   77</span>              :    *                                        _M_length </span>
<span class="lineNum">   78</span>              :    *   [basic_string&lt;char_type&gt;]            _M_capacity </span>
<span class="lineNum">   79</span>              :    *   _M_dataplus                          _M_refcount </span>
<span class="lineNum">   80</span>              :    *   _M_p ----------------&gt;               unnamed array of char_type </span>
<span class="lineNum">   81</span>              :    *  @endcode </span>
<span class="lineNum">   82</span>              :    * </span>
<span class="lineNum">   83</span>              :    *  Where the _M_p points to the first character in the string, and </span>
<span class="lineNum">   84</span>              :    *  you cast it to a pointer-to-_Rep and subtract 1 to get a </span>
<span class="lineNum">   85</span>              :    *  pointer to the header. </span>
<span class="lineNum">   86</span>              :    * </span>
<span class="lineNum">   87</span>              :    *  This approach has the enormous advantage that a string object </span>
<span class="lineNum">   88</span>              :    *  requires only one allocation.  All the ugliness is confined </span>
<span class="lineNum">   89</span>              :    *  within a single %pair of inline functions, which each compile to </span>
<span class="lineNum">   90</span>              :    *  a single @a add instruction: _Rep::_M_data(), and </span>
<span class="lineNum">   91</span>              :    *  string::_M_rep(); and the allocation function which gets a </span>
<span class="lineNum">   92</span>              :    *  block of raw bytes and with room enough and constructs a _Rep </span>
<span class="lineNum">   93</span>              :    *  object at the front. </span>
<span class="lineNum">   94</span>              :    * </span>
<span class="lineNum">   95</span>              :    *  The reason you want _M_data pointing to the character %array and </span>
<span class="lineNum">   96</span>              :    *  not the _Rep is so that the debugger can see the string </span>
<span class="lineNum">   97</span>              :    *  contents. (Probably we should add a non-inline member to get </span>
<span class="lineNum">   98</span>              :    *  the _Rep for the debugger to use, so users can check the actual </span>
<span class="lineNum">   99</span>              :    *  string length.) </span>
<span class="lineNum">  100</span>              :    * </span>
<span class="lineNum">  101</span>              :    *  Note that the _Rep object is a POD so that you can have a </span>
<span class="lineNum">  102</span>              :    *  static &lt;em&gt;empty string&lt;&#047;em&gt; _Rep object already @a constructed before </span>
<span class="lineNum">  103</span>              :    *  static constructors have run.  The reference-count encoding is </span>
<span class="lineNum">  104</span>              :    *  chosen so that a 0 indicates one reference, so you never try to </span>
<span class="lineNum">  105</span>              :    *  destroy the empty-string _Rep object. </span>
<span class="lineNum">  106</span>              :    * </span>
<span class="lineNum">  107</span>              :    *  All but the last paragraph is considered pretty conventional </span>
<span class="lineNum">  108</span>              :    *  for a C++ string implementation. </span>
<span class="lineNum">  109</span>              :   *&#047; </span>
<span class="lineNum">  110</span>              :   &#047;&#047; 21.3  Template class basic_string </span>
<span class="lineNum">  111</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum">  112</span>              :     class basic_string </span>
<span class="lineNum">  113</span>              :     { </span>
<span class="lineNum">  114</span>              :       typedef typename _Alloc::template rebind&lt;_CharT&gt;::other _CharT_alloc_type; </span>
<span class="lineNum">  115</span>              :  </span>
<span class="lineNum">  116</span>              :       &#047;&#047; Types: </span>
<span class="lineNum">  117</span>              :     public: </span>
<span class="lineNum">  118</span>              :       typedef _Traits					    traits_type; </span>
<span class="lineNum">  119</span>              :       typedef typename _Traits::char_type		    value_type; </span>
<span class="lineNum">  120</span>              :       typedef _Alloc					    allocator_type; </span>
<span class="lineNum">  121</span>              :       typedef typename _CharT_alloc_type::size_type	    size_type; </span>
<span class="lineNum">  122</span>              :       typedef typename _CharT_alloc_type::difference_type   difference_type; </span>
<span class="lineNum">  123</span>              :       typedef typename _CharT_alloc_type::reference	    reference; </span>
<span class="lineNum">  124</span>              :       typedef typename _CharT_alloc_type::const_reference   const_reference; </span>
<span class="lineNum">  125</span>              :       typedef typename _CharT_alloc_type::pointer	    pointer; </span>
<span class="lineNum">  126</span>              :       typedef typename _CharT_alloc_type::const_pointer	    const_pointer; </span>
<span class="lineNum">  127</span>              :       typedef __gnu_cxx::__normal_iterator&lt;pointer, basic_string&gt;  iterator; </span>
<span class="lineNum">  128</span>              :       typedef __gnu_cxx::__normal_iterator&lt;const_pointer, basic_string&gt; </span>
<span class="lineNum">  129</span>              :                                                             const_iterator; </span>
<span class="lineNum">  130</span>              :       typedef std::reverse_iterator&lt;const_iterator&gt;	const_reverse_iterator; </span>
<span class="lineNum">  131</span>              :       typedef std::reverse_iterator&lt;iterator&gt;		    reverse_iterator; </span>
<span class="lineNum">  132</span>              :  </span>
<span class="lineNum">  133</span>              :     private: </span>
<span class="lineNum">  134</span>              :       &#047;&#047; _Rep: string representation </span>
<span class="lineNum">  135</span>              :       &#047;&#047;   Invariants: </span>
<span class="lineNum">  136</span>              :       &#047;&#047;   1. String really contains _M_length + 1 characters: due to 21.3.4 </span>
<span class="lineNum">  137</span>              :       &#047;&#047;      must be kept null-terminated. </span>
<span class="lineNum">  138</span>              :       &#047;&#047;   2. _M_capacity &gt;= _M_length </span>
<span class="lineNum">  139</span>              :       &#047;&#047;      Allocated memory is always (_M_capacity + 1) * sizeof(_CharT). </span>
<span class="lineNum">  140</span>              :       &#047;&#047;   3. _M_refcount has three states: </span>
<span class="lineNum">  141</span>              :       &#047;&#047;      -1: leaked, one reference, no ref-copies allowed, non-const. </span>
<span class="lineNum">  142</span>              :       &#047;&#047;       0: one reference, non-const. </span>
<span class="lineNum">  143</span>              :       &#047;&#047;     n&gt;0: n + 1 references, operations require a lock, const. </span>
<span class="lineNum">  144</span>              :       &#047;&#047;   4. All fields==0 is an empty string, given the extra storage </span>
<span class="lineNum">  145</span>              :       &#047;&#047;      beyond-the-end for a null terminator; thus, the shared </span>
<span class="lineNum">  146</span>              :       &#047;&#047;      empty string representation needs no constructor. </span>
<span class="lineNum">  147</span>              :  </span>
<span class="lineNum">  148</span>              :       struct _Rep_base </span>
<span class="lineNum">  149</span>              :       { </span>
<span class="lineNum">  150</span>              : 	size_type		_M_length; </span>
<span class="lineNum">  151</span>              : 	size_type		_M_capacity; </span>
<span class="lineNum">  152</span>              : 	_Atomic_word		_M_refcount; </span>
<span class="lineNum">  153</span>              :       }; </span>
<span class="lineNum">  154</span>              :  </span>
<span class="lineNum">  155</span>              :       struct _Rep : _Rep_base </span>
<span class="lineNum">  156</span>              :       { </span>
<span class="lineNum">  157</span>              : 	&#047;&#047; Types: </span>
<span class="lineNum">  158</span>              : 	typedef typename _Alloc::template rebind&lt;char&gt;::other _Raw_bytes_alloc; </span>
<span class="lineNum">  159</span>              :  </span>
<span class="lineNum">  160</span>              : 	&#047;&#047; (Public) Data members: </span>
<span class="lineNum">  161</span>              :  </span>
<span class="lineNum">  162</span>              : 	&#047;&#047; The maximum number of individual char_type elements of an </span>
<span class="lineNum">  163</span>              : 	&#047;&#047; individual string is determined by _S_max_size. This is the </span>
<span class="lineNum">  164</span>              : 	&#047;&#047; value that will be returned by max_size().  (Whereas npos </span>
<span class="lineNum">  165</span>              : 	&#047;&#047; is the maximum number of bytes the allocator can allocate.) </span>
<span class="lineNum">  166</span>              : 	&#047;&#047; If one was to divvy up the theoretical largest size string, </span>
<span class="lineNum">  167</span>              : 	&#047;&#047; with a terminating character and m _CharT elements, it&#039;d </span>
<span class="lineNum">  168</span>              : 	&#047;&#047; look like this: </span>
<span class="lineNum">  169</span>              : 	&#047;&#047; npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT) </span>
<span class="lineNum">  170</span>              : 	&#047;&#047; Solving for m: </span>
<span class="lineNum">  171</span>              : 	&#047;&#047; m = ((npos - sizeof(_Rep))&#047;sizeof(CharT)) - 1 </span>
<span class="lineNum">  172</span>              : 	&#047;&#047; In addition, this implementation quarters this amount. </span>
<span class="lineNum">  173</span>              : 	static const size_type	_S_max_size; </span>
<span class="lineNum">  174</span>              : 	static const _CharT	_S_terminal; </span>
<span class="lineNum">  175</span>              :  </span>
<span class="lineNum">  176</span>              : 	&#047;&#047; The following storage is init&#039;d to 0 by the linker, resulting </span>
<span class="lineNum">  177</span>              :         &#047;&#047; (carefully) in an empty string with one reference. </span>
<span class="lineNum">  178</span>              :         static size_type _S_empty_rep_storage[]; </span>
<span class="lineNum">  179</span>              :  </span>
<span class="lineNum">  180</span>              :         static _Rep&amp; </span>
<span class="lineNum">  181</span>              :         _S_empty_rep() </span>
<span class="lineNum">  182</span>              :         {  </span>
<span class="lineNum">  183</span>              : 	  &#047;&#047; NB: Mild hack to avoid strict-aliasing warnings.  Note that </span>
<span class="lineNum">  184</span>              : 	  &#047;&#047; _S_empty_rep_storage is never modified and the punning should </span>
<span class="lineNum">  185</span>              : 	  &#047;&#047; be reasonably safe in this case. </span>
<span class="lineNum">  186</span>              : 	  void* __p = reinterpret_cast&lt;void*&gt;(&amp;_S_empty_rep_storage); </span>
<span class="lineNum">  187</span>              : 	  return *reinterpret_cast&lt;_Rep*&gt;(__p); </span>
<span class="lineNum">  188</span>              : 	} </span>
<span class="lineNum">  189</span>              :  </span>
<span class="lineNum">  190</span>              :         bool </span>
<span class="lineNum">  191</span>              : 	_M_is_leaked() const </span>
<span class="lineNum">  192</span>              :         { return this-&gt;_M_refcount &lt; 0; } </span>
<span class="lineNum">  193</span>              :  </span>
<span class="lineNum">  194</span>              :         bool </span>
<span class="lineNum">  195</span>              : 	_M_is_shared() const </span>
<span class="lineNum">  196</span>              :         { return this-&gt;_M_refcount &gt; 0; } </span>
<span class="lineNum">  197</span>              :  </span>
<span class="lineNum">  198</span>              :         void </span>
<span class="lineNum">  199</span>              : 	_M_set_leaked() </span>
<span class="lineNum">  200</span>              :         { this-&gt;_M_refcount = -1; } </span>
<span class="lineNum">  201</span>              :  </span>
<span class="lineNum">  202</span>              :         void </span>
<span class="lineNum">  203</span>              : 	_M_set_sharable() </span>
<span class="lineNum">  204</span>              :         { this-&gt;_M_refcount = 0; } </span>
<span class="lineNum">  205</span>              :  </span>
<span class="lineNum">  206</span>              : 	void </span>
<span class="lineNum">  207</span>              : 	_M_set_length_and_sharable(size_type __n) </span>
<span class="lineNum">  208</span>              : 	{ </span>
<span class="lineNum">  209</span>              : #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0 </span>
<span class="lineNum">  210</span>              : 	  if (__builtin_expect(this != &amp;_S_empty_rep(), false)) </span>
<span class="lineNum">  211</span>              : #endif </span>
<span class="lineNum">  212</span>              : 	    { </span>
<span class="lineNum">  213</span>              : 	      this-&gt;_M_set_sharable();  &#047;&#047; One reference. </span>
<span class="lineNum">  214</span>              : 	      this-&gt;_M_length = __n; </span>
<span class="lineNum">  215</span>              : 	      traits_type::assign(this-&gt;_M_refdata()[__n], _S_terminal); </span>
<span class="lineNum">  216</span>              : 	      &#047;&#047; grrr. (per 21.3.4) </span>
<span class="lineNum">  217</span>              : 	      &#047;&#047; You cannot leave those LWG people alone for a second. </span>
<span class="lineNum">  218</span>              : 	    } </span>
<span class="lineNum">  219</span>              : 	} </span>
<span class="lineNum">  220</span>              :  </span>
<span class="lineNum">  221</span>              : 	_CharT* </span>
<span class="lineNum">  222</span>              : 	_M_refdata() throw() </span>
<span class="lineNum">  223</span>              : 	{ return reinterpret_cast&lt;_CharT*&gt;(this + 1); } </span>
<span class="lineNum">  224</span>              :  </span>
<span class="lineNum">  225</span>              : 	_CharT* </span>
<span class="lineNum">  226</span>              : 	_M_grab(const _Alloc&amp; __alloc1, const _Alloc&amp; __alloc2) </span>
<span class="lineNum">  227</span>              : 	{ </span>
<span class="lineNum">  228</span>              : 	  return (!_M_is_leaked() &amp;&amp; __alloc1 == __alloc2) </span>
<span class="lineNum">  229</span>              : 	          ? _M_refcopy() : _M_clone(__alloc1); </span>
<span class="lineNum">  230</span>              : 	} </span>
<span class="lineNum">  231</span>              :  </span>
<span class="lineNum">  232</span>              : 	&#047;&#047; Create &amp; Destroy </span>
<span class="lineNum">  233</span>              : 	static _Rep* </span>
<span class="lineNum">  234</span>              : 	_S_create(size_type, size_type, const _Alloc&amp;); </span>
<span class="lineNum">  235</span>              :  </span>
<span class="lineNum">  236</span>              : 	void </span>
<span class="lineNum">  237</span>              : 	_M_dispose(const _Alloc&amp; __a) </span>
<span class="lineNum">  238</span>              : 	{ </span>
<span class="lineNum">  239</span>              : #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0 </span>
<span class="lineNum">  240</span>              : 	  if (__builtin_expect(this != &amp;_S_empty_rep(), false)) </span>
<span class="lineNum">  241</span>              : #endif </span>
<span class="lineNum">  242</span>              : 	    { </span>
<span class="lineNum">  243</span>              : 	      &#047;&#047; Be race-detector-friendly.  For more info see bits&#047;c++config. </span>
<span class="lineNum">  244</span>              : 	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;this-&gt;_M_refcount); </span>
<span class="lineNum">  245</span>              : 	      if (__gnu_cxx::__exchange_and_add_dispatch(&amp;this-&gt;_M_refcount, </span>
<span class="lineNum">  246</span>              : 							 -1) &lt;= 0) </span>
<span class="lineNum">  247</span>              : 		{ </span>
<span class="lineNum">  248</span>              : 		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;this-&gt;_M_refcount); </span>
<span class="lineNum">  249</span>              : 		  _M_destroy(__a); </span>
<span class="lineNum">  250</span>              : 		} </span>
<span class="lineNum">  251</span>              : 	    } </span>
<span class="lineNum">  252</span>              : 	}  &#047;&#047; XXX MT </span>
<span class="lineNum">  253</span>              :  </span>
<span class="lineNum">  254</span>              : 	void </span>
<span class="lineNum">  255</span>              : 	_M_destroy(const _Alloc&amp;) throw(); </span>
<span class="lineNum">  256</span>              :  </span>
<span class="lineNum">  257</span>              : 	_CharT* </span>
<span class="lineNum">  258</span>              : 	_M_refcopy() throw() </span>
<span class="lineNum">  259</span>              : 	{ </span>
<span class="lineNum">  260</span>              : #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0 </span>
<span class="lineNum">  261</span>              : 	  if (__builtin_expect(this != &amp;_S_empty_rep(), false)) </span>
<span class="lineNum">  262</span>              : #endif </span>
<span class="lineNum">  263</span>              :             __gnu_cxx::__atomic_add_dispatch(&amp;this-&gt;_M_refcount, 1); </span>
<span class="lineNum">  264</span>              : 	  return _M_refdata(); </span>
<span class="lineNum">  265</span>              : 	}  &#047;&#047; XXX MT </span>
<span class="lineNum">  266</span>              :  </span>
<span class="lineNum">  267</span>              : 	_CharT* </span>
<span class="lineNum">  268</span>              : 	_M_clone(const _Alloc&amp;, size_type __res = 0); </span>
<span class="lineNum">  269</span>              :       }; </span>
<span class="lineNum">  270</span>              :  </span>
<span class="lineNum">  271</span>              :       &#047;&#047; Use empty-base optimization: http:&#047;&#047;www.cantrip.org&#047;emptyopt.html </span>
<span class="lineNum">  272</span>              :       struct _Alloc_hider : _Alloc </span>
<span class="lineNum">  273</span>              :       { </span>
<span class="lineNum">  274</span>              : 	_Alloc_hider(_CharT* __dat, const _Alloc&amp; __a) </span>
<span class="lineNum">  275</span>              : 	: _Alloc(__a), _M_p(__dat) { } </span>
<span class="lineNum">  276</span>              :  </span>
<span class="lineNum">  277</span>              : 	_CharT* _M_p; &#047;&#047; The actual data. </span>
<span class="lineNum">  278</span>              :       }; </span>
<span class="lineNum">  279</span>              :  </span>
<span class="lineNum">  280</span>              :     public: </span>
<span class="lineNum">  281</span>              :       &#047;&#047; Data Members (public): </span>
<span class="lineNum">  282</span>              :       &#047;&#047; NB: This is an unsigned type, and thus represents the maximum </span>
<span class="lineNum">  283</span>              :       &#047;&#047; size that the allocator can hold. </span>
<span class="lineNum">  284</span>              :       &#047;&#047;&#047;  Value returned by various member functions when they fail. </span>
<span class="lineNum">  285</span>              :       static const size_type	npos = static_cast&lt;size_type&gt;(-1); </span>
<span class="lineNum">  286</span>              :  </span>
<span class="lineNum">  287</span>              :     private: </span>
<span class="lineNum">  288</span>              :       &#047;&#047; Data Members (private): </span>
<span class="lineNum">  289</span>              :       mutable _Alloc_hider	_M_dataplus; </span>
<span class="lineNum">  290</span>              :  </span>
<span class="lineNum">  291</span>              :       _CharT* </span>
<span class="lineNum">  292</span>              :       _M_data() const </span>
<span class="lineNum">  293</span>              :       { return  _M_dataplus._M_p; } </span>
<span class="lineNum">  294</span>              :  </span>
<span class="lineNum">  295</span>              :       _CharT* </span>
<span class="lineNum">  296</span>              :       _M_data(_CharT* __p) </span>
<span class="lineNum">  297</span>              :       { return (_M_dataplus._M_p = __p); } </span>
<span class="lineNum">  298</span>              :  </span>
<span class="lineNum">  299</span>              :       _Rep* </span>
<span class="lineNum">  300</span>              :       _M_rep() const </span>
<span class="lineNum">  301</span>              :       { return &amp;((reinterpret_cast&lt;_Rep*&gt; (_M_data()))[-1]); } </span>
<span class="lineNum">  302</span>              :  </span>
<span class="lineNum">  303</span>              :       &#047;&#047; For the internal use we have functions similar to `begin&#039;&#047;`end&#039; </span>
<span class="lineNum">  304</span>              :       &#047;&#047; but they do not call _M_leak. </span>
<span class="lineNum">  305</span>              :       iterator </span>
<span class="lineNum">  306</span>              :       _M_ibegin() const </span>
<span class="lineNum">  307</span>              :       { return iterator(_M_data()); } </span>
<span class="lineNum">  308</span>              :  </span>
<span class="lineNum">  309</span>              :       iterator </span>
<span class="lineNum">  310</span>              :       _M_iend() const </span>
<span class="lineNum">  311</span>              :       { return iterator(_M_data() + this-&gt;size()); } </span>
<span class="lineNum">  312</span>              :  </span>
<span class="lineNum">  313</span>              :       void </span>
<span class="lineNum">  314</span>              :       _M_leak()    &#047;&#047; for use in begin() &amp; non-const op[] </span>
<span class="lineNum">  315</span>              :       { </span>
<span class="lineNum">  316</span>              : 	if (!_M_rep()-&gt;_M_is_leaked()) </span>
<span class="lineNum">  317</span>              : 	  _M_leak_hard(); </span>
<span class="lineNum">  318</span>              :       } </span>
<span class="lineNum">  319</span>              :  </span>
<span class="lineNum">  320</span>              :       size_type </span>
<span class="lineNum">  321</span>              :       _M_check(size_type __pos, const char* __s) const </span>
<span class="lineNum">  322</span>              :       { </span>
<span class="lineNum">  323</span>              : 	if (__pos &gt; this-&gt;size()) </span>
<span class="lineNum">  324</span>              : 	  __throw_out_of_range(__N(__s)); </span>
<span class="lineNum">  325</span>              : 	return __pos; </span>
<span class="lineNum">  326</span>              :       } </span>
<span class="lineNum">  327</span>              :  </span>
<span class="lineNum">  328</span>              :       void </span>
<span class="lineNum">  329</span>              :       _M_check_length(size_type __n1, size_type __n2, const char* __s) const </span>
<span class="lineNum">  330</span>              :       { </span>
<span class="lineNum">  331</span>              : 	if (this-&gt;max_size() - (this-&gt;size() - __n1) &lt; __n2) </span>
<span class="lineNum">  332</span>              : 	  __throw_length_error(__N(__s)); </span>
<span class="lineNum">  333</span>              :       } </span>
<span class="lineNum">  334</span>              :  </span>
<span class="lineNum">  335</span>              :       &#047;&#047; NB: _M_limit doesn&#039;t check for a bad __pos value. </span>
<span class="lineNum">  336</span>              :       size_type </span>
<span class="lineNum">  337</span>              :       _M_limit(size_type __pos, size_type __off) const </span>
<span class="lineNum">  338</span>              :       { </span>
<span class="lineNum">  339</span>              : 	const bool __testoff =  __off &lt; this-&gt;size() - __pos; </span>
<span class="lineNum">  340</span>              : 	return __testoff ? __off : this-&gt;size() - __pos; </span>
<span class="lineNum">  341</span>              :       } </span>
<span class="lineNum">  342</span>              :  </span>
<span class="lineNum">  343</span>              :       &#047;&#047; True if _Rep and source do not overlap. </span>
<span class="lineNum">  344</span>              :       bool </span>
<span class="lineNum">  345</span>              :       _M_disjunct(const _CharT* __s) const </span>
<span class="lineNum">  346</span>              :       { </span>
<span class="lineNum">  347</span>              : 	return (less&lt;const _CharT*&gt;()(__s, _M_data()) </span>
<span class="lineNum">  348</span>              : 		|| less&lt;const _CharT*&gt;()(_M_data() + this-&gt;size(), __s)); </span>
<span class="lineNum">  349</span>              :       } </span>
<span class="lineNum">  350</span>              :  </span>
<span class="lineNum">  351</span>              :       &#047;&#047; When __n = 1 way faster than the general multichar </span>
<span class="lineNum">  352</span>              :       &#047;&#047; traits_type::copy&#047;move&#047;assign. </span>
<span class="lineNum">  353</span>              :       static void </span>
<span class="lineNum">  354</span>              :       _M_copy(_CharT* __d, const _CharT* __s, size_type __n) </span>
<span class="lineNum">  355</span>              :       { </span>
<span class="lineNum">  356</span>              : 	if (__n == 1) </span>
<span class="lineNum">  357</span>              : 	  traits_type::assign(*__d, *__s); </span>
<span class="lineNum">  358</span>              : 	else </span>
<span class="lineNum">  359</span>              : 	  traits_type::copy(__d, __s, __n); </span>
<span class="lineNum">  360</span>              :       } </span>
<span class="lineNum">  361</span>              :  </span>
<span class="lineNum">  362</span>              :       static void </span>
<span class="lineNum">  363</span>              :       _M_move(_CharT* __d, const _CharT* __s, size_type __n) </span>
<span class="lineNum">  364</span>              :       { </span>
<span class="lineNum">  365</span>              : 	if (__n == 1) </span>
<span class="lineNum">  366</span>              : 	  traits_type::assign(*__d, *__s); </span>
<span class="lineNum">  367</span>              : 	else </span>
<span class="lineNum">  368</span>              : 	  traits_type::move(__d, __s, __n);	   </span>
<span class="lineNum">  369</span>              :       } </span>
<span class="lineNum">  370</span>              :  </span>
<span class="lineNum">  371</span>              :       static void </span>
<span class="lineNum">  372</span>              :       _M_assign(_CharT* __d, size_type __n, _CharT __c) </span>
<span class="lineNum">  373</span>              :       { </span>
<span class="lineNum">  374</span>              : 	if (__n == 1) </span>
<span class="lineNum">  375</span>              : 	  traits_type::assign(*__d, __c); </span>
<span class="lineNum">  376</span>              : 	else </span>
<span class="lineNum">  377</span>              : 	  traits_type::assign(__d, __n, __c);	   </span>
<span class="lineNum">  378</span>              :       } </span>
<span class="lineNum">  379</span>              :  </span>
<span class="lineNum">  380</span>              :       &#047;&#047; _S_copy_chars is a separate template to permit specialization </span>
<span class="lineNum">  381</span>              :       &#047;&#047; to optimize for the common case of pointers as iterators. </span>
<span class="lineNum">  382</span>              :       template&lt;class _Iterator&gt; </span>
<span class="lineNum">  383</span>              :         static void </span>
<span class="lineNum">  384</span>              :         _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2) </span>
<span class="lineNum">  385</span>              :         { </span>
<span class="lineNum">  386</span>              : 	  for (; __k1 != __k2; ++__k1, ++__p) </span>
<span class="lineNum">  387</span>              : 	    traits_type::assign(*__p, *__k1); &#047;&#047; These types are off. </span>
<span class="lineNum">  388</span>              : 	} </span>
<span class="lineNum">  389</span>              :  </span>
<span class="lineNum">  390</span>              :       static void </span>
<span class="lineNum">  391</span>              :       _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) </span>
<span class="lineNum">  392</span>              :       { _S_copy_chars(__p, __k1.base(), __k2.base()); } </span>
<span class="lineNum">  393</span>              :  </span>
<span class="lineNum">  394</span>              :       static void </span>
<span class="lineNum">  395</span>              :       _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2) </span>
<span class="lineNum">  396</span>              :       { _S_copy_chars(__p, __k1.base(), __k2.base()); } </span>
<span class="lineNum">  397</span>              :  </span>
<span class="lineNum">  398</span>              :       static void </span>
<span class="lineNum">  399</span>              :       _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) </span>
<span class="lineNum">  400</span>              :       { _M_copy(__p, __k1, __k2 - __k1); } </span>
<span class="lineNum">  401</span>              :  </span>
<span class="lineNum">  402</span>              :       static void </span>
<span class="lineNum">  403</span>              :       _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2) </span>
<span class="lineNum">  404</span>              :       { _M_copy(__p, __k1, __k2 - __k1); } </span>
<span class="lineNum">  405</span>              :  </span>
<span class="lineNum">  406</span>              :       static int </span>
<span class="lineNum">  407</span>              :       _S_compare(size_type __n1, size_type __n2) </span>
<span class="lineNum">  408</span>              :       { </span>
<span class="lineNum">  409</span>              : 	const difference_type __d = difference_type(__n1 - __n2); </span>
<span class="lineNum">  410</span>              :  </span>
<span class="lineNum">  411</span>              : 	if (__d &gt; __gnu_cxx::__numeric_traits&lt;int&gt;::__max) </span>
<span class="lineNum">  412</span>              : 	  return __gnu_cxx::__numeric_traits&lt;int&gt;::__max; </span>
<span class="lineNum">  413</span>              : 	else if (__d &lt; __gnu_cxx::__numeric_traits&lt;int&gt;::__min) </span>
<span class="lineNum">  414</span>              : 	  return __gnu_cxx::__numeric_traits&lt;int&gt;::__min; </span>
<span class="lineNum">  415</span>              : 	else </span>
<span class="lineNum">  416</span>              : 	  return int(__d); </span>
<span class="lineNum">  417</span>              :       } </span>
<span class="lineNum">  418</span>              :  </span>
<span class="lineNum">  419</span>              :       void </span>
<span class="lineNum">  420</span>              :       _M_mutate(size_type __pos, size_type __len1, size_type __len2); </span>
<span class="lineNum">  421</span>              :  </span>
<span class="lineNum">  422</span>              :       void </span>
<span class="lineNum">  423</span>              :       _M_leak_hard(); </span>
<span class="lineNum">  424</span>              :  </span>
<span class="lineNum">  425</span>              :       static _Rep&amp; </span>
<span class="lineNum">  426</span>              :       _S_empty_rep() </span>
<span class="lineNum">  427</span>              :       { return _Rep::_S_empty_rep(); } </span>
<span class="lineNum">  428</span>              :  </span>
<span class="lineNum">  429</span>              :     public: </span>
<span class="lineNum">  430</span>              :       &#047;&#047; Construct&#047;copy&#047;destroy: </span>
<span class="lineNum">  431</span>              :       &#047;&#047; NB: We overload ctors in some cases instead of using default </span>
<span class="lineNum">  432</span>              :       &#047;&#047; arguments, per 17.4.4.4 para. 2 item 2. </span>
<span class="lineNum">  433</span>              :  </span>
<span class="lineNum">  434</span>              :       &#047;** </span>
<span class="lineNum">  435</span>              :        *  @brief  Default constructor creates an empty string. </span>
<span class="lineNum">  436</span>              :        *&#047; </span>
<span class="lineNum">  437</span>              :       basic_string() </span>
<span class="lineNum">  438</span>              : #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0 </span>
<span class="lineNum">  439</span>              :       : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { } </span>
<span class="lineNum">  440</span>              : #else </span>
<span class="lineNum">  441</span>              :       : _M_dataplus(_S_construct(size_type(), _CharT(), _Alloc()), _Alloc()){ } </span>
<span class="lineNum">  442</span>              : #endif </span>
<span class="lineNum">  443</span>              :  </span>
<span class="lineNum">  444</span>              :       &#047;** </span>
<span class="lineNum">  445</span>              :        *  @brief  Construct an empty string using allocator @a a. </span>
<span class="lineNum">  446</span>              :        *&#047; </span>
<span class="lineNum">  447</span>              :       explicit </span>
<span class="lineNum">  448</span>              :       basic_string(const _Alloc&amp; __a); </span>
<span class="lineNum">  449</span>              :  </span>
<span class="lineNum">  450</span>              :       &#047;&#047; NB: per LWG issue 42, semantics different from IS: </span>
<span class="lineNum">  451</span>              :       &#047;** </span>
<span class="lineNum">  452</span>              :        *  @brief  Construct string with copy of value of @a str. </span>
<span class="lineNum">  453</span>              :        *  @param  __str  Source string. </span>
<span class="lineNum">  454</span>              :        *&#047; </span>
<span class="lineNum">  455</span>              :       basic_string(const basic_string&amp; __str); </span>
<span class="lineNum">  456</span>              :       &#047;** </span>
<span class="lineNum">  457</span>              :        *  @brief  Construct string as copy of a substring. </span>
<span class="lineNum">  458</span>              :        *  @param  __str  Source string. </span>
<span class="lineNum">  459</span>              :        *  @param  __pos  Index of first character to copy from. </span>
<span class="lineNum">  460</span>              :        *  @param  __n  Number of characters to copy (default remainder). </span>
<span class="lineNum">  461</span>              :        *&#047; </span>
<span class="lineNum">  462</span>              :       basic_string(const basic_string&amp; __str, size_type __pos, </span>
<span class="lineNum">  463</span>              : 		   size_type __n = npos); </span>
<span class="lineNum">  464</span>              :       &#047;** </span>
<span class="lineNum">  465</span>              :        *  @brief  Construct string as copy of a substring. </span>
<span class="lineNum">  466</span>              :        *  @param  __str  Source string. </span>
<span class="lineNum">  467</span>              :        *  @param  __pos  Index of first character to copy from. </span>
<span class="lineNum">  468</span>              :        *  @param  __n  Number of characters to copy. </span>
<span class="lineNum">  469</span>              :        *  @param  __a  Allocator to use. </span>
<span class="lineNum">  470</span>              :        *&#047; </span>
<span class="lineNum">  471</span>              :       basic_string(const basic_string&amp; __str, size_type __pos, </span>
<span class="lineNum">  472</span>              : 		   size_type __n, const _Alloc&amp; __a); </span>
<span class="lineNum">  473</span>              :  </span>
<span class="lineNum">  474</span>              :       &#047;** </span>
<span class="lineNum">  475</span>              :        *  @brief  Construct string initialized by a character %array. </span>
<span class="lineNum">  476</span>              :        *  @param  __s  Source character %array. </span>
<span class="lineNum">  477</span>              :        *  @param  __n  Number of characters to copy. </span>
<span class="lineNum">  478</span>              :        *  @param  __a  Allocator to use (default is default allocator). </span>
<span class="lineNum">  479</span>              :        * </span>
<span class="lineNum">  480</span>              :        *  NB: @a __s must have at least @a __n characters, &amp;apos;&#092;&#092;0&amp;apos; </span>
<span class="lineNum">  481</span>              :        *  has no special meaning. </span>
<span class="lineNum">  482</span>              :        *&#047; </span>
<span class="lineNum">  483</span>              :       basic_string(const _CharT* __s, size_type __n, </span>
<span class="lineNum">  484</span>              : 		   const _Alloc&amp; __a = _Alloc()); </span>
<span class="lineNum">  485</span>              :       &#047;** </span>
<span class="lineNum">  486</span>              :        *  @brief  Construct string as copy of a C string. </span>
<span class="lineNum">  487</span>              :        *  @param  __s  Source C string. </span>
<span class="lineNum">  488</span>              :        *  @param  __a  Allocator to use (default is default allocator). </span>
<span class="lineNum">  489</span>              :        *&#047; </span>
<span class="lineNum">  490</span>              :       basic_string(const _CharT* __s, const _Alloc&amp; __a = _Alloc()); </span>
<span class="lineNum">  491</span>              :       &#047;** </span>
<span class="lineNum">  492</span>              :        *  @brief  Construct string as multiple characters. </span>
<span class="lineNum">  493</span>              :        *  @param  __n  Number of characters. </span>
<span class="lineNum">  494</span>              :        *  @param  __c  Character to use. </span>
<span class="lineNum">  495</span>              :        *  @param  __a  Allocator to use (default is default allocator). </span>
<span class="lineNum">  496</span>              :        *&#047; </span>
<span class="lineNum">  497</span>              :       basic_string(size_type __n, _CharT __c, const _Alloc&amp; __a = _Alloc()); </span>
<span class="lineNum">  498</span>              :  </span>
<span class="lineNum">  499</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  500</span>              :       &#047;** </span>
<span class="lineNum">  501</span>              :        *  @brief  Move construct string. </span>
<span class="lineNum">  502</span>              :        *  @param  __str  Source string. </span>
<span class="lineNum">  503</span>              :        * </span>
<span class="lineNum">  504</span>              :        *  The newly-created string contains the exact contents of @a __str. </span>
<span class="lineNum">  505</span>              :        *  @a __str is a valid, but unspecified string. </span>
<span class="lineNum">  506</span>              :        **&#047; </span>
<span class="lineNum">  507</span>              :       basic_string(basic_string&amp;&amp; __str) noexcept </span>
<span class="lineNum">  508</span>              :       : _M_dataplus(__str._M_dataplus) </span>
<span class="lineNum">  509</span>              :       { </span>
<span class="lineNum">  510</span>              : #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0 </span>
<span class="lineNum">  511</span>              : 	__str._M_data(_S_empty_rep()._M_refdata()); </span>
<span class="lineNum">  512</span>              : #else </span>
<span class="lineNum">  513</span>              : 	__str._M_data(_S_construct(size_type(), _CharT(), get_allocator())); </span>
<span class="lineNum">  514</span>              : #endif </span>
<span class="lineNum">  515</span>              :       } </span>
<span class="lineNum">  516</span>              :  </span>
<span class="lineNum">  517</span>              :       &#047;** </span>
<span class="lineNum">  518</span>              :        *  @brief  Construct string from an initializer %list. </span>
<span class="lineNum">  519</span>              :        *  @param  __l  std::initializer_list of characters. </span>
<span class="lineNum">  520</span>              :        *  @param  __a  Allocator to use (default is default allocator). </span>
<span class="lineNum">  521</span>              :        *&#047; </span>
<span class="lineNum">  522</span>              :       basic_string(initializer_list&lt;_CharT&gt; __l, const _Alloc&amp; __a = _Alloc()); </span>
<span class="lineNum">  523</span>              : #endif &#047;&#047; C++11 </span>
<span class="lineNum">  524</span>              :  </span>
<span class="lineNum">  525</span>              :       &#047;** </span>
<span class="lineNum">  526</span>              :        *  @brief  Construct string as copy of a range. </span>
<span class="lineNum">  527</span>              :        *  @param  __beg  Start of range. </span>
<span class="lineNum">  528</span>              :        *  @param  __end  End of range. </span>
<span class="lineNum">  529</span>              :        *  @param  __a  Allocator to use (default is default allocator). </span>
<span class="lineNum">  530</span>              :        *&#047; </span>
<span class="lineNum">  531</span>              :       template&lt;class _InputIterator&gt; </span>
<span class="lineNum">  532</span>              :         basic_string(_InputIterator __beg, _InputIterator __end, </span>
<span class="lineNum">  533</span>              : 		     const _Alloc&amp; __a = _Alloc()); </span>
<span class="lineNum">  534</span>              :  </span>
<span class="lineNum">  535</span>              :       &#047;** </span>
<span class="lineNum">  536</span>              :        *  @brief  Destroy the string instance. </span>
<span class="lineNum">  537</span>              :        *&#047; </span>
<span class="lineNum">  538</span>              :       ~basic_string() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  539</span>              :       { _M_rep()-&gt;_M_dispose(this-&gt;get_allocator()); } </span>
<span class="lineNum">  540</span>              :  </span>
<span class="lineNum">  541</span>              :       &#047;** </span>
<span class="lineNum">  542</span>              :        *  @brief  Assign the value of @a str to this string. </span>
<span class="lineNum">  543</span>              :        *  @param  __str  Source string. </span>
<span class="lineNum">  544</span>              :        *&#047; </span>
<span class="lineNum">  545</span>              :       basic_string&amp; </span>
<span class="lineNum">  546</span>              :       operator=(const basic_string&amp; __str)  </span>
<span class="lineNum">  547</span>              :       { return this-&gt;assign(__str); } </span>
<span class="lineNum">  548</span>              :  </span>
<span class="lineNum">  549</span>              :       &#047;** </span>
<span class="lineNum">  550</span>              :        *  @brief  Copy contents of @a s into this string. </span>
<span class="lineNum">  551</span>              :        *  @param  __s  Source null-terminated string. </span>
<span class="lineNum">  552</span>              :        *&#047; </span>
<span class="lineNum">  553</span>              :       basic_string&amp; </span>
<span class="lineNum">  554</span>              :       operator=(const _CharT* __s)  </span>
<span class="lineNum">  555</span>              :       { return this-&gt;assign(__s); } </span>
<span class="lineNum">  556</span>              :  </span>
<span class="lineNum">  557</span>              :       &#047;** </span>
<span class="lineNum">  558</span>              :        *  @brief  Set value to string of length 1. </span>
<span class="lineNum">  559</span>              :        *  @param  __c  Source character. </span>
<span class="lineNum">  560</span>              :        * </span>
<span class="lineNum">  561</span>              :        *  Assigning to a character makes this string length 1 and </span>
<span class="lineNum">  562</span>              :        *  (*this)[0] == @a c. </span>
<span class="lineNum">  563</span>              :        *&#047; </span>
<span class="lineNum">  564</span>              :       basic_string&amp; </span>
<span class="lineNum">  565</span>              :       operator=(_CharT __c)  </span>
<span class="lineNum">  566</span>              :       {  </span>
<span class="lineNum">  567</span>              : 	this-&gt;assign(1, __c);  </span>
<span class="lineNum">  568</span>              : 	return *this; </span>
<span class="lineNum">  569</span>              :       } </span>
<span class="lineNum">  570</span>              :  </span>
<span class="lineNum">  571</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  572</span>              :       &#047;** </span>
<span class="lineNum">  573</span>              :        *  @brief  Move assign the value of @a str to this string. </span>
<span class="lineNum">  574</span>              :        *  @param  __str  Source string. </span>
<span class="lineNum">  575</span>              :        * </span>
<span class="lineNum">  576</span>              :        *  The contents of @a str are moved into this string (without copying). </span>
<span class="lineNum">  577</span>              :        *  @a str is a valid, but unspecified string. </span>
<span class="lineNum">  578</span>              :        **&#047; </span>
<span class="lineNum">  579</span>              :       basic_string&amp; </span>
<span class="lineNum">  580</span>              :       operator=(basic_string&amp;&amp; __str) </span>
<span class="lineNum">  581</span>              :       { </span>
<span class="lineNum">  582</span>              : 	&#047;&#047; NB: DR 1204. </span>
<span class="lineNum">  583</span>              : 	this-&gt;swap(__str); </span>
<span class="lineNum">  584</span>              : 	return *this; </span>
<span class="lineNum">  585</span>              :       } </span>
<span class="lineNum">  586</span>              :  </span>
<span class="lineNum">  587</span>              :       &#047;** </span>
<span class="lineNum">  588</span>              :        *  @brief  Set value to string constructed from initializer %list. </span>
<span class="lineNum">  589</span>              :        *  @param  __l  std::initializer_list. </span>
<span class="lineNum">  590</span>              :        *&#047; </span>
<span class="lineNum">  591</span>              :       basic_string&amp; </span>
<span class="lineNum">  592</span>              :       operator=(initializer_list&lt;_CharT&gt; __l) </span>
<span class="lineNum">  593</span>              :       { </span>
<span class="lineNum">  594</span>              : 	this-&gt;assign(__l.begin(), __l.size()); </span>
<span class="lineNum">  595</span>              : 	return *this; </span>
<span class="lineNum">  596</span>              :       } </span>
<span class="lineNum">  597</span>              : #endif &#047;&#047; C++11 </span>
<span class="lineNum">  598</span>              :  </span>
<span class="lineNum">  599</span>              :       &#047;&#047; Iterators: </span>
<span class="lineNum">  600</span>              :       &#047;** </span>
<span class="lineNum">  601</span>              :        *  Returns a read&#047;write iterator that points to the first character in </span>
<span class="lineNum">  602</span>              :        *  the %string.  Unshares the string. </span>
<span class="lineNum">  603</span>              :        *&#047; </span>
<span class="lineNum">  604</span>              :       iterator </span>
<span class="lineNum">  605</span>              :       begin() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  606</span>              :       { </span>
<span class="lineNum">  607</span>              : 	_M_leak(); </span>
<span class="lineNum">  608</span>              : 	return iterator(_M_data()); </span>
<span class="lineNum">  609</span>              :       } </span>
<span class="lineNum">  610</span>              :  </span>
<span class="lineNum">  611</span>              :       &#047;** </span>
<span class="lineNum">  612</span>              :        *  Returns a read-only (constant) iterator that points to the first </span>
<span class="lineNum">  613</span>              :        *  character in the %string. </span>
<span class="lineNum">  614</span>              :        *&#047; </span>
<span class="lineNum">  615</span>              :       const_iterator </span>
<span class="lineNum">  616</span>              :       begin() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  617</span>              :       { return const_iterator(_M_data()); } </span>
<span class="lineNum">  618</span>              :  </span>
<span class="lineNum">  619</span>              :       &#047;** </span>
<span class="lineNum">  620</span>              :        *  Returns a read&#047;write iterator that points one past the last </span>
<span class="lineNum">  621</span>              :        *  character in the %string.  Unshares the string. </span>
<span class="lineNum">  622</span>              :        *&#047; </span>
<span class="lineNum">  623</span>              :       iterator </span>
<span class="lineNum">  624</span>              :       end() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  625</span>              :       { </span>
<span class="lineNum">  626</span>              : 	_M_leak(); </span>
<span class="lineNum">  627</span>              : 	return iterator(_M_data() + this-&gt;size()); </span>
<span class="lineNum">  628</span>              :       } </span>
<span class="lineNum">  629</span>              :  </span>
<span class="lineNum">  630</span>              :       &#047;** </span>
<span class="lineNum">  631</span>              :        *  Returns a read-only (constant) iterator that points one past the </span>
<span class="lineNum">  632</span>              :        *  last character in the %string. </span>
<span class="lineNum">  633</span>              :        *&#047; </span>
<span class="lineNum">  634</span>              :       const_iterator </span>
<span class="lineNum">  635</span>              :       end() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  636</span>              :       { return const_iterator(_M_data() + this-&gt;size()); } </span>
<span class="lineNum">  637</span>              :  </span>
<span class="lineNum">  638</span>              :       &#047;** </span>
<span class="lineNum">  639</span>              :        *  Returns a read&#047;write reverse iterator that points to the last </span>
<span class="lineNum">  640</span>              :        *  character in the %string.  Iteration is done in reverse element </span>
<span class="lineNum">  641</span>              :        *  order.  Unshares the string. </span>
<span class="lineNum">  642</span>              :        *&#047; </span>
<span class="lineNum">  643</span>              :       reverse_iterator </span>
<span class="lineNum">  644</span>              :       rbegin() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  645</span>              :       { return reverse_iterator(this-&gt;end()); } </span>
<span class="lineNum">  646</span>              :  </span>
<span class="lineNum">  647</span>              :       &#047;** </span>
<span class="lineNum">  648</span>              :        *  Returns a read-only (constant) reverse iterator that points </span>
<span class="lineNum">  649</span>              :        *  to the last character in the %string.  Iteration is done in </span>
<span class="lineNum">  650</span>              :        *  reverse element order. </span>
<span class="lineNum">  651</span>              :        *&#047; </span>
<span class="lineNum">  652</span>              :       const_reverse_iterator </span>
<span class="lineNum">  653</span>              :       rbegin() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  654</span>              :       { return const_reverse_iterator(this-&gt;end()); } </span>
<span class="lineNum">  655</span>              :  </span>
<span class="lineNum">  656</span>              :       &#047;** </span>
<span class="lineNum">  657</span>              :        *  Returns a read&#047;write reverse iterator that points to one before the </span>
<span class="lineNum">  658</span>              :        *  first character in the %string.  Iteration is done in reverse </span>
<span class="lineNum">  659</span>              :        *  element order.  Unshares the string. </span>
<span class="lineNum">  660</span>              :        *&#047; </span>
<span class="lineNum">  661</span>              :       reverse_iterator </span>
<span class="lineNum">  662</span>              :       rend() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  663</span>              :       { return reverse_iterator(this-&gt;begin()); } </span>
<span class="lineNum">  664</span>              :  </span>
<span class="lineNum">  665</span>              :       &#047;** </span>
<span class="lineNum">  666</span>              :        *  Returns a read-only (constant) reverse iterator that points </span>
<span class="lineNum">  667</span>              :        *  to one before the first character in the %string.  Iteration </span>
<span class="lineNum">  668</span>              :        *  is done in reverse element order. </span>
<span class="lineNum">  669</span>              :        *&#047; </span>
<span class="lineNum">  670</span>              :       const_reverse_iterator </span>
<span class="lineNum">  671</span>              :       rend() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  672</span>              :       { return const_reverse_iterator(this-&gt;begin()); } </span>
<span class="lineNum">  673</span>              :  </span>
<span class="lineNum">  674</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  675</span>              :       &#047;** </span>
<span class="lineNum">  676</span>              :        *  Returns a read-only (constant) iterator that points to the first </span>
<span class="lineNum">  677</span>              :        *  character in the %string. </span>
<span class="lineNum">  678</span>              :        *&#047; </span>
<span class="lineNum">  679</span>              :       const_iterator </span>
<span class="lineNum">  680</span>              :       cbegin() const noexcept </span>
<span class="lineNum">  681</span>              :       { return const_iterator(this-&gt;_M_data()); } </span>
<span class="lineNum">  682</span>              :  </span>
<span class="lineNum">  683</span>              :       &#047;** </span>
<span class="lineNum">  684</span>              :        *  Returns a read-only (constant) iterator that points one past the </span>
<span class="lineNum">  685</span>              :        *  last character in the %string. </span>
<span class="lineNum">  686</span>              :        *&#047; </span>
<span class="lineNum">  687</span>              :       const_iterator </span>
<span class="lineNum">  688</span>              :       cend() const noexcept </span>
<span class="lineNum">  689</span>              :       { return const_iterator(this-&gt;_M_data() + this-&gt;size()); } </span>
<span class="lineNum">  690</span>              :  </span>
<span class="lineNum">  691</span>              :       &#047;** </span>
<span class="lineNum">  692</span>              :        *  Returns a read-only (constant) reverse iterator that points </span>
<span class="lineNum">  693</span>              :        *  to the last character in the %string.  Iteration is done in </span>
<span class="lineNum">  694</span>              :        *  reverse element order. </span>
<span class="lineNum">  695</span>              :        *&#047; </span>
<span class="lineNum">  696</span>              :       const_reverse_iterator </span>
<span class="lineNum">  697</span>              :       crbegin() const noexcept </span>
<span class="lineNum">  698</span>              :       { return const_reverse_iterator(this-&gt;end()); } </span>
<span class="lineNum">  699</span>              :  </span>
<span class="lineNum">  700</span>              :       &#047;** </span>
<span class="lineNum">  701</span>              :        *  Returns a read-only (constant) reverse iterator that points </span>
<span class="lineNum">  702</span>              :        *  to one before the first character in the %string.  Iteration </span>
<span class="lineNum">  703</span>              :        *  is done in reverse element order. </span>
<span class="lineNum">  704</span>              :        *&#047; </span>
<span class="lineNum">  705</span>              :       const_reverse_iterator </span>
<span class="lineNum">  706</span>              :       crend() const noexcept </span>
<span class="lineNum">  707</span>              :       { return const_reverse_iterator(this-&gt;begin()); } </span>
<span class="lineNum">  708</span>              : #endif </span>
<span class="lineNum">  709</span>              :  </span>
<span class="lineNum">  710</span>              :     public: </span>
<span class="lineNum">  711</span>              :       &#047;&#047; Capacity: </span>
<span class="lineNum">  712</span>              :       &#047;&#047;&#047;  Returns the number of characters in the string, not including any </span>
<span class="lineNum">  713</span>              :       &#047;&#047;&#047;  null-termination. </span>
<span class="lineNum">  714</span>              :       size_type </span>
<span class="lineNum">  715</span>              :       size() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  716</span>              :       { return _M_rep()-&gt;_M_length; } </span>
<span class="lineNum">  717</span>              :  </span>
<span class="lineNum">  718</span>              :       &#047;&#047;&#047;  Returns the number of characters in the string, not including any </span>
<span class="lineNum">  719</span>              :       &#047;&#047;&#047;  null-termination. </span>
<span class="lineNum">  720</span>              :       size_type </span>
<span class="lineNum">  721</span>              :       length() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  722</span>              :       { return _M_rep()-&gt;_M_length; } </span>
<span class="lineNum">  723</span>              :  </span>
<span class="lineNum">  724</span>              :       &#047;&#047;&#047;  Returns the size() of the largest possible %string. </span>
<span class="lineNum">  725</span>              :       size_type </span>
<span class="lineNum">  726</span>              :       max_size() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  727</span>              :       { return _Rep::_S_max_size; } </span>
<span class="lineNum">  728</span>              :  </span>
<span class="lineNum">  729</span>              :       &#047;** </span>
<span class="lineNum">  730</span>              :        *  @brief  Resizes the %string to the specified number of characters. </span>
<span class="lineNum">  731</span>              :        *  @param  __n  Number of characters the %string should contain. </span>
<span class="lineNum">  732</span>              :        *  @param  __c  Character to fill any new elements. </span>
<span class="lineNum">  733</span>              :        * </span>
<span class="lineNum">  734</span>              :        *  This function will %resize the %string to the specified </span>
<span class="lineNum">  735</span>              :        *  number of characters.  If the number is smaller than the </span>
<span class="lineNum">  736</span>              :        *  %string&#039;s current size the %string is truncated, otherwise </span>
<span class="lineNum">  737</span>              :        *  the %string is extended and new elements are %set to @a __c. </span>
<span class="lineNum">  738</span>              :        *&#047; </span>
<span class="lineNum">  739</span>              :       void </span>
<span class="lineNum">  740</span>              :       resize(size_type __n, _CharT __c); </span>
<span class="lineNum">  741</span>              :  </span>
<span class="lineNum">  742</span>              :       &#047;** </span>
<span class="lineNum">  743</span>              :        *  @brief  Resizes the %string to the specified number of characters. </span>
<span class="lineNum">  744</span>              :        *  @param  __n  Number of characters the %string should contain. </span>
<span class="lineNum">  745</span>              :        * </span>
<span class="lineNum">  746</span>              :        *  This function will resize the %string to the specified length.  If </span>
<span class="lineNum">  747</span>              :        *  the new size is smaller than the %string&#039;s current size the %string </span>
<span class="lineNum">  748</span>              :        *  is truncated, otherwise the %string is extended and new characters </span>
<span class="lineNum">  749</span>              :        *  are default-constructed.  For basic types such as char, this means </span>
<span class="lineNum">  750</span>              :        *  setting them to 0. </span>
<span class="lineNum">  751</span>              :        *&#047; </span>
<span class="lineNum">  752</span>              :       void </span>
<span class="lineNum">  753</span>              :       resize(size_type __n) </span>
<span class="lineNum">  754</span>              :       { this-&gt;resize(__n, _CharT()); } </span>
<span class="lineNum">  755</span>              :  </span>
<span class="lineNum">  756</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  757</span>              :       &#047;&#047;&#047;  A non-binding request to reduce capacity() to size(). </span>
<span class="lineNum">  758</span>              :       void </span>
<span class="lineNum">  759</span>              :       shrink_to_fit() </span>
<span class="lineNum">  760</span>              :       { </span>
<span class="lineNum">  761</span>              : 	if (capacity() &gt; size()) </span>
<span class="lineNum">  762</span>              : 	  { </span>
<span class="lineNum">  763</span>              : 	    __try </span>
<span class="lineNum">  764</span>              : 	      { reserve(0); } </span>
<span class="lineNum">  765</span>              : 	    __catch(...) </span>
<span class="lineNum">  766</span>              : 	      { } </span>
<span class="lineNum">  767</span>              : 	  } </span>
<span class="lineNum">  768</span>              :       } </span>
<span class="lineNum">  769</span>              : #endif </span>
<span class="lineNum">  770</span>              :  </span>
<span class="lineNum">  771</span>              :       &#047;** </span>
<span class="lineNum">  772</span>              :        *  Returns the total number of characters that the %string can hold </span>
<span class="lineNum">  773</span>              :        *  before needing to allocate more memory. </span>
<span class="lineNum">  774</span>              :        *&#047; </span>
<span class="lineNum">  775</span>              :       size_type </span>
<span class="lineNum">  776</span>              :       capacity() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  777</span>              :       { return _M_rep()-&gt;_M_capacity; } </span>
<span class="lineNum">  778</span>              :  </span>
<span class="lineNum">  779</span>              :       &#047;** </span>
<span class="lineNum">  780</span>              :        *  @brief  Attempt to preallocate enough memory for specified number of </span>
<span class="lineNum">  781</span>              :        *          characters. </span>
<span class="lineNum">  782</span>              :        *  @param  __res_arg  Number of characters required. </span>
<span class="lineNum">  783</span>              :        *  @throw  std::length_error  If @a __res_arg exceeds @c max_size(). </span>
<span class="lineNum">  784</span>              :        * </span>
<span class="lineNum">  785</span>              :        *  This function attempts to reserve enough memory for the </span>
<span class="lineNum">  786</span>              :        *  %string to hold the specified number of characters.  If the </span>
<span class="lineNum">  787</span>              :        *  number requested is more than max_size(), length_error is </span>
<span class="lineNum">  788</span>              :        *  thrown. </span>
<span class="lineNum">  789</span>              :        * </span>
<span class="lineNum">  790</span>              :        *  The advantage of this function is that if optimal code is a </span>
<span class="lineNum">  791</span>              :        *  necessity and the user can determine the string length that will be </span>
<span class="lineNum">  792</span>              :        *  required, the user can reserve the memory in %advance, and thus </span>
<span class="lineNum">  793</span>              :        *  prevent a possible reallocation of memory and copying of %string </span>
<span class="lineNum">  794</span>              :        *  data. </span>
<span class="lineNum">  795</span>              :        *&#047; </span>
<span class="lineNum">  796</span>              :       void </span>
<span class="lineNum">  797</span>              :       reserve(size_type __res_arg = 0); </span>
<span class="lineNum">  798</span>              :  </span>
<span class="lineNum">  799</span>              :       &#047;** </span>
<span class="lineNum">  800</span>              :        *  Erases the string, making it empty. </span>
<span class="lineNum">  801</span>              :        *&#047; </span>
<span class="lineNum">  802</span>              :       void </span>
<span class="lineNum">  803</span>              :       clear() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  804</span>              :       { _M_mutate(0, this-&gt;size(), 0); } </span>
<span class="lineNum">  805</span>              :  </span>
<span class="lineNum">  806</span>              :       &#047;** </span>
<span class="lineNum">  807</span>              :        *  Returns true if the %string is empty.  Equivalent to  </span>
<span class="lineNum">  808</span>              :        *  &lt;code&gt;*this == &quot;&quot;&lt;&#047;code&gt;. </span>
<span class="lineNum">  809</span>              :        *&#047; </span>
<span class="lineNum">  810</span>              :       bool </span>
<span class="lineNum">  811</span>              :       empty() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  812</span>              :       { return this-&gt;size() == 0; } </span>
<span class="lineNum">  813</span>              :  </span>
<span class="lineNum">  814</span>              :       &#047;&#047; Element access: </span>
<span class="lineNum">  815</span>              :       &#047;** </span>
<span class="lineNum">  816</span>              :        *  @brief  Subscript access to the data contained in the %string. </span>
<span class="lineNum">  817</span>              :        *  @param  __pos  The index of the character to access. </span>
<span class="lineNum">  818</span>              :        *  @return  Read-only (constant) reference to the character. </span>
<span class="lineNum">  819</span>              :        * </span>
<span class="lineNum">  820</span>              :        *  This operator allows for easy, array-style, data access. </span>
<span class="lineNum">  821</span>              :        *  Note that data access with this operator is unchecked and </span>
<span class="lineNum">  822</span>              :        *  out_of_range lookups are not defined. (For checked lookups </span>
<span class="lineNum">  823</span>              :        *  see at().) </span>
<span class="lineNum">  824</span>              :        *&#047; </span>
<span class="lineNum">  825</span>              :       const_reference </span>
<span class="lineNum">  826</span>              :       operator[] (size_type __pos) const </span>
<span class="lineNum">  827</span>              :       { </span>
<span class="lineNum">  828</span>              : 	_GLIBCXX_DEBUG_ASSERT(__pos &lt;= size()); </span>
<span class="lineNum">  829</span>              : 	return _M_data()[__pos]; </span>
<span class="lineNum">  830</span>              :       } </span>
<span class="lineNum">  831</span>              :  </span>
<span class="lineNum">  832</span>              :       &#047;** </span>
<span class="lineNum">  833</span>              :        *  @brief  Subscript access to the data contained in the %string. </span>
<span class="lineNum">  834</span>              :        *  @param  __pos  The index of the character to access. </span>
<span class="lineNum">  835</span>              :        *  @return  Read&#047;write reference to the character. </span>
<span class="lineNum">  836</span>              :        * </span>
<span class="lineNum">  837</span>              :        *  This operator allows for easy, array-style, data access. </span>
<span class="lineNum">  838</span>              :        *  Note that data access with this operator is unchecked and </span>
<span class="lineNum">  839</span>              :        *  out_of_range lookups are not defined. (For checked lookups </span>
<span class="lineNum">  840</span>              :        *  see at().)  Unshares the string. </span>
<span class="lineNum">  841</span>              :        *&#047; </span>
<span class="lineNum">  842</span>              :       reference </span>
<span class="lineNum">  843</span>              :       operator[](size_type __pos) </span>
<span class="lineNum">  844</span>              :       { </span>
<span class="lineNum">  845</span>              :         &#047;&#047; allow pos == size() as v3 extension: </span>
<span class="lineNum">  846</span>              : 	_GLIBCXX_DEBUG_ASSERT(__pos &lt;= size()); </span>
<span class="lineNum">  847</span>              :         &#047;&#047; but be strict in pedantic mode: </span>
<span class="lineNum">  848</span>              : 	_GLIBCXX_DEBUG_PEDASSERT(__pos &lt; size()); </span>
<span class="lineNum">  849</span>              : 	_M_leak(); </span>
<span class="lineNum">  850</span>              : 	return _M_data()[__pos]; </span>
<span class="lineNum">  851</span>              :       } </span>
<span class="lineNum">  852</span>              :  </span>
<span class="lineNum">  853</span>              :       &#047;** </span>
<span class="lineNum">  854</span>              :        *  @brief  Provides access to the data contained in the %string. </span>
<span class="lineNum">  855</span>              :        *  @param __n The index of the character to access. </span>
<span class="lineNum">  856</span>              :        *  @return  Read-only (const) reference to the character. </span>
<span class="lineNum">  857</span>              :        *  @throw  std::out_of_range  If @a n is an invalid index. </span>
<span class="lineNum">  858</span>              :        * </span>
<span class="lineNum">  859</span>              :        *  This function provides for safer data access.  The parameter is </span>
<span class="lineNum">  860</span>              :        *  first checked that it is in the range of the string.  The function </span>
<span class="lineNum">  861</span>              :        *  throws out_of_range if the check fails. </span>
<span class="lineNum">  862</span>              :        *&#047; </span>
<span class="lineNum">  863</span>              :       const_reference </span>
<span class="lineNum">  864</span>              :       at(size_type __n) const </span>
<span class="lineNum">  865</span>              :       { </span>
<span class="lineNum">  866</span>              : 	if (__n &gt;= this-&gt;size()) </span>
<span class="lineNum">  867</span>              : 	  __throw_out_of_range(__N(&quot;basic_string::at&quot;)); </span>
<span class="lineNum">  868</span>              : 	return _M_data()[__n]; </span>
<span class="lineNum">  869</span>              :       } </span>
<span class="lineNum">  870</span>              :  </span>
<span class="lineNum">  871</span>              :       &#047;** </span>
<span class="lineNum">  872</span>              :        *  @brief  Provides access to the data contained in the %string. </span>
<span class="lineNum">  873</span>              :        *  @param __n The index of the character to access. </span>
<span class="lineNum">  874</span>              :        *  @return  Read&#047;write reference to the character. </span>
<span class="lineNum">  875</span>              :        *  @throw  std::out_of_range  If @a n is an invalid index. </span>
<span class="lineNum">  876</span>              :        * </span>
<span class="lineNum">  877</span>              :        *  This function provides for safer data access.  The parameter is </span>
<span class="lineNum">  878</span>              :        *  first checked that it is in the range of the string.  The function </span>
<span class="lineNum">  879</span>              :        *  throws out_of_range if the check fails.  Success results in </span>
<span class="lineNum">  880</span>              :        *  unsharing the string. </span>
<span class="lineNum">  881</span>              :        *&#047; </span>
<span class="lineNum">  882</span>              :       reference </span>
<span class="lineNum">  883</span>              :       at(size_type __n) </span>
<span class="lineNum">  884</span>              :       { </span>
<span class="lineNum">  885</span>              : 	if (__n &gt;= size()) </span>
<span class="lineNum">  886</span>              : 	  __throw_out_of_range(__N(&quot;basic_string::at&quot;)); </span>
<span class="lineNum">  887</span>              : 	_M_leak(); </span>
<span class="lineNum">  888</span>              : 	return _M_data()[__n]; </span>
<span class="lineNum">  889</span>              :       } </span>
<span class="lineNum">  890</span>              :  </span>
<span class="lineNum">  891</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  892</span>              :       &#047;** </span>
<span class="lineNum">  893</span>              :        *  Returns a read&#047;write reference to the data at the first </span>
<span class="lineNum">  894</span>              :        *  element of the %string. </span>
<span class="lineNum">  895</span>              :        *&#047; </span>
<span class="lineNum">  896</span>              :       reference </span>
<span class="lineNum">  897</span>              :       front() </span>
<span class="lineNum">  898</span>              :       { return operator[](0); } </span>
<span class="lineNum">  899</span>              :  </span>
<span class="lineNum">  900</span>              :       &#047;** </span>
<span class="lineNum">  901</span>              :        *  Returns a read-only (constant) reference to the data at the first </span>
<span class="lineNum">  902</span>              :        *  element of the %string. </span>
<span class="lineNum">  903</span>              :        *&#047; </span>
<span class="lineNum">  904</span>              :       const_reference </span>
<span class="lineNum">  905</span>              :       front() const </span>
<span class="lineNum">  906</span>              :       { return operator[](0); } </span>
<span class="lineNum">  907</span>              :  </span>
<span class="lineNum">  908</span>              :       &#047;** </span>
<span class="lineNum">  909</span>              :        *  Returns a read&#047;write reference to the data at the last </span>
<span class="lineNum">  910</span>              :        *  element of the %string. </span>
<span class="lineNum">  911</span>              :        *&#047; </span>
<span class="lineNum">  912</span>              :       reference </span>
<span class="lineNum">  913</span>              :       back() </span>
<span class="lineNum">  914</span>              :       { return operator[](this-&gt;size() - 1); } </span>
<span class="lineNum">  915</span>              :  </span>
<span class="lineNum">  916</span>              :       &#047;** </span>
<span class="lineNum">  917</span>              :        *  Returns a read-only (constant) reference to the data at the </span>
<span class="lineNum">  918</span>              :        *  last element of the %string. </span>
<span class="lineNum">  919</span>              :        *&#047; </span>
<span class="lineNum">  920</span>              :       const_reference </span>
<span class="lineNum">  921</span>              :       back() const </span>
<span class="lineNum">  922</span>              :       { return operator[](this-&gt;size() - 1); } </span>
<span class="lineNum">  923</span>              : #endif </span>
<span class="lineNum">  924</span>              :  </span>
<span class="lineNum">  925</span>              :       &#047;&#047; Modifiers: </span>
<span class="lineNum">  926</span>              :       &#047;** </span>
<span class="lineNum">  927</span>              :        *  @brief  Append a string to this string. </span>
<span class="lineNum">  928</span>              :        *  @param __str  The string to append. </span>
<span class="lineNum">  929</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum">  930</span>              :        *&#047; </span>
<span class="lineNum">  931</span>              :       basic_string&amp; </span>
<span class="lineNum">  932</span>              :       operator+=(const basic_string&amp; __str) </span>
<span class="lineNum">  933</span>              :       { return this-&gt;append(__str); } </span>
<span class="lineNum">  934</span>              :  </span>
<span class="lineNum">  935</span>              :       &#047;** </span>
<span class="lineNum">  936</span>              :        *  @brief  Append a C string. </span>
<span class="lineNum">  937</span>              :        *  @param __s  The C string to append. </span>
<span class="lineNum">  938</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum">  939</span>              :        *&#047; </span>
<span class="lineNum">  940</span>              :       basic_string&amp; </span>
<span class="lineNum">  941</span>              :       operator+=(const _CharT* __s) </span>
<span class="lineNum">  942</span>              :       { return this-&gt;append(__s); } </span>
<span class="lineNum">  943</span>              :  </span>
<span class="lineNum">  944</span>              :       &#047;** </span>
<span class="lineNum">  945</span>              :        *  @brief  Append a character. </span>
<span class="lineNum">  946</span>              :        *  @param __c  The character to append. </span>
<span class="lineNum">  947</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum">  948</span>              :        *&#047; </span>
<span class="lineNum">  949</span>              :       basic_string&amp; </span>
<span class="lineNum">  950</span>              :       operator+=(_CharT __c) </span>
<span class="lineNum">  951</span>              :       {  </span>
<span class="lineNum">  952</span>              : 	this-&gt;push_back(__c); </span>
<span class="lineNum">  953</span>              : 	return *this; </span>
<span class="lineNum">  954</span>              :       } </span>
<span class="lineNum">  955</span>              :  </span>
<span class="lineNum">  956</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  957</span>              :       &#047;** </span>
<span class="lineNum">  958</span>              :        *  @brief  Append an initializer_list of characters. </span>
<span class="lineNum">  959</span>              :        *  @param __l  The initializer_list of characters to be appended. </span>
<span class="lineNum">  960</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum">  961</span>              :        *&#047; </span>
<span class="lineNum">  962</span>              :       basic_string&amp; </span>
<span class="lineNum">  963</span>              :       operator+=(initializer_list&lt;_CharT&gt; __l) </span>
<span class="lineNum">  964</span>              :       { return this-&gt;append(__l.begin(), __l.size()); } </span>
<span class="lineNum">  965</span>              : #endif &#047;&#047; C++11 </span>
<span class="lineNum">  966</span>              :  </span>
<span class="lineNum">  967</span>              :       &#047;** </span>
<span class="lineNum">  968</span>              :        *  @brief  Append a string to this string. </span>
<span class="lineNum">  969</span>              :        *  @param __str  The string to append. </span>
<span class="lineNum">  970</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum">  971</span>              :        *&#047; </span>
<span class="lineNum">  972</span>              :       basic_string&amp; </span>
<span class="lineNum">  973</span>              :       append(const basic_string&amp; __str); </span>
<span class="lineNum">  974</span>              :  </span>
<span class="lineNum">  975</span>              :       &#047;** </span>
<span class="lineNum">  976</span>              :        *  @brief  Append a substring. </span>
<span class="lineNum">  977</span>              :        *  @param __str  The string to append. </span>
<span class="lineNum">  978</span>              :        *  @param __pos  Index of the first character of str to append. </span>
<span class="lineNum">  979</span>              :        *  @param __n  The number of characters to append. </span>
<span class="lineNum">  980</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum">  981</span>              :        *  @throw  std::out_of_range if @a __pos is not a valid index. </span>
<span class="lineNum">  982</span>              :        * </span>
<span class="lineNum">  983</span>              :        *  This function appends @a __n characters from @a __str </span>
<span class="lineNum">  984</span>              :        *  starting at @a __pos to this string.  If @a __n is is larger </span>
<span class="lineNum">  985</span>              :        *  than the number of available characters in @a __str, the </span>
<span class="lineNum">  986</span>              :        *  remainder of @a __str is appended. </span>
<span class="lineNum">  987</span>              :        *&#047; </span>
<span class="lineNum">  988</span>              :       basic_string&amp; </span>
<span class="lineNum">  989</span>              :       append(const basic_string&amp; __str, size_type __pos, size_type __n); </span>
<span class="lineNum">  990</span>              :  </span>
<span class="lineNum">  991</span>              :       &#047;** </span>
<span class="lineNum">  992</span>              :        *  @brief  Append a C substring. </span>
<span class="lineNum">  993</span>              :        *  @param __s  The C string to append. </span>
<span class="lineNum">  994</span>              :        *  @param __n  The number of characters to append. </span>
<span class="lineNum">  995</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum">  996</span>              :        *&#047; </span>
<span class="lineNum">  997</span>              :       basic_string&amp; </span>
<span class="lineNum">  998</span>              :       append(const _CharT* __s, size_type __n); </span>
<span class="lineNum">  999</span>              :  </span>
<span class="lineNum"> 1000</span>              :       &#047;** </span>
<span class="lineNum"> 1001</span>              :        *  @brief  Append a C string. </span>
<span class="lineNum"> 1002</span>              :        *  @param __s  The C string to append. </span>
<span class="lineNum"> 1003</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1004</span>              :        *&#047; </span>
<span class="lineNum"> 1005</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1006</span>              :       append(const _CharT* __s) </span>
<span class="lineNum"> 1007</span>              :       { </span>
<span class="lineNum"> 1008</span>              : 	__glibcxx_requires_string(__s); </span>
<span class="lineNum"> 1009</span>              : 	return this-&gt;append(__s, traits_type::length(__s)); </span>
<span class="lineNum"> 1010</span>              :       } </span>
<span class="lineNum"> 1011</span>              :  </span>
<span class="lineNum"> 1012</span>              :       &#047;** </span>
<span class="lineNum"> 1013</span>              :        *  @brief  Append multiple characters. </span>
<span class="lineNum"> 1014</span>              :        *  @param __n  The number of characters to append. </span>
<span class="lineNum"> 1015</span>              :        *  @param __c  The character to use. </span>
<span class="lineNum"> 1016</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1017</span>              :        * </span>
<span class="lineNum"> 1018</span>              :        *  Appends __n copies of __c to this string. </span>
<span class="lineNum"> 1019</span>              :        *&#047; </span>
<span class="lineNum"> 1020</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1021</span>              :       append(size_type __n, _CharT __c); </span>
<span class="lineNum"> 1022</span>              :  </span>
<span class="lineNum"> 1023</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1024</span>              :       &#047;** </span>
<span class="lineNum"> 1025</span>              :        *  @brief  Append an initializer_list of characters. </span>
<span class="lineNum"> 1026</span>              :        *  @param __l  The initializer_list of characters to append. </span>
<span class="lineNum"> 1027</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1028</span>              :        *&#047; </span>
<span class="lineNum"> 1029</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1030</span>              :       append(initializer_list&lt;_CharT&gt; __l) </span>
<span class="lineNum"> 1031</span>              :       { return this-&gt;append(__l.begin(), __l.size()); } </span>
<span class="lineNum"> 1032</span>              : #endif &#047;&#047; C++11 </span>
<span class="lineNum"> 1033</span>              :  </span>
<span class="lineNum"> 1034</span>              :       &#047;** </span>
<span class="lineNum"> 1035</span>              :        *  @brief  Append a range of characters. </span>
<span class="lineNum"> 1036</span>              :        *  @param __first  Iterator referencing the first character to append. </span>
<span class="lineNum"> 1037</span>              :        *  @param __last  Iterator marking the end of the range. </span>
<span class="lineNum"> 1038</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1039</span>              :        * </span>
<span class="lineNum"> 1040</span>              :        *  Appends characters in the range [__first,__last) to this string. </span>
<span class="lineNum"> 1041</span>              :        *&#047; </span>
<span class="lineNum"> 1042</span>              :       template&lt;class _InputIterator&gt; </span>
<span class="lineNum"> 1043</span>              :         basic_string&amp; </span>
<span class="lineNum"> 1044</span>              :         append(_InputIterator __first, _InputIterator __last) </span>
<span class="lineNum"> 1045</span>              :         { return this-&gt;replace(_M_iend(), _M_iend(), __first, __last); } </span>
<span class="lineNum"> 1046</span>              :  </span>
<span class="lineNum"> 1047</span>              :       &#047;** </span>
<span class="lineNum"> 1048</span>              :        *  @brief  Append a single character. </span>
<span class="lineNum"> 1049</span>              :        *  @param __c  Character to append. </span>
<span class="lineNum"> 1050</span>              :        *&#047; </span>
<span class="lineNum"> 1051</span>              :       void </span>
<span class="lineNum"> 1052</span>              :       push_back(_CharT __c) </span>
<span class="lineNum"> 1053</span>              :       {  </span>
<span class="lineNum"> 1054</span>              : 	const size_type __len = 1 + this-&gt;size(); </span>
<span class="lineNum"> 1055</span>              : 	if (__len &gt; this-&gt;capacity() || _M_rep()-&gt;_M_is_shared()) </span>
<span class="lineNum"> 1056</span>              : 	  this-&gt;reserve(__len); </span>
<span class="lineNum"> 1057</span>              : 	traits_type::assign(_M_data()[this-&gt;size()], __c); </span>
<span class="lineNum"> 1058</span>              : 	_M_rep()-&gt;_M_set_length_and_sharable(__len); </span>
<span class="lineNum"> 1059</span>              :       } </span>
<span class="lineNum"> 1060</span>              :  </span>
<span class="lineNum"> 1061</span>              :       &#047;** </span>
<span class="lineNum"> 1062</span>              :        *  @brief  Set value to contents of another string. </span>
<span class="lineNum"> 1063</span>              :        *  @param  __str  Source string to use. </span>
<span class="lineNum"> 1064</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1065</span>              :        *&#047; </span>
<span class="lineNum"> 1066</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1067</span>              :       assign(const basic_string&amp; __str); </span>
<span class="lineNum"> 1068</span>              :  </span>
<span class="lineNum"> 1069</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1070</span>              :       &#047;** </span>
<span class="lineNum"> 1071</span>              :        *  @brief  Set value to contents of another string. </span>
<span class="lineNum"> 1072</span>              :        *  @param  __str  Source string to use. </span>
<span class="lineNum"> 1073</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1074</span>              :        * </span>
<span class="lineNum"> 1075</span>              :        *  This function sets this string to the exact contents of @a __str. </span>
<span class="lineNum"> 1076</span>              :        *  @a __str is a valid, but unspecified string. </span>
<span class="lineNum"> 1077</span>              :        *&#047; </span>
<span class="lineNum"> 1078</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1079</span>              :       assign(basic_string&amp;&amp; __str) </span>
<span class="lineNum"> 1080</span>              :       { </span>
<span class="lineNum"> 1081</span>              : 	this-&gt;swap(__str); </span>
<span class="lineNum"> 1082</span>              : 	return *this; </span>
<span class="lineNum"> 1083</span>              :       } </span>
<span class="lineNum"> 1084</span>              : #endif &#047;&#047; C++11 </span>
<span class="lineNum"> 1085</span>              :  </span>
<span class="lineNum"> 1086</span>              :       &#047;** </span>
<span class="lineNum"> 1087</span>              :        *  @brief  Set value to a substring of a string. </span>
<span class="lineNum"> 1088</span>              :        *  @param __str  The string to use. </span>
<span class="lineNum"> 1089</span>              :        *  @param __pos  Index of the first character of str. </span>
<span class="lineNum"> 1090</span>              :        *  @param __n  Number of characters to use. </span>
<span class="lineNum"> 1091</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1092</span>              :        *  @throw  std::out_of_range if @a pos is not a valid index. </span>
<span class="lineNum"> 1093</span>              :        * </span>
<span class="lineNum"> 1094</span>              :        *  This function sets this string to the substring of @a __str </span>
<span class="lineNum"> 1095</span>              :        *  consisting of @a __n characters at @a __pos.  If @a __n is </span>
<span class="lineNum"> 1096</span>              :        *  is larger than the number of available characters in @a </span>
<span class="lineNum"> 1097</span>              :        *  __str, the remainder of @a __str is used. </span>
<span class="lineNum"> 1098</span>              :        *&#047; </span>
<span class="lineNum"> 1099</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1100</span>              :       assign(const basic_string&amp; __str, size_type __pos, size_type __n) </span>
<span class="lineNum"> 1101</span>              :       { return this-&gt;assign(__str._M_data() </span>
<span class="lineNum"> 1102</span>              : 			    + __str._M_check(__pos, &quot;basic_string::assign&quot;), </span>
<span class="lineNum"> 1103</span>              : 			    __str._M_limit(__pos, __n)); } </span>
<span class="lineNum"> 1104</span>              :  </span>
<span class="lineNum"> 1105</span>              :       &#047;** </span>
<span class="lineNum"> 1106</span>              :        *  @brief  Set value to a C substring. </span>
<span class="lineNum"> 1107</span>              :        *  @param __s  The C string to use. </span>
<span class="lineNum"> 1108</span>              :        *  @param __n  Number of characters to use. </span>
<span class="lineNum"> 1109</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1110</span>              :        * </span>
<span class="lineNum"> 1111</span>              :        *  This function sets the value of this string to the first @a __n </span>
<span class="lineNum"> 1112</span>              :        *  characters of @a __s.  If @a __n is is larger than the number of </span>
<span class="lineNum"> 1113</span>              :        *  available characters in @a __s, the remainder of @a __s is used. </span>
<span class="lineNum"> 1114</span>              :        *&#047; </span>
<span class="lineNum"> 1115</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1116</span>              :       assign(const _CharT* __s, size_type __n); </span>
<span class="lineNum"> 1117</span>              :  </span>
<span class="lineNum"> 1118</span>              :       &#047;** </span>
<span class="lineNum"> 1119</span>              :        *  @brief  Set value to contents of a C string. </span>
<span class="lineNum"> 1120</span>              :        *  @param __s  The C string to use. </span>
<span class="lineNum"> 1121</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1122</span>              :        * </span>
<span class="lineNum"> 1123</span>              :        *  This function sets the value of this string to the value of @a __s. </span>
<span class="lineNum"> 1124</span>              :        *  The data is copied, so there is no dependence on @a __s once the </span>
<span class="lineNum"> 1125</span>              :        *  function returns. </span>
<span class="lineNum"> 1126</span>              :        *&#047; </span>
<span class="lineNum"> 1127</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1128</span>              :       assign(const _CharT* __s) </span>
<span class="lineNum"> 1129</span>              :       { </span>
<span class="lineNum"> 1130</span>              : 	__glibcxx_requires_string(__s); </span>
<span class="lineNum"> 1131</span>              : 	return this-&gt;assign(__s, traits_type::length(__s)); </span>
<span class="lineNum"> 1132</span>              :       } </span>
<span class="lineNum"> 1133</span>              :  </span>
<span class="lineNum"> 1134</span>              :       &#047;** </span>
<span class="lineNum"> 1135</span>              :        *  @brief  Set value to multiple characters. </span>
<span class="lineNum"> 1136</span>              :        *  @param __n  Length of the resulting string. </span>
<span class="lineNum"> 1137</span>              :        *  @param __c  The character to use. </span>
<span class="lineNum"> 1138</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1139</span>              :        * </span>
<span class="lineNum"> 1140</span>              :        *  This function sets the value of this string to @a __n copies of </span>
<span class="lineNum"> 1141</span>              :        *  character @a __c. </span>
<span class="lineNum"> 1142</span>              :        *&#047; </span>
<span class="lineNum"> 1143</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1144</span>              :       assign(size_type __n, _CharT __c) </span>
<span class="lineNum"> 1145</span>              :       { return _M_replace_aux(size_type(0), this-&gt;size(), __n, __c); } </span>
<span class="lineNum"> 1146</span>              :  </span>
<span class="lineNum"> 1147</span>              :       &#047;** </span>
<span class="lineNum"> 1148</span>              :        *  @brief  Set value to a range of characters. </span>
<span class="lineNum"> 1149</span>              :        *  @param __first  Iterator referencing the first character to append. </span>
<span class="lineNum"> 1150</span>              :        *  @param __last  Iterator marking the end of the range. </span>
<span class="lineNum"> 1151</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1152</span>              :        * </span>
<span class="lineNum"> 1153</span>              :        *  Sets value of string to characters in the range [__first,__last). </span>
<span class="lineNum"> 1154</span>              :       *&#047; </span>
<span class="lineNum"> 1155</span>              :       template&lt;class _InputIterator&gt; </span>
<span class="lineNum"> 1156</span>              :         basic_string&amp; </span>
<span class="lineNum"> 1157</span>              :         assign(_InputIterator __first, _InputIterator __last) </span>
<span class="lineNum"> 1158</span>              :         { return this-&gt;replace(_M_ibegin(), _M_iend(), __first, __last); } </span>
<span class="lineNum"> 1159</span>              :  </span>
<span class="lineNum"> 1160</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1161</span>              :       &#047;** </span>
<span class="lineNum"> 1162</span>              :        *  @brief  Set value to an initializer_list of characters. </span>
<span class="lineNum"> 1163</span>              :        *  @param __l  The initializer_list of characters to assign. </span>
<span class="lineNum"> 1164</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1165</span>              :        *&#047; </span>
<span class="lineNum"> 1166</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1167</span>              :       assign(initializer_list&lt;_CharT&gt; __l) </span>
<span class="lineNum"> 1168</span>              :       { return this-&gt;assign(__l.begin(), __l.size()); } </span>
<span class="lineNum"> 1169</span>              : #endif &#047;&#047; C++11 </span>
<span class="lineNum"> 1170</span>              :  </span>
<span class="lineNum"> 1171</span>              :       &#047;** </span>
<span class="lineNum"> 1172</span>              :        *  @brief  Insert multiple characters. </span>
<span class="lineNum"> 1173</span>              :        *  @param __p  Iterator referencing location in string to insert at. </span>
<span class="lineNum"> 1174</span>              :        *  @param __n  Number of characters to insert </span>
<span class="lineNum"> 1175</span>              :        *  @param __c  The character to insert. </span>
<span class="lineNum"> 1176</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1177</span>              :        * </span>
<span class="lineNum"> 1178</span>              :        *  Inserts @a __n copies of character @a __c starting at the </span>
<span class="lineNum"> 1179</span>              :        *  position referenced by iterator @a __p.  If adding </span>
<span class="lineNum"> 1180</span>              :        *  characters causes the length to exceed max_size(), </span>
<span class="lineNum"> 1181</span>              :        *  length_error is thrown.  The value of the string doesn&#039;t </span>
<span class="lineNum"> 1182</span>              :        *  change if an error is thrown. </span>
<span class="lineNum"> 1183</span>              :       *&#047; </span>
<span class="lineNum"> 1184</span>              :       void </span>
<span class="lineNum"> 1185</span>              :       insert(iterator __p, size_type __n, _CharT __c) </span>
<span class="lineNum"> 1186</span>              :       {	this-&gt;replace(__p, __p, __n, __c);  } </span>
<span class="lineNum"> 1187</span>              :  </span>
<span class="lineNum"> 1188</span>              :       &#047;** </span>
<span class="lineNum"> 1189</span>              :        *  @brief  Insert a range of characters. </span>
<span class="lineNum"> 1190</span>              :        *  @param __p  Iterator referencing location in string to insert at. </span>
<span class="lineNum"> 1191</span>              :        *  @param __beg  Start of range. </span>
<span class="lineNum"> 1192</span>              :        *  @param __end  End of range. </span>
<span class="lineNum"> 1193</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1194</span>              :        * </span>
<span class="lineNum"> 1195</span>              :        *  Inserts characters in range [__beg,__end).  If adding </span>
<span class="lineNum"> 1196</span>              :        *  characters causes the length to exceed max_size(), </span>
<span class="lineNum"> 1197</span>              :        *  length_error is thrown.  The value of the string doesn&#039;t </span>
<span class="lineNum"> 1198</span>              :        *  change if an error is thrown. </span>
<span class="lineNum"> 1199</span>              :       *&#047; </span>
<span class="lineNum"> 1200</span>              :       template&lt;class _InputIterator&gt; </span>
<span class="lineNum"> 1201</span>              :         void </span>
<span class="lineNum"> 1202</span>              :         insert(iterator __p, _InputIterator __beg, _InputIterator __end) </span>
<span class="lineNum"> 1203</span>              :         { this-&gt;replace(__p, __p, __beg, __end); } </span>
<span class="lineNum"> 1204</span>              :  </span>
<span class="lineNum"> 1205</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1206</span>              :       &#047;** </span>
<span class="lineNum"> 1207</span>              :        *  @brief  Insert an initializer_list of characters. </span>
<span class="lineNum"> 1208</span>              :        *  @param __p  Iterator referencing location in string to insert at. </span>
<span class="lineNum"> 1209</span>              :        *  @param __l  The initializer_list of characters to insert. </span>
<span class="lineNum"> 1210</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1211</span>              :        *&#047; </span>
<span class="lineNum"> 1212</span>              :       void </span>
<span class="lineNum"> 1213</span>              :       insert(iterator __p, initializer_list&lt;_CharT&gt; __l) </span>
<span class="lineNum"> 1214</span>              :       { </span>
<span class="lineNum"> 1215</span>              : 	_GLIBCXX_DEBUG_PEDASSERT(__p &gt;= _M_ibegin() &amp;&amp; __p &lt;= _M_iend()); </span>
<span class="lineNum"> 1216</span>              : 	this-&gt;insert(__p - _M_ibegin(), __l.begin(), __l.size()); </span>
<span class="lineNum"> 1217</span>              :       } </span>
<span class="lineNum"> 1218</span>              : #endif &#047;&#047; C++11 </span>
<span class="lineNum"> 1219</span>              :  </span>
<span class="lineNum"> 1220</span>              :       &#047;** </span>
<span class="lineNum"> 1221</span>              :        *  @brief  Insert value of a string. </span>
<span class="lineNum"> 1222</span>              :        *  @param __pos1  Iterator referencing location in string to insert at. </span>
<span class="lineNum"> 1223</span>              :        *  @param __str  The string to insert. </span>
<span class="lineNum"> 1224</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1225</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1226</span>              :        * </span>
<span class="lineNum"> 1227</span>              :        *  Inserts value of @a __str starting at @a __pos1.  If adding </span>
<span class="lineNum"> 1228</span>              :        *  characters causes the length to exceed max_size(), </span>
<span class="lineNum"> 1229</span>              :        *  length_error is thrown.  The value of the string doesn&#039;t </span>
<span class="lineNum"> 1230</span>              :        *  change if an error is thrown. </span>
<span class="lineNum"> 1231</span>              :       *&#047; </span>
<span class="lineNum"> 1232</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1233</span>              :       insert(size_type __pos1, const basic_string&amp; __str) </span>
<span class="lineNum"> 1234</span>              :       { return this-&gt;insert(__pos1, __str, size_type(0), __str.size()); } </span>
<span class="lineNum"> 1235</span>              :  </span>
<span class="lineNum"> 1236</span>              :       &#047;** </span>
<span class="lineNum"> 1237</span>              :        *  @brief  Insert a substring. </span>
<span class="lineNum"> 1238</span>              :        *  @param __pos1  Iterator referencing location in string to insert at. </span>
<span class="lineNum"> 1239</span>              :        *  @param __str  The string to insert. </span>
<span class="lineNum"> 1240</span>              :        *  @param __pos2  Start of characters in str to insert. </span>
<span class="lineNum"> 1241</span>              :        *  @param __n  Number of characters to insert. </span>
<span class="lineNum"> 1242</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1243</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1244</span>              :        *  @throw  std::out_of_range  If @a pos1 &gt; size() or </span>
<span class="lineNum"> 1245</span>              :        *  @a __pos2 &gt; @a str.size(). </span>
<span class="lineNum"> 1246</span>              :        * </span>
<span class="lineNum"> 1247</span>              :        *  Starting at @a pos1, insert @a __n character of @a __str </span>
<span class="lineNum"> 1248</span>              :        *  beginning with @a __pos2.  If adding characters causes the </span>
<span class="lineNum"> 1249</span>              :        *  length to exceed max_size(), length_error is thrown.  If @a </span>
<span class="lineNum"> 1250</span>              :        *  __pos1 is beyond the end of this string or @a __pos2 is </span>
<span class="lineNum"> 1251</span>              :        *  beyond the end of @a __str, out_of_range is thrown.  The </span>
<span class="lineNum"> 1252</span>              :        *  value of the string doesn&#039;t change if an error is thrown. </span>
<span class="lineNum"> 1253</span>              :       *&#047; </span>
<span class="lineNum"> 1254</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1255</span>              :       insert(size_type __pos1, const basic_string&amp; __str, </span>
<span class="lineNum"> 1256</span>              : 	     size_type __pos2, size_type __n) </span>
<span class="lineNum"> 1257</span>              :       { return this-&gt;insert(__pos1, __str._M_data() </span>
<span class="lineNum"> 1258</span>              : 			    + __str._M_check(__pos2, &quot;basic_string::insert&quot;), </span>
<span class="lineNum"> 1259</span>              : 			    __str._M_limit(__pos2, __n)); } </span>
<span class="lineNum"> 1260</span>              :  </span>
<span class="lineNum"> 1261</span>              :       &#047;** </span>
<span class="lineNum"> 1262</span>              :        *  @brief  Insert a C substring. </span>
<span class="lineNum"> 1263</span>              :        *  @param __pos  Iterator referencing location in string to insert at. </span>
<span class="lineNum"> 1264</span>              :        *  @param __s  The C string to insert. </span>
<span class="lineNum"> 1265</span>              :        *  @param __n  The number of characters to insert. </span>
<span class="lineNum"> 1266</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1267</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1268</span>              :        *  @throw  std::out_of_range  If @a __pos is beyond the end of this </span>
<span class="lineNum"> 1269</span>              :        *  string. </span>
<span class="lineNum"> 1270</span>              :        * </span>
<span class="lineNum"> 1271</span>              :        *  Inserts the first @a __n characters of @a __s starting at @a </span>
<span class="lineNum"> 1272</span>              :        *  __pos.  If adding characters causes the length to exceed </span>
<span class="lineNum"> 1273</span>              :        *  max_size(), length_error is thrown.  If @a __pos is beyond </span>
<span class="lineNum"> 1274</span>              :        *  end(), out_of_range is thrown.  The value of the string </span>
<span class="lineNum"> 1275</span>              :        *  doesn&#039;t change if an error is thrown. </span>
<span class="lineNum"> 1276</span>              :       *&#047; </span>
<span class="lineNum"> 1277</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1278</span>              :       insert(size_type __pos, const _CharT* __s, size_type __n); </span>
<span class="lineNum"> 1279</span>              :  </span>
<span class="lineNum"> 1280</span>              :       &#047;** </span>
<span class="lineNum"> 1281</span>              :        *  @brief  Insert a C string. </span>
<span class="lineNum"> 1282</span>              :        *  @param __pos  Iterator referencing location in string to insert at. </span>
<span class="lineNum"> 1283</span>              :        *  @param __s  The C string to insert. </span>
<span class="lineNum"> 1284</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1285</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1286</span>              :        *  @throw  std::out_of_range  If @a pos is beyond the end of this </span>
<span class="lineNum"> 1287</span>              :        *  string. </span>
<span class="lineNum"> 1288</span>              :        * </span>
<span class="lineNum"> 1289</span>              :        *  Inserts the first @a n characters of @a __s starting at @a __pos.  If </span>
<span class="lineNum"> 1290</span>              :        *  adding characters causes the length to exceed max_size(), </span>
<span class="lineNum"> 1291</span>              :        *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is </span>
<span class="lineNum"> 1292</span>              :        *  thrown.  The value of the string doesn&#039;t change if an error is </span>
<span class="lineNum"> 1293</span>              :        *  thrown. </span>
<span class="lineNum"> 1294</span>              :       *&#047; </span>
<span class="lineNum"> 1295</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1296</span>              :       insert(size_type __pos, const _CharT* __s) </span>
<span class="lineNum"> 1297</span>              :       { </span>
<span class="lineNum"> 1298</span>              : 	__glibcxx_requires_string(__s); </span>
<span class="lineNum"> 1299</span>              : 	return this-&gt;insert(__pos, __s, traits_type::length(__s)); </span>
<span class="lineNum"> 1300</span>              :       } </span>
<span class="lineNum"> 1301</span>              :  </span>
<span class="lineNum"> 1302</span>              :       &#047;** </span>
<span class="lineNum"> 1303</span>              :        *  @brief  Insert multiple characters. </span>
<span class="lineNum"> 1304</span>              :        *  @param __pos  Index in string to insert at. </span>
<span class="lineNum"> 1305</span>              :        *  @param __n  Number of characters to insert </span>
<span class="lineNum"> 1306</span>              :        *  @param __c  The character to insert. </span>
<span class="lineNum"> 1307</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1308</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1309</span>              :        *  @throw  std::out_of_range  If @a __pos is beyond the end of this </span>
<span class="lineNum"> 1310</span>              :        *  string. </span>
<span class="lineNum"> 1311</span>              :        * </span>
<span class="lineNum"> 1312</span>              :        *  Inserts @a __n copies of character @a __c starting at index </span>
<span class="lineNum"> 1313</span>              :        *  @a __pos.  If adding characters causes the length to exceed </span>
<span class="lineNum"> 1314</span>              :        *  max_size(), length_error is thrown.  If @a __pos &gt; length(), </span>
<span class="lineNum"> 1315</span>              :        *  out_of_range is thrown.  The value of the string doesn&#039;t </span>
<span class="lineNum"> 1316</span>              :        *  change if an error is thrown. </span>
<span class="lineNum"> 1317</span>              :       *&#047; </span>
<span class="lineNum"> 1318</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1319</span>              :       insert(size_type __pos, size_type __n, _CharT __c) </span>
<span class="lineNum"> 1320</span>              :       { return _M_replace_aux(_M_check(__pos, &quot;basic_string::insert&quot;), </span>
<span class="lineNum"> 1321</span>              : 			      size_type(0), __n, __c); } </span>
<span class="lineNum"> 1322</span>              :  </span>
<span class="lineNum"> 1323</span>              :       &#047;** </span>
<span class="lineNum"> 1324</span>              :        *  @brief  Insert one character. </span>
<span class="lineNum"> 1325</span>              :        *  @param __p  Iterator referencing position in string to insert at. </span>
<span class="lineNum"> 1326</span>              :        *  @param __c  The character to insert. </span>
<span class="lineNum"> 1327</span>              :        *  @return  Iterator referencing newly inserted char. </span>
<span class="lineNum"> 1328</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1329</span>              :        * </span>
<span class="lineNum"> 1330</span>              :        *  Inserts character @a __c at position referenced by @a __p. </span>
<span class="lineNum"> 1331</span>              :        *  If adding character causes the length to exceed max_size(), </span>
<span class="lineNum"> 1332</span>              :        *  length_error is thrown.  If @a __p is beyond end of string, </span>
<span class="lineNum"> 1333</span>              :        *  out_of_range is thrown.  The value of the string doesn&#039;t </span>
<span class="lineNum"> 1334</span>              :        *  change if an error is thrown. </span>
<span class="lineNum"> 1335</span>              :       *&#047; </span>
<span class="lineNum"> 1336</span>              :       iterator </span>
<span class="lineNum"> 1337</span>              :       insert(iterator __p, _CharT __c) </span>
<span class="lineNum"> 1338</span>              :       { </span>
<span class="lineNum"> 1339</span>              : 	_GLIBCXX_DEBUG_PEDASSERT(__p &gt;= _M_ibegin() &amp;&amp; __p &lt;= _M_iend()); </span>
<span class="lineNum"> 1340</span>              : 	const size_type __pos = __p - _M_ibegin(); </span>
<span class="lineNum"> 1341</span>              : 	_M_replace_aux(__pos, size_type(0), size_type(1), __c); </span>
<span class="lineNum"> 1342</span>              : 	_M_rep()-&gt;_M_set_leaked(); </span>
<span class="lineNum"> 1343</span>              : 	return iterator(_M_data() + __pos); </span>
<span class="lineNum"> 1344</span>              :       } </span>
<span class="lineNum"> 1345</span>              :  </span>
<span class="lineNum"> 1346</span>              :       &#047;** </span>
<span class="lineNum"> 1347</span>              :        *  @brief  Remove characters. </span>
<span class="lineNum"> 1348</span>              :        *  @param __pos  Index of first character to remove (default 0). </span>
<span class="lineNum"> 1349</span>              :        *  @param __n  Number of characters to remove (default remainder). </span>
<span class="lineNum"> 1350</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1351</span>              :        *  @throw  std::out_of_range  If @a pos is beyond the end of this </span>
<span class="lineNum"> 1352</span>              :        *  string. </span>
<span class="lineNum"> 1353</span>              :        * </span>
<span class="lineNum"> 1354</span>              :        *  Removes @a __n characters from this string starting at @a </span>
<span class="lineNum"> 1355</span>              :        *  __pos.  The length of the string is reduced by @a __n.  If </span>
<span class="lineNum"> 1356</span>              :        *  there are &lt; @a __n characters to remove, the remainder of </span>
<span class="lineNum"> 1357</span>              :        *  the string is truncated.  If @a __p is beyond end of string, </span>
<span class="lineNum"> 1358</span>              :        *  out_of_range is thrown.  The value of the string doesn&#039;t </span>
<span class="lineNum"> 1359</span>              :        *  change if an error is thrown. </span>
<span class="lineNum"> 1360</span>              :       *&#047; </span>
<span class="lineNum"> 1361</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1362</span>              :       erase(size_type __pos = 0, size_type __n = npos) </span>
<span class="lineNum"> 1363</span>              :       {  </span>
<span class="lineNum"> 1364</span>              : 	_M_mutate(_M_check(__pos, &quot;basic_string::erase&quot;), </span>
<span class="lineNum"> 1365</span>              : 		  _M_limit(__pos, __n), size_type(0)); </span>
<span class="lineNum"> 1366</span>              : 	return *this; </span>
<span class="lineNum"> 1367</span>              :       } </span>
<span class="lineNum"> 1368</span>              :  </span>
<span class="lineNum"> 1369</span>              :       &#047;** </span>
<span class="lineNum"> 1370</span>              :        *  @brief  Remove one character. </span>
<span class="lineNum"> 1371</span>              :        *  @param __position  Iterator referencing the character to remove. </span>
<span class="lineNum"> 1372</span>              :        *  @return  iterator referencing same location after removal. </span>
<span class="lineNum"> 1373</span>              :        * </span>
<span class="lineNum"> 1374</span>              :        *  Removes the character at @a __position from this string. The value </span>
<span class="lineNum"> 1375</span>              :        *  of the string doesn&#039;t change if an error is thrown. </span>
<span class="lineNum"> 1376</span>              :       *&#047; </span>
<span class="lineNum"> 1377</span>              :       iterator </span>
<span class="lineNum"> 1378</span>              :       erase(iterator __position) </span>
<span class="lineNum"> 1379</span>              :       { </span>
<span class="lineNum"> 1380</span>              : 	_GLIBCXX_DEBUG_PEDASSERT(__position &gt;= _M_ibegin() </span>
<span class="lineNum"> 1381</span>              : 				 &amp;&amp; __position &lt; _M_iend()); </span>
<span class="lineNum"> 1382</span>              : 	const size_type __pos = __position - _M_ibegin(); </span>
<span class="lineNum"> 1383</span>              : 	_M_mutate(__pos, size_type(1), size_type(0)); </span>
<span class="lineNum"> 1384</span>              : 	_M_rep()-&gt;_M_set_leaked(); </span>
<span class="lineNum"> 1385</span>              : 	return iterator(_M_data() + __pos); </span>
<span class="lineNum"> 1386</span>              :       } </span>
<span class="lineNum"> 1387</span>              :  </span>
<span class="lineNum"> 1388</span>              :       &#047;** </span>
<span class="lineNum"> 1389</span>              :        *  @brief  Remove a range of characters. </span>
<span class="lineNum"> 1390</span>              :        *  @param __first  Iterator referencing the first character to remove. </span>
<span class="lineNum"> 1391</span>              :        *  @param __last  Iterator referencing the end of the range. </span>
<span class="lineNum"> 1392</span>              :        *  @return  Iterator referencing location of first after removal. </span>
<span class="lineNum"> 1393</span>              :        * </span>
<span class="lineNum"> 1394</span>              :        *  Removes the characters in the range [first,last) from this string. </span>
<span class="lineNum"> 1395</span>              :        *  The value of the string doesn&#039;t change if an error is thrown. </span>
<span class="lineNum"> 1396</span>              :       *&#047; </span>
<span class="lineNum"> 1397</span>              :       iterator </span>
<span class="lineNum"> 1398</span>              :       erase(iterator __first, iterator __last); </span>
<span class="lineNum"> 1399</span>              :   </span>
<span class="lineNum"> 1400</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1401</span>              :       &#047;** </span>
<span class="lineNum"> 1402</span>              :        *  @brief  Remove the last character. </span>
<span class="lineNum"> 1403</span>              :        * </span>
<span class="lineNum"> 1404</span>              :        *  The string must be non-empty. </span>
<span class="lineNum"> 1405</span>              :        *&#047; </span>
<span class="lineNum"> 1406</span>              :       void </span>
<span class="lineNum"> 1407</span>              :       pop_back() </span>
<span class="lineNum"> 1408</span>              :       { erase(size()-1, 1); } </span>
<span class="lineNum"> 1409</span>              : #endif &#047;&#047; C++11 </span>
<span class="lineNum"> 1410</span>              :  </span>
<span class="lineNum"> 1411</span>              :       &#047;** </span>
<span class="lineNum"> 1412</span>              :        *  @brief  Replace characters with value from another string. </span>
<span class="lineNum"> 1413</span>              :        *  @param __pos  Index of first character to replace. </span>
<span class="lineNum"> 1414</span>              :        *  @param __n  Number of characters to be replaced. </span>
<span class="lineNum"> 1415</span>              :        *  @param __str  String to insert. </span>
<span class="lineNum"> 1416</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1417</span>              :        *  @throw  std::out_of_range  If @a pos is beyond the end of this </span>
<span class="lineNum"> 1418</span>              :        *  string. </span>
<span class="lineNum"> 1419</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1420</span>              :        * </span>
<span class="lineNum"> 1421</span>              :        *  Removes the characters in the range [__pos,__pos+__n) from </span>
<span class="lineNum"> 1422</span>              :        *  this string.  In place, the value of @a __str is inserted. </span>
<span class="lineNum"> 1423</span>              :        *  If @a __pos is beyond end of string, out_of_range is thrown. </span>
<span class="lineNum"> 1424</span>              :        *  If the length of the result exceeds max_size(), length_error </span>
<span class="lineNum"> 1425</span>              :        *  is thrown.  The value of the string doesn&#039;t change if an </span>
<span class="lineNum"> 1426</span>              :        *  error is thrown. </span>
<span class="lineNum"> 1427</span>              :       *&#047; </span>
<span class="lineNum"> 1428</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1429</span>              :       replace(size_type __pos, size_type __n, const basic_string&amp; __str) </span>
<span class="lineNum"> 1430</span>              :       { return this-&gt;replace(__pos, __n, __str._M_data(), __str.size()); } </span>
<span class="lineNum"> 1431</span>              :  </span>
<span class="lineNum"> 1432</span>              :       &#047;** </span>
<span class="lineNum"> 1433</span>              :        *  @brief  Replace characters with value from another string. </span>
<span class="lineNum"> 1434</span>              :        *  @param __pos1  Index of first character to replace. </span>
<span class="lineNum"> 1435</span>              :        *  @param __n1  Number of characters to be replaced. </span>
<span class="lineNum"> 1436</span>              :        *  @param __str  String to insert. </span>
<span class="lineNum"> 1437</span>              :        *  @param __pos2  Index of first character of str to use. </span>
<span class="lineNum"> 1438</span>              :        *  @param __n2  Number of characters from str to use. </span>
<span class="lineNum"> 1439</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1440</span>              :        *  @throw  std::out_of_range  If @a __pos1 &gt; size() or @a __pos2 &gt; </span>
<span class="lineNum"> 1441</span>              :        *  __str.size(). </span>
<span class="lineNum"> 1442</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1443</span>              :        * </span>
<span class="lineNum"> 1444</span>              :        *  Removes the characters in the range [__pos1,__pos1 + n) from this </span>
<span class="lineNum"> 1445</span>              :        *  string.  In place, the value of @a __str is inserted.  If @a __pos is </span>
<span class="lineNum"> 1446</span>              :        *  beyond end of string, out_of_range is thrown.  If the length of the </span>
<span class="lineNum"> 1447</span>              :        *  result exceeds max_size(), length_error is thrown.  The value of the </span>
<span class="lineNum"> 1448</span>              :        *  string doesn&#039;t change if an error is thrown. </span>
<span class="lineNum"> 1449</span>              :       *&#047; </span>
<span class="lineNum"> 1450</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1451</span>              :       replace(size_type __pos1, size_type __n1, const basic_string&amp; __str, </span>
<span class="lineNum"> 1452</span>              : 	      size_type __pos2, size_type __n2) </span>
<span class="lineNum"> 1453</span>              :       { return this-&gt;replace(__pos1, __n1, __str._M_data() </span>
<span class="lineNum"> 1454</span>              : 			     + __str._M_check(__pos2, &quot;basic_string::replace&quot;), </span>
<span class="lineNum"> 1455</span>              : 			     __str._M_limit(__pos2, __n2)); } </span>
<span class="lineNum"> 1456</span>              :  </span>
<span class="lineNum"> 1457</span>              :       &#047;** </span>
<span class="lineNum"> 1458</span>              :        *  @brief  Replace characters with value of a C substring. </span>
<span class="lineNum"> 1459</span>              :        *  @param __pos  Index of first character to replace. </span>
<span class="lineNum"> 1460</span>              :        *  @param __n1  Number of characters to be replaced. </span>
<span class="lineNum"> 1461</span>              :        *  @param __s  C string to insert. </span>
<span class="lineNum"> 1462</span>              :        *  @param __n2  Number of characters from @a s to use. </span>
<span class="lineNum"> 1463</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1464</span>              :        *  @throw  std::out_of_range  If @a pos1 &gt; size(). </span>
<span class="lineNum"> 1465</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1466</span>              :        * </span>
<span class="lineNum"> 1467</span>              :        *  Removes the characters in the range [__pos,__pos + __n1) </span>
<span class="lineNum"> 1468</span>              :        *  from this string.  In place, the first @a __n2 characters of </span>
<span class="lineNum"> 1469</span>              :        *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If </span>
<span class="lineNum"> 1470</span>              :        *  @a __pos is beyond end of string, out_of_range is thrown.  If </span>
<span class="lineNum"> 1471</span>              :        *  the length of result exceeds max_size(), length_error is </span>
<span class="lineNum"> 1472</span>              :        *  thrown.  The value of the string doesn&#039;t change if an error </span>
<span class="lineNum"> 1473</span>              :        *  is thrown. </span>
<span class="lineNum"> 1474</span>              :       *&#047; </span>
<span class="lineNum"> 1475</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1476</span>              :       replace(size_type __pos, size_type __n1, const _CharT* __s, </span>
<span class="lineNum"> 1477</span>              : 	      size_type __n2); </span>
<span class="lineNum"> 1478</span>              :  </span>
<span class="lineNum"> 1479</span>              :       &#047;** </span>
<span class="lineNum"> 1480</span>              :        *  @brief  Replace characters with value of a C string. </span>
<span class="lineNum"> 1481</span>              :        *  @param __pos  Index of first character to replace. </span>
<span class="lineNum"> 1482</span>              :        *  @param __n1  Number of characters to be replaced. </span>
<span class="lineNum"> 1483</span>              :        *  @param __s  C string to insert. </span>
<span class="lineNum"> 1484</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1485</span>              :        *  @throw  std::out_of_range  If @a pos &gt; size(). </span>
<span class="lineNum"> 1486</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1487</span>              :        * </span>
<span class="lineNum"> 1488</span>              :        *  Removes the characters in the range [__pos,__pos + __n1) </span>
<span class="lineNum"> 1489</span>              :        *  from this string.  In place, the characters of @a __s are </span>
<span class="lineNum"> 1490</span>              :        *  inserted.  If @a __pos is beyond end of string, out_of_range </span>
<span class="lineNum"> 1491</span>              :        *  is thrown.  If the length of result exceeds max_size(), </span>
<span class="lineNum"> 1492</span>              :        *  length_error is thrown.  The value of the string doesn&#039;t </span>
<span class="lineNum"> 1493</span>              :        *  change if an error is thrown. </span>
<span class="lineNum"> 1494</span>              :       *&#047; </span>
<span class="lineNum"> 1495</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1496</span>              :       replace(size_type __pos, size_type __n1, const _CharT* __s) </span>
<span class="lineNum"> 1497</span>              :       { </span>
<span class="lineNum"> 1498</span>              : 	__glibcxx_requires_string(__s); </span>
<span class="lineNum"> 1499</span>              : 	return this-&gt;replace(__pos, __n1, __s, traits_type::length(__s)); </span>
<span class="lineNum"> 1500</span>              :       } </span>
<span class="lineNum"> 1501</span>              :  </span>
<span class="lineNum"> 1502</span>              :       &#047;** </span>
<span class="lineNum"> 1503</span>              :        *  @brief  Replace characters with multiple characters. </span>
<span class="lineNum"> 1504</span>              :        *  @param __pos  Index of first character to replace. </span>
<span class="lineNum"> 1505</span>              :        *  @param __n1  Number of characters to be replaced. </span>
<span class="lineNum"> 1506</span>              :        *  @param __n2  Number of characters to insert. </span>
<span class="lineNum"> 1507</span>              :        *  @param __c  Character to insert. </span>
<span class="lineNum"> 1508</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1509</span>              :        *  @throw  std::out_of_range  If @a __pos &gt; size(). </span>
<span class="lineNum"> 1510</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1511</span>              :        * </span>
<span class="lineNum"> 1512</span>              :        *  Removes the characters in the range [pos,pos + n1) from this </span>
<span class="lineNum"> 1513</span>              :        *  string.  In place, @a __n2 copies of @a __c are inserted. </span>
<span class="lineNum"> 1514</span>              :        *  If @a __pos is beyond end of string, out_of_range is thrown. </span>
<span class="lineNum"> 1515</span>              :        *  If the length of result exceeds max_size(), length_error is </span>
<span class="lineNum"> 1516</span>              :        *  thrown.  The value of the string doesn&#039;t change if an error </span>
<span class="lineNum"> 1517</span>              :        *  is thrown. </span>
<span class="lineNum"> 1518</span>              :       *&#047; </span>
<span class="lineNum"> 1519</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1520</span>              :       replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c) </span>
<span class="lineNum"> 1521</span>              :       { return _M_replace_aux(_M_check(__pos, &quot;basic_string::replace&quot;), </span>
<span class="lineNum"> 1522</span>              : 			      _M_limit(__pos, __n1), __n2, __c); } </span>
<span class="lineNum"> 1523</span>              :  </span>
<span class="lineNum"> 1524</span>              :       &#047;** </span>
<span class="lineNum"> 1525</span>              :        *  @brief  Replace range of characters with string. </span>
<span class="lineNum"> 1526</span>              :        *  @param __i1  Iterator referencing start of range to replace. </span>
<span class="lineNum"> 1527</span>              :        *  @param __i2  Iterator referencing end of range to replace. </span>
<span class="lineNum"> 1528</span>              :        *  @param __str  String value to insert. </span>
<span class="lineNum"> 1529</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1530</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1531</span>              :        * </span>
<span class="lineNum"> 1532</span>              :        *  Removes the characters in the range [__i1,__i2).  In place, </span>
<span class="lineNum"> 1533</span>              :        *  the value of @a __str is inserted.  If the length of result </span>
<span class="lineNum"> 1534</span>              :        *  exceeds max_size(), length_error is thrown.  The value of </span>
<span class="lineNum"> 1535</span>              :        *  the string doesn&#039;t change if an error is thrown. </span>
<span class="lineNum"> 1536</span>              :       *&#047; </span>
<span class="lineNum"> 1537</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1538</span>              :       replace(iterator __i1, iterator __i2, const basic_string&amp; __str) </span>
<span class="lineNum"> 1539</span>              :       { return this-&gt;replace(__i1, __i2, __str._M_data(), __str.size()); } </span>
<span class="lineNum"> 1540</span>              :  </span>
<span class="lineNum"> 1541</span>              :       &#047;** </span>
<span class="lineNum"> 1542</span>              :        *  @brief  Replace range of characters with C substring. </span>
<span class="lineNum"> 1543</span>              :        *  @param __i1  Iterator referencing start of range to replace. </span>
<span class="lineNum"> 1544</span>              :        *  @param __i2  Iterator referencing end of range to replace. </span>
<span class="lineNum"> 1545</span>              :        *  @param __s  C string value to insert. </span>
<span class="lineNum"> 1546</span>              :        *  @param __n  Number of characters from s to insert. </span>
<span class="lineNum"> 1547</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1548</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1549</span>              :        * </span>
<span class="lineNum"> 1550</span>              :        *  Removes the characters in the range [__i1,__i2).  In place, </span>
<span class="lineNum"> 1551</span>              :        *  the first @a __n characters of @a __s are inserted.  If the </span>
<span class="lineNum"> 1552</span>              :        *  length of result exceeds max_size(), length_error is thrown. </span>
<span class="lineNum"> 1553</span>              :        *  The value of the string doesn&#039;t change if an error is </span>
<span class="lineNum"> 1554</span>              :        *  thrown. </span>
<span class="lineNum"> 1555</span>              :       *&#047; </span>
<span class="lineNum"> 1556</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1557</span>              :       replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n) </span>
<span class="lineNum"> 1558</span>              :       { </span>
<span class="lineNum"> 1559</span>              : 	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() &lt;= __i1 &amp;&amp; __i1 &lt;= __i2 </span>
<span class="lineNum"> 1560</span>              : 				 &amp;&amp; __i2 &lt;= _M_iend()); </span>
<span class="lineNum"> 1561</span>              : 	return this-&gt;replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n); </span>
<span class="lineNum"> 1562</span>              :       } </span>
<span class="lineNum"> 1563</span>              :  </span>
<span class="lineNum"> 1564</span>              :       &#047;** </span>
<span class="lineNum"> 1565</span>              :        *  @brief  Replace range of characters with C string. </span>
<span class="lineNum"> 1566</span>              :        *  @param __i1  Iterator referencing start of range to replace. </span>
<span class="lineNum"> 1567</span>              :        *  @param __i2  Iterator referencing end of range to replace. </span>
<span class="lineNum"> 1568</span>              :        *  @param __s  C string value to insert. </span>
<span class="lineNum"> 1569</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1570</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1571</span>              :        * </span>
<span class="lineNum"> 1572</span>              :        *  Removes the characters in the range [__i1,__i2).  In place, </span>
<span class="lineNum"> 1573</span>              :        *  the characters of @a __s are inserted.  If the length of </span>
<span class="lineNum"> 1574</span>              :        *  result exceeds max_size(), length_error is thrown.  The </span>
<span class="lineNum"> 1575</span>              :        *  value of the string doesn&#039;t change if an error is thrown. </span>
<span class="lineNum"> 1576</span>              :       *&#047; </span>
<span class="lineNum"> 1577</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1578</span>              :       replace(iterator __i1, iterator __i2, const _CharT* __s) </span>
<span class="lineNum"> 1579</span>              :       { </span>
<span class="lineNum"> 1580</span>              : 	__glibcxx_requires_string(__s); </span>
<span class="lineNum"> 1581</span>              : 	return this-&gt;replace(__i1, __i2, __s, traits_type::length(__s)); </span>
<span class="lineNum"> 1582</span>              :       } </span>
<span class="lineNum"> 1583</span>              :  </span>
<span class="lineNum"> 1584</span>              :       &#047;** </span>
<span class="lineNum"> 1585</span>              :        *  @brief  Replace range of characters with multiple characters </span>
<span class="lineNum"> 1586</span>              :        *  @param __i1  Iterator referencing start of range to replace. </span>
<span class="lineNum"> 1587</span>              :        *  @param __i2  Iterator referencing end of range to replace. </span>
<span class="lineNum"> 1588</span>              :        *  @param __n  Number of characters to insert. </span>
<span class="lineNum"> 1589</span>              :        *  @param __c  Character to insert. </span>
<span class="lineNum"> 1590</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1591</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1592</span>              :        * </span>
<span class="lineNum"> 1593</span>              :        *  Removes the characters in the range [__i1,__i2).  In place, </span>
<span class="lineNum"> 1594</span>              :        *  @a __n copies of @a __c are inserted.  If the length of </span>
<span class="lineNum"> 1595</span>              :        *  result exceeds max_size(), length_error is thrown.  The </span>
<span class="lineNum"> 1596</span>              :        *  value of the string doesn&#039;t change if an error is thrown. </span>
<span class="lineNum"> 1597</span>              :       *&#047; </span>
<span class="lineNum"> 1598</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1599</span>              :       replace(iterator __i1, iterator __i2, size_type __n, _CharT __c) </span>
<span class="lineNum"> 1600</span>              :       { </span>
<span class="lineNum"> 1601</span>              : 	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() &lt;= __i1 &amp;&amp; __i1 &lt;= __i2 </span>
<span class="lineNum"> 1602</span>              : 				 &amp;&amp; __i2 &lt;= _M_iend()); </span>
<span class="lineNum"> 1603</span>              : 	return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c); </span>
<span class="lineNum"> 1604</span>              :       } </span>
<span class="lineNum"> 1605</span>              :  </span>
<span class="lineNum"> 1606</span>              :       &#047;** </span>
<span class="lineNum"> 1607</span>              :        *  @brief  Replace range of characters with range. </span>
<span class="lineNum"> 1608</span>              :        *  @param __i1  Iterator referencing start of range to replace. </span>
<span class="lineNum"> 1609</span>              :        *  @param __i2  Iterator referencing end of range to replace. </span>
<span class="lineNum"> 1610</span>              :        *  @param __k1  Iterator referencing start of range to insert. </span>
<span class="lineNum"> 1611</span>              :        *  @param __k2  Iterator referencing end of range to insert. </span>
<span class="lineNum"> 1612</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1613</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1614</span>              :        * </span>
<span class="lineNum"> 1615</span>              :        *  Removes the characters in the range [__i1,__i2).  In place, </span>
<span class="lineNum"> 1616</span>              :        *  characters in the range [__k1,__k2) are inserted.  If the </span>
<span class="lineNum"> 1617</span>              :        *  length of result exceeds max_size(), length_error is thrown. </span>
<span class="lineNum"> 1618</span>              :        *  The value of the string doesn&#039;t change if an error is </span>
<span class="lineNum"> 1619</span>              :        *  thrown. </span>
<span class="lineNum"> 1620</span>              :       *&#047; </span>
<span class="lineNum"> 1621</span>              :       template&lt;class _InputIterator&gt; </span>
<span class="lineNum"> 1622</span>              :         basic_string&amp; </span>
<span class="lineNum"> 1623</span>              :         replace(iterator __i1, iterator __i2, </span>
<span class="lineNum"> 1624</span>              : 		_InputIterator __k1, _InputIterator __k2) </span>
<span class="lineNum"> 1625</span>              :         { </span>
<span class="lineNum"> 1626</span>              : 	  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() &lt;= __i1 &amp;&amp; __i1 &lt;= __i2 </span>
<span class="lineNum"> 1627</span>              : 				   &amp;&amp; __i2 &lt;= _M_iend()); </span>
<span class="lineNum"> 1628</span>              : 	  __glibcxx_requires_valid_range(__k1, __k2); </span>
<span class="lineNum"> 1629</span>              : 	  typedef typename std::__is_integer&lt;_InputIterator&gt;::__type _Integral; </span>
<span class="lineNum"> 1630</span>              : 	  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral()); </span>
<span class="lineNum"> 1631</span>              : 	} </span>
<span class="lineNum"> 1632</span>              :  </span>
<span class="lineNum"> 1633</span>              :       &#047;&#047; Specializations for the common case of pointer and iterator: </span>
<span class="lineNum"> 1634</span>              :       &#047;&#047; useful to avoid the overhead of temporary buffering in _M_replace. </span>
<span class="lineNum"> 1635</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1636</span>              :       replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2) </span>
<span class="lineNum"> 1637</span>              :       { </span>
<span class="lineNum"> 1638</span>              : 	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() &lt;= __i1 &amp;&amp; __i1 &lt;= __i2 </span>
<span class="lineNum"> 1639</span>              : 				 &amp;&amp; __i2 &lt;= _M_iend()); </span>
<span class="lineNum"> 1640</span>              : 	__glibcxx_requires_valid_range(__k1, __k2); </span>
<span class="lineNum"> 1641</span>              : 	return this-&gt;replace(__i1 - _M_ibegin(), __i2 - __i1, </span>
<span class="lineNum"> 1642</span>              : 			     __k1, __k2 - __k1); </span>
<span class="lineNum"> 1643</span>              :       } </span>
<span class="lineNum"> 1644</span>              :  </span>
<span class="lineNum"> 1645</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1646</span>              :       replace(iterator __i1, iterator __i2, </span>
<span class="lineNum"> 1647</span>              : 	      const _CharT* __k1, const _CharT* __k2) </span>
<span class="lineNum"> 1648</span>              :       { </span>
<span class="lineNum"> 1649</span>              : 	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() &lt;= __i1 &amp;&amp; __i1 &lt;= __i2 </span>
<span class="lineNum"> 1650</span>              : 				 &amp;&amp; __i2 &lt;= _M_iend()); </span>
<span class="lineNum"> 1651</span>              : 	__glibcxx_requires_valid_range(__k1, __k2); </span>
<span class="lineNum"> 1652</span>              : 	return this-&gt;replace(__i1 - _M_ibegin(), __i2 - __i1, </span>
<span class="lineNum"> 1653</span>              : 			     __k1, __k2 - __k1); </span>
<span class="lineNum"> 1654</span>              :       } </span>
<span class="lineNum"> 1655</span>              :  </span>
<span class="lineNum"> 1656</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1657</span>              :       replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2) </span>
<span class="lineNum"> 1658</span>              :       { </span>
<span class="lineNum"> 1659</span>              : 	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() &lt;= __i1 &amp;&amp; __i1 &lt;= __i2 </span>
<span class="lineNum"> 1660</span>              : 				 &amp;&amp; __i2 &lt;= _M_iend()); </span>
<span class="lineNum"> 1661</span>              : 	__glibcxx_requires_valid_range(__k1, __k2); </span>
<span class="lineNum"> 1662</span>              : 	return this-&gt;replace(__i1 - _M_ibegin(), __i2 - __i1, </span>
<span class="lineNum"> 1663</span>              : 			     __k1.base(), __k2 - __k1); </span>
<span class="lineNum"> 1664</span>              :       } </span>
<span class="lineNum"> 1665</span>              :  </span>
<span class="lineNum"> 1666</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1667</span>              :       replace(iterator __i1, iterator __i2, </span>
<span class="lineNum"> 1668</span>              : 	      const_iterator __k1, const_iterator __k2) </span>
<span class="lineNum"> 1669</span>              :       { </span>
<span class="lineNum"> 1670</span>              : 	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() &lt;= __i1 &amp;&amp; __i1 &lt;= __i2 </span>
<span class="lineNum"> 1671</span>              : 				 &amp;&amp; __i2 &lt;= _M_iend()); </span>
<span class="lineNum"> 1672</span>              : 	__glibcxx_requires_valid_range(__k1, __k2); </span>
<span class="lineNum"> 1673</span>              : 	return this-&gt;replace(__i1 - _M_ibegin(), __i2 - __i1, </span>
<span class="lineNum"> 1674</span>              : 			     __k1.base(), __k2 - __k1); </span>
<span class="lineNum"> 1675</span>              :       } </span>
<span class="lineNum"> 1676</span>              :        </span>
<span class="lineNum"> 1677</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1678</span>              :       &#047;** </span>
<span class="lineNum"> 1679</span>              :        *  @brief  Replace range of characters with initializer_list. </span>
<span class="lineNum"> 1680</span>              :        *  @param __i1  Iterator referencing start of range to replace. </span>
<span class="lineNum"> 1681</span>              :        *  @param __i2  Iterator referencing end of range to replace. </span>
<span class="lineNum"> 1682</span>              :        *  @param __l  The initializer_list of characters to insert. </span>
<span class="lineNum"> 1683</span>              :        *  @return  Reference to this string. </span>
<span class="lineNum"> 1684</span>              :        *  @throw  std::length_error  If new length exceeds @c max_size(). </span>
<span class="lineNum"> 1685</span>              :        * </span>
<span class="lineNum"> 1686</span>              :        *  Removes the characters in the range [__i1,__i2).  In place, </span>
<span class="lineNum"> 1687</span>              :        *  characters in the range [__k1,__k2) are inserted.  If the </span>
<span class="lineNum"> 1688</span>              :        *  length of result exceeds max_size(), length_error is thrown. </span>
<span class="lineNum"> 1689</span>              :        *  The value of the string doesn&#039;t change if an error is </span>
<span class="lineNum"> 1690</span>              :        *  thrown. </span>
<span class="lineNum"> 1691</span>              :       *&#047; </span>
<span class="lineNum"> 1692</span>              :       basic_string&amp; replace(iterator __i1, iterator __i2, </span>
<span class="lineNum"> 1693</span>              : 			    initializer_list&lt;_CharT&gt; __l) </span>
<span class="lineNum"> 1694</span>              :       { return this-&gt;replace(__i1, __i2, __l.begin(), __l.end()); } </span>
<span class="lineNum"> 1695</span>              : #endif &#047;&#047; C++11 </span>
<span class="lineNum"> 1696</span>              :  </span>
<span class="lineNum"> 1697</span>              :     private: </span>
<span class="lineNum"> 1698</span>              :       template&lt;class _Integer&gt; </span>
<span class="lineNum"> 1699</span>              : 	basic_string&amp; </span>
<span class="lineNum"> 1700</span>              : 	_M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n, </span>
<span class="lineNum"> 1701</span>              : 			    _Integer __val, __true_type) </span>
<span class="lineNum"> 1702</span>              :         { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); } </span>
<span class="lineNum"> 1703</span>              :  </span>
<span class="lineNum"> 1704</span>              :       template&lt;class _InputIterator&gt; </span>
<span class="lineNum"> 1705</span>              : 	basic_string&amp; </span>
<span class="lineNum"> 1706</span>              : 	_M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1, </span>
<span class="lineNum"> 1707</span>              : 			    _InputIterator __k2, __false_type); </span>
<span class="lineNum"> 1708</span>              :  </span>
<span class="lineNum"> 1709</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1710</span>              :       _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, </span>
<span class="lineNum"> 1711</span>              : 		     _CharT __c); </span>
<span class="lineNum"> 1712</span>              :  </span>
<span class="lineNum"> 1713</span>              :       basic_string&amp; </span>
<span class="lineNum"> 1714</span>              :       _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s, </span>
<span class="lineNum"> 1715</span>              : 		      size_type __n2); </span>
<span class="lineNum"> 1716</span>              :  </span>
<span class="lineNum"> 1717</span>              :       &#047;&#047; _S_construct_aux is used to implement the 21.3.1 para 15 which </span>
<span class="lineNum"> 1718</span>              :       &#047;&#047; requires special behaviour if _InIter is an integral type </span>
<span class="lineNum"> 1719</span>              :       template&lt;class _InIterator&gt; </span>
<span class="lineNum"> 1720</span>              :         static _CharT* </span>
<span class="lineNum"> 1721</span>              :         _S_construct_aux(_InIterator __beg, _InIterator __end, </span>
<span class="lineNum"> 1722</span>              : 			 const _Alloc&amp; __a, __false_type) </span>
<span class="lineNum"> 1723</span>              : 	{ </span>
<span class="lineNum"> 1724</span>              :           typedef typename iterator_traits&lt;_InIterator&gt;::iterator_category _Tag; </span>
<span class="lineNum"> 1725</span>              :           return _S_construct(__beg, __end, __a, _Tag()); </span>
<span class="lineNum"> 1726</span>              : 	} </span>
<span class="lineNum"> 1727</span>              :  </span>
<span class="lineNum"> 1728</span>              :       &#047;&#047; _GLIBCXX_RESOLVE_LIB_DEFECTS </span>
<span class="lineNum"> 1729</span>              :       &#047;&#047; 438. Ambiguity in the &quot;do the right thing&quot; clause </span>
<span class="lineNum"> 1730</span>              :       template&lt;class _Integer&gt; </span>
<span class="lineNum"> 1731</span>              :         static _CharT* </span>
<span class="lineNum"> 1732</span>              :         _S_construct_aux(_Integer __beg, _Integer __end, </span>
<span class="lineNum"> 1733</span>              : 			 const _Alloc&amp; __a, __true_type) </span>
<span class="lineNum"> 1734</span>              :         { return _S_construct_aux_2(static_cast&lt;size_type&gt;(__beg), </span>
<span class="lineNum"> 1735</span>              : 				    __end, __a); } </span>
<span class="lineNum"> 1736</span>              :  </span>
<span class="lineNum"> 1737</span>              :       static _CharT* </span>
<span class="lineNum"> 1738</span>              :       _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc&amp; __a) </span>
<span class="lineNum"> 1739</span>              :       { return _S_construct(__req, __c, __a); } </span>
<span class="lineNum"> 1740</span>              :  </span>
<span class="lineNum"> 1741</span>              :       template&lt;class _InIterator&gt; </span>
<span class="lineNum"> 1742</span>              :         static _CharT* </span>
<span class="lineNum"> 1743</span>              :         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc&amp; __a) </span>
<span class="lineNum"> 1744</span>              : 	{ </span>
<span class="lineNum"> 1745</span>              : 	  typedef typename std::__is_integer&lt;_InIterator&gt;::__type _Integral; </span>
<span class="lineNum"> 1746</span>              : 	  return _S_construct_aux(__beg, __end, __a, _Integral()); </span>
<span class="lineNum"> 1747</span>              :         } </span>
<span class="lineNum"> 1748</span>              :  </span>
<span class="lineNum"> 1749</span>              :       &#047;&#047; For Input Iterators, used in istreambuf_iterators, etc. </span>
<span class="lineNum"> 1750</span>              :       template&lt;class _InIterator&gt; </span>
<span class="lineNum"> 1751</span>              :         static _CharT* </span>
<span class="lineNum"> 1752</span>              :          _S_construct(_InIterator __beg, _InIterator __end, const _Alloc&amp; __a, </span>
<span class="lineNum"> 1753</span>              : 		      input_iterator_tag); </span>
<span class="lineNum"> 1754</span>              :  </span>
<span class="lineNum"> 1755</span>              :       &#047;&#047; For forward_iterators up to random_access_iterators, used for </span>
<span class="lineNum"> 1756</span>              :       &#047;&#047; string::iterator, _CharT*, etc. </span>
<span class="lineNum"> 1757</span>              :       template&lt;class _FwdIterator&gt; </span>
<span class="lineNum"> 1758</span>              :         static _CharT* </span>
<span class="lineNum"> 1759</span>              :         _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc&amp; __a, </span>
<span class="lineNum"> 1760</span>              : 		     forward_iterator_tag); </span>
<span class="lineNum"> 1761</span>              :  </span>
<span class="lineNum"> 1762</span>              :       static _CharT* </span>
<span class="lineNum"> 1763</span>              :       _S_construct(size_type __req, _CharT __c, const _Alloc&amp; __a); </span>
<span class="lineNum"> 1764</span>              :  </span>
<span class="lineNum"> 1765</span>              :     public: </span>
<span class="lineNum"> 1766</span>              :  </span>
<span class="lineNum"> 1767</span>              :       &#047;** </span>
<span class="lineNum"> 1768</span>              :        *  @brief  Copy substring into C string. </span>
<span class="lineNum"> 1769</span>              :        *  @param __s  C string to copy value into. </span>
<span class="lineNum"> 1770</span>              :        *  @param __n  Number of characters to copy. </span>
<span class="lineNum"> 1771</span>              :        *  @param __pos  Index of first character to copy. </span>
<span class="lineNum"> 1772</span>              :        *  @return  Number of characters actually copied </span>
<span class="lineNum"> 1773</span>              :        *  @throw  std::out_of_range  If __pos &gt; size(). </span>
<span class="lineNum"> 1774</span>              :        * </span>
<span class="lineNum"> 1775</span>              :        *  Copies up to @a __n characters starting at @a __pos into the </span>
<span class="lineNum"> 1776</span>              :        *  C string @a __s.  If @a __pos is %greater than size(), </span>
<span class="lineNum"> 1777</span>              :        *  out_of_range is thrown. </span>
<span class="lineNum"> 1778</span>              :       *&#047; </span>
<span class="lineNum"> 1779</span>              :       size_type </span>
<span class="lineNum"> 1780</span>              :       copy(_CharT* __s, size_type __n, size_type __pos = 0) const; </span>
<span class="lineNum"> 1781</span>              :  </span>
<span class="lineNum"> 1782</span>              :       &#047;** </span>
<span class="lineNum"> 1783</span>              :        *  @brief  Swap contents with another string. </span>
<span class="lineNum"> 1784</span>              :        *  @param __s  String to swap with. </span>
<span class="lineNum"> 1785</span>              :        * </span>
<span class="lineNum"> 1786</span>              :        *  Exchanges the contents of this string with that of @a __s in constant </span>
<span class="lineNum"> 1787</span>              :        *  time. </span>
<span class="lineNum"> 1788</span>              :       *&#047; </span>
<span class="lineNum"> 1789</span>              :       void </span>
<span class="lineNum"> 1790</span>              :       swap(basic_string&amp; __s); </span>
<span class="lineNum"> 1791</span>              :  </span>
<span class="lineNum"> 1792</span>              :       &#047;&#047; String operations: </span>
<span class="lineNum"> 1793</span>              :       &#047;** </span>
<span class="lineNum"> 1794</span>              :        *  @brief  Return const pointer to null-terminated contents. </span>
<span class="lineNum"> 1795</span>              :        * </span>
<span class="lineNum"> 1796</span>              :        *  This is a handle to internal data.  Do not modify or dire things may </span>
<span class="lineNum"> 1797</span>              :        *  happen. </span>
<span class="lineNum"> 1798</span>              :       *&#047; </span>
<span class="lineNum"> 1799</span>              :       const _CharT* </span>
<span class="lineNum"> 1800</span>              :       c_str() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum"> 1801</span>              :       { return _M_data(); } </span>
<span class="lineNum"> 1802</span>              :  </span>
<span class="lineNum"> 1803</span>              :       &#047;** </span>
<span class="lineNum"> 1804</span>              :        *  @brief  Return const pointer to contents. </span>
<span class="lineNum"> 1805</span>              :        * </span>
<span class="lineNum"> 1806</span>              :        *  This is a handle to internal data.  Do not modify or dire things may </span>
<span class="lineNum"> 1807</span>              :        *  happen. </span>
<span class="lineNum"> 1808</span>              :       *&#047; </span>
<span class="lineNum"> 1809</span>              :       const _CharT* </span>
<span class="lineNum"> 1810</span>              :       data() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum"> 1811</span>              :       { return _M_data(); } </span>
<span class="lineNum"> 1812</span>              :  </span>
<span class="lineNum"> 1813</span>              :       &#047;** </span>
<span class="lineNum"> 1814</span>              :        *  @brief  Return copy of allocator used to construct this string. </span>
<span class="lineNum"> 1815</span>              :       *&#047; </span>
<span class="lineNum"> 1816</span>              :       allocator_type </span>
<span class="lineNum"> 1817</span>              :       get_allocator() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum"> 1818</span>              :       { return _M_dataplus; } </span>
<span class="lineNum"> 1819</span>              :  </span>
<span class="lineNum"> 1820</span>              :       &#047;** </span>
<span class="lineNum"> 1821</span>              :        *  @brief  Find position of a C substring. </span>
<span class="lineNum"> 1822</span>              :        *  @param __s  C string to locate. </span>
<span class="lineNum"> 1823</span>              :        *  @param __pos  Index of character to search from. </span>
<span class="lineNum"> 1824</span>              :        *  @param __n  Number of characters from @a s to search for. </span>
<span class="lineNum"> 1825</span>              :        *  @return  Index of start of first occurrence. </span>
<span class="lineNum"> 1826</span>              :        * </span>
<span class="lineNum"> 1827</span>              :        *  Starting from @a __pos, searches forward for the first @a </span>
<span class="lineNum"> 1828</span>              :        *  __n characters in @a __s within this string.  If found, </span>
<span class="lineNum"> 1829</span>              :        *  returns the index where it begins.  If not found, returns </span>
<span class="lineNum"> 1830</span>              :        *  npos. </span>
<span class="lineNum"> 1831</span>              :       *&#047; </span>
<span class="lineNum"> 1832</span>              :       size_type </span>
<span class="lineNum"> 1833</span>              :       find(const _CharT* __s, size_type __pos, size_type __n) const; </span>
<span class="lineNum"> 1834</span>              :  </span>
<span class="lineNum"> 1835</span>              :       &#047;** </span>
<span class="lineNum"> 1836</span>              :        *  @brief  Find position of a string. </span>
<span class="lineNum"> 1837</span>              :        *  @param __str  String to locate. </span>
<span class="lineNum"> 1838</span>              :        *  @param __pos  Index of character to search from (default 0). </span>
<span class="lineNum"> 1839</span>              :        *  @return  Index of start of first occurrence. </span>
<span class="lineNum"> 1840</span>              :        * </span>
<span class="lineNum"> 1841</span>              :        *  Starting from @a __pos, searches forward for value of @a __str within </span>
<span class="lineNum"> 1842</span>              :        *  this string.  If found, returns the index where it begins.  If not </span>
<span class="lineNum"> 1843</span>              :        *  found, returns npos. </span>
<span class="lineNum"> 1844</span>              :       *&#047; </span>
<span class="lineNum"> 1845</span>              :       size_type </span>
<span class="lineNum"> 1846</span>              :       find(const basic_string&amp; __str, size_type __pos = 0) const </span>
<span class="lineNum"> 1847</span>              : 	_GLIBCXX_NOEXCEPT </span>
<span class="lineNum"> 1848</span>              :       { return this-&gt;find(__str.data(), __pos, __str.size()); } </span>
<span class="lineNum"> 1849</span>              :  </span>
<span class="lineNum"> 1850</span>              :       &#047;** </span>
<span class="lineNum"> 1851</span>              :        *  @brief  Find position of a C string. </span>
<span class="lineNum"> 1852</span>              :        *  @param __s  C string to locate. </span>
<span class="lineNum"> 1853</span>              :        *  @param __pos  Index of character to search from (default 0). </span>
<span class="lineNum"> 1854</span>              :        *  @return  Index of start of first occurrence. </span>
<span class="lineNum"> 1855</span>              :        * </span>
<span class="lineNum"> 1856</span>              :        *  Starting from @a __pos, searches forward for the value of @a </span>
<span class="lineNum"> 1857</span>              :        *  __s within this string.  If found, returns the index where </span>
<span class="lineNum"> 1858</span>              :        *  it begins.  If not found, returns npos. </span>
<span class="lineNum"> 1859</span>              :       *&#047; </span>
<span class="lineNum"> 1860</span>              :       size_type </span>
<span class="lineNum"> 1861</span>              :       find(const _CharT* __s, size_type __pos = 0) const </span>
<span class="lineNum"> 1862</span>              :       { </span>
<span class="lineNum"> 1863</span>              : 	__glibcxx_requires_string(__s); </span>
<span class="lineNum"> 1864</span>              : 	return this-&gt;find(__s, __pos, traits_type::length(__s)); </span>
<span class="lineNum"> 1865</span>              :       } </span>
<span class="lineNum"> 1866</span>              :  </span>
<span class="lineNum"> 1867</span>              :       &#047;** </span>
<span class="lineNum"> 1868</span>              :        *  @brief  Find position of a character. </span>
<span class="lineNum"> 1869</span>              :        *  @param __c  Character to locate. </span>
<span class="lineNum"> 1870</span>              :        *  @param __pos  Index of character to search from (default 0). </span>
<span class="lineNum"> 1871</span>              :        *  @return  Index of first occurrence. </span>
<span class="lineNum"> 1872</span>              :        * </span>
<span class="lineNum"> 1873</span>              :        *  Starting from @a __pos, searches forward for @a __c within </span>
<span class="lineNum"> 1874</span>              :        *  this string.  If found, returns the index where it was </span>
<span class="lineNum"> 1875</span>              :        *  found.  If not found, returns npos. </span>
<span class="lineNum"> 1876</span>              :       *&#047; </span>
<span class="lineNum"> 1877</span>              :       size_type </span>
<span class="lineNum"> 1878</span>              :       find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT; </span>
<span class="lineNum"> 1879</span>              :  </span>
<span class="lineNum"> 1880</span>              :       &#047;** </span>
<span class="lineNum"> 1881</span>              :        *  @brief  Find last position of a string. </span>
<span class="lineNum"> 1882</span>              :        *  @param __str  String to locate. </span>
<span class="lineNum"> 1883</span>              :        *  @param __pos  Index of character to search back from (default end). </span>
<span class="lineNum"> 1884</span>              :        *  @return  Index of start of last occurrence. </span>
<span class="lineNum"> 1885</span>              :        * </span>
<span class="lineNum"> 1886</span>              :        *  Starting from @a __pos, searches backward for value of @a </span>
<span class="lineNum"> 1887</span>              :        *  __str within this string.  If found, returns the index where </span>
<span class="lineNum"> 1888</span>              :        *  it begins.  If not found, returns npos. </span>
<span class="lineNum"> 1889</span>              :       *&#047; </span>
<span class="lineNum"> 1890</span>              :       size_type </span>
<span class="lineNum"> 1891</span>              :       rfind(const basic_string&amp; __str, size_type __pos = npos) const </span>
<span class="lineNum"> 1892</span>              : 	_GLIBCXX_NOEXCEPT </span>
<span class="lineNum"> 1893</span>              :       { return this-&gt;rfind(__str.data(), __pos, __str.size()); } </span>
<span class="lineNum"> 1894</span>              :  </span>
<span class="lineNum"> 1895</span>              :       &#047;** </span>
<span class="lineNum"> 1896</span>              :        *  @brief  Find last position of a C substring. </span>
<span class="lineNum"> 1897</span>              :        *  @param __s  C string to locate. </span>
<span class="lineNum"> 1898</span>              :        *  @param __pos  Index of character to search back from. </span>
<span class="lineNum"> 1899</span>              :        *  @param __n  Number of characters from s to search for. </span>
<span class="lineNum"> 1900</span>              :        *  @return  Index of start of last occurrence. </span>
<span class="lineNum"> 1901</span>              :        * </span>
<span class="lineNum"> 1902</span>              :        *  Starting from @a __pos, searches backward for the first @a </span>
<span class="lineNum"> 1903</span>              :        *  __n characters in @a __s within this string.  If found, </span>
<span class="lineNum"> 1904</span>              :        *  returns the index where it begins.  If not found, returns </span>
<span class="lineNum"> 1905</span>              :        *  npos. </span>
<span class="lineNum"> 1906</span>              :       *&#047; </span>
<span class="lineNum"> 1907</span>              :       size_type </span>
<span class="lineNum"> 1908</span>              :       rfind(const _CharT* __s, size_type __pos, size_type __n) const; </span>
<span class="lineNum"> 1909</span>              :  </span>
<span class="lineNum"> 1910</span>              :       &#047;** </span>
<span class="lineNum"> 1911</span>              :        *  @brief  Find last position of a C string. </span>
<span class="lineNum"> 1912</span>              :        *  @param __s  C string to locate. </span>
<span class="lineNum"> 1913</span>              :        *  @param __pos  Index of character to start search at (default end). </span>
<span class="lineNum"> 1914</span>              :        *  @return  Index of start of  last occurrence. </span>
<span class="lineNum"> 1915</span>              :        * </span>
<span class="lineNum"> 1916</span>              :        *  Starting from @a __pos, searches backward for the value of </span>
<span class="lineNum"> 1917</span>              :        *  @a __s within this string.  If found, returns the index </span>
<span class="lineNum"> 1918</span>              :        *  where it begins.  If not found, returns npos. </span>
<span class="lineNum"> 1919</span>              :       *&#047; </span>
<span class="lineNum"> 1920</span>              :       size_type </span>
<span class="lineNum"> 1921</span>              :       rfind(const _CharT* __s, size_type __pos = npos) const </span>
<span class="lineNum"> 1922</span>              :       { </span>
<span class="lineNum"> 1923</span>              : 	__glibcxx_requires_string(__s); </span>
<span class="lineNum"> 1924</span>              : 	return this-&gt;rfind(__s, __pos, traits_type::length(__s)); </span>
<span class="lineNum"> 1925</span>              :       } </span>
<span class="lineNum"> 1926</span>              :  </span>
<span class="lineNum"> 1927</span>              :       &#047;** </span>
<span class="lineNum"> 1928</span>              :        *  @brief  Find last position of a character. </span>
<span class="lineNum"> 1929</span>              :        *  @param __c  Character to locate. </span>
<span class="lineNum"> 1930</span>              :        *  @param __pos  Index of character to search back from (default end). </span>
<span class="lineNum"> 1931</span>              :        *  @return  Index of last occurrence. </span>
<span class="lineNum"> 1932</span>              :        * </span>
<span class="lineNum"> 1933</span>              :        *  Starting from @a __pos, searches backward for @a __c within </span>
<span class="lineNum"> 1934</span>              :        *  this string.  If found, returns the index where it was </span>
<span class="lineNum"> 1935</span>              :        *  found.  If not found, returns npos. </span>
<span class="lineNum"> 1936</span>              :       *&#047; </span>
<span class="lineNum"> 1937</span>              :       size_type </span>
<span class="lineNum"> 1938</span>              :       rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT; </span>
<span class="lineNum"> 1939</span>              :  </span>
<span class="lineNum"> 1940</span>              :       &#047;** </span>
<span class="lineNum"> 1941</span>              :        *  @brief  Find position of a character of string. </span>
<span class="lineNum"> 1942</span>              :        *  @param __str  String containing characters to locate. </span>
<span class="lineNum"> 1943</span>              :        *  @param __pos  Index of character to search from (default 0). </span>
<span class="lineNum"> 1944</span>              :        *  @return  Index of first occurrence. </span>
<span class="lineNum"> 1945</span>              :        * </span>
<span class="lineNum"> 1946</span>              :        *  Starting from @a __pos, searches forward for one of the </span>
<span class="lineNum"> 1947</span>              :        *  characters of @a __str within this string.  If found, </span>
<span class="lineNum"> 1948</span>              :        *  returns the index where it was found.  If not found, returns </span>
<span class="lineNum"> 1949</span>              :        *  npos. </span>
<span class="lineNum"> 1950</span>              :       *&#047; </span>
<span class="lineNum"> 1951</span>              :       size_type </span>
<span class="lineNum"> 1952</span>              :       find_first_of(const basic_string&amp; __str, size_type __pos = 0) const </span>
<span class="lineNum"> 1953</span>              : 	_GLIBCXX_NOEXCEPT </span>
<span class="lineNum"> 1954</span>              :       { return this-&gt;find_first_of(__str.data(), __pos, __str.size()); } </span>
<span class="lineNum"> 1955</span>              :  </span>
<span class="lineNum"> 1956</span>              :       &#047;** </span>
<span class="lineNum"> 1957</span>              :        *  @brief  Find position of a character of C substring. </span>
<span class="lineNum"> 1958</span>              :        *  @param __s  String containing characters to locate. </span>
<span class="lineNum"> 1959</span>              :        *  @param __pos  Index of character to search from. </span>
<span class="lineNum"> 1960</span>              :        *  @param __n  Number of characters from s to search for. </span>
<span class="lineNum"> 1961</span>              :        *  @return  Index of first occurrence. </span>
<span class="lineNum"> 1962</span>              :        * </span>
<span class="lineNum"> 1963</span>              :        *  Starting from @a __pos, searches forward for one of the </span>
<span class="lineNum"> 1964</span>              :        *  first @a __n characters of @a __s within this string.  If </span>
<span class="lineNum"> 1965</span>              :        *  found, returns the index where it was found.  If not found, </span>
<span class="lineNum"> 1966</span>              :        *  returns npos. </span>
<span class="lineNum"> 1967</span>              :       *&#047; </span>
<span class="lineNum"> 1968</span>              :       size_type </span>
<span class="lineNum"> 1969</span>              :       find_first_of(const _CharT* __s, size_type __pos, size_type __n) const; </span>
<span class="lineNum"> 1970</span>              :  </span>
<span class="lineNum"> 1971</span>              :       &#047;** </span>
<span class="lineNum"> 1972</span>              :        *  @brief  Find position of a character of C string. </span>
<span class="lineNum"> 1973</span>              :        *  @param __s  String containing characters to locate. </span>
<span class="lineNum"> 1974</span>              :        *  @param __pos  Index of character to search from (default 0). </span>
<span class="lineNum"> 1975</span>              :        *  @return  Index of first occurrence. </span>
<span class="lineNum"> 1976</span>              :        * </span>
<span class="lineNum"> 1977</span>              :        *  Starting from @a __pos, searches forward for one of the </span>
<span class="lineNum"> 1978</span>              :        *  characters of @a __s within this string.  If found, returns </span>
<span class="lineNum"> 1979</span>              :        *  the index where it was found.  If not found, returns npos. </span>
<span class="lineNum"> 1980</span>              :       *&#047; </span>
<span class="lineNum"> 1981</span>              :       size_type </span>
<span class="lineNum"> 1982</span>              :       find_first_of(const _CharT* __s, size_type __pos = 0) const </span>
<span class="lineNum"> 1983</span>              :       { </span>
<span class="lineNum"> 1984</span>              : 	__glibcxx_requires_string(__s); </span>
<span class="lineNum"> 1985</span>              : 	return this-&gt;find_first_of(__s, __pos, traits_type::length(__s)); </span>
<span class="lineNum"> 1986</span>              :       } </span>
<span class="lineNum"> 1987</span>              :  </span>
<span class="lineNum"> 1988</span>              :       &#047;** </span>
<span class="lineNum"> 1989</span>              :        *  @brief  Find position of a character. </span>
<span class="lineNum"> 1990</span>              :        *  @param __c  Character to locate. </span>
<span class="lineNum"> 1991</span>              :        *  @param __pos  Index of character to search from (default 0). </span>
<span class="lineNum"> 1992</span>              :        *  @return  Index of first occurrence. </span>
<span class="lineNum"> 1993</span>              :        * </span>
<span class="lineNum"> 1994</span>              :        *  Starting from @a __pos, searches forward for the character </span>
<span class="lineNum"> 1995</span>              :        *  @a __c within this string.  If found, returns the index </span>
<span class="lineNum"> 1996</span>              :        *  where it was found.  If not found, returns npos. </span>
<span class="lineNum"> 1997</span>              :        * </span>
<span class="lineNum"> 1998</span>              :        *  Note: equivalent to find(__c, __pos). </span>
<span class="lineNum"> 1999</span>              :       *&#047; </span>
<span class="lineNum"> 2000</span>              :       size_type </span>
<span class="lineNum"> 2001</span>              :       find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum"> 2002</span>              :       { return this-&gt;find(__c, __pos); } </span>
<span class="lineNum"> 2003</span>              :  </span>
<span class="lineNum"> 2004</span>              :       &#047;** </span>
<span class="lineNum"> 2005</span>              :        *  @brief  Find last position of a character of string. </span>
<span class="lineNum"> 2006</span>              :        *  @param __str  String containing characters to locate. </span>
<span class="lineNum"> 2007</span>              :        *  @param __pos  Index of character to search back from (default end). </span>
<span class="lineNum"> 2008</span>              :        *  @return  Index of last occurrence. </span>
<span class="lineNum"> 2009</span>              :        * </span>
<span class="lineNum"> 2010</span>              :        *  Starting from @a __pos, searches backward for one of the </span>
<span class="lineNum"> 2011</span>              :        *  characters of @a __str within this string.  If found, </span>
<span class="lineNum"> 2012</span>              :        *  returns the index where it was found.  If not found, returns </span>
<span class="lineNum"> 2013</span>              :        *  npos. </span>
<span class="lineNum"> 2014</span>              :       *&#047; </span>
<span class="lineNum"> 2015</span>              :       size_type </span>
<span class="lineNum"> 2016</span>              :       find_last_of(const basic_string&amp; __str, size_type __pos = npos) const </span>
<span class="lineNum"> 2017</span>              : 	_GLIBCXX_NOEXCEPT </span>
<span class="lineNum"> 2018</span>              :       { return this-&gt;find_last_of(__str.data(), __pos, __str.size()); } </span>
<span class="lineNum"> 2019</span>              :  </span>
<span class="lineNum"> 2020</span>              :       &#047;** </span>
<span class="lineNum"> 2021</span>              :        *  @brief  Find last position of a character of C substring. </span>
<span class="lineNum"> 2022</span>              :        *  @param __s  C string containing characters to locate. </span>
<span class="lineNum"> 2023</span>              :        *  @param __pos  Index of character to search back from. </span>
<span class="lineNum"> 2024</span>              :        *  @param __n  Number of characters from s to search for. </span>
<span class="lineNum"> 2025</span>              :        *  @return  Index of last occurrence. </span>
<span class="lineNum"> 2026</span>              :        * </span>
<span class="lineNum"> 2027</span>              :        *  Starting from @a __pos, searches backward for one of the </span>
<span class="lineNum"> 2028</span>              :        *  first @a __n characters of @a __s within this string.  If </span>
<span class="lineNum"> 2029</span>              :        *  found, returns the index where it was found.  If not found, </span>
<span class="lineNum"> 2030</span>              :        *  returns npos. </span>
<span class="lineNum"> 2031</span>              :       *&#047; </span>
<span class="lineNum"> 2032</span>              :       size_type </span>
<span class="lineNum"> 2033</span>              :       find_last_of(const _CharT* __s, size_type __pos, size_type __n) const; </span>
<span class="lineNum"> 2034</span>              :  </span>
<span class="lineNum"> 2035</span>              :       &#047;** </span>
<span class="lineNum"> 2036</span>              :        *  @brief  Find last position of a character of C string. </span>
<span class="lineNum"> 2037</span>              :        *  @param __s  C string containing characters to locate. </span>
<span class="lineNum"> 2038</span>              :        *  @param __pos  Index of character to search back from (default end). </span>
<span class="lineNum"> 2039</span>              :        *  @return  Index of last occurrence. </span>
<span class="lineNum"> 2040</span>              :        * </span>
<span class="lineNum"> 2041</span>              :        *  Starting from @a __pos, searches backward for one of the </span>
<span class="lineNum"> 2042</span>              :        *  characters of @a __s within this string.  If found, returns </span>
<span class="lineNum"> 2043</span>              :        *  the index where it was found.  If not found, returns npos. </span>
<span class="lineNum"> 2044</span>              :       *&#047; </span>
<span class="lineNum"> 2045</span>              :       size_type </span>
<span class="lineNum"> 2046</span>              :       find_last_of(const _CharT* __s, size_type __pos = npos) const </span>
<span class="lineNum"> 2047</span>              :       { </span>
<span class="lineNum"> 2048</span>              : 	__glibcxx_requires_string(__s); </span>
<span class="lineNum"> 2049</span>              : 	return this-&gt;find_last_of(__s, __pos, traits_type::length(__s)); </span>
<span class="lineNum"> 2050</span>              :       } </span>
<span class="lineNum"> 2051</span>              :  </span>
<span class="lineNum"> 2052</span>              :       &#047;** </span>
<span class="lineNum"> 2053</span>              :        *  @brief  Find last position of a character. </span>
<span class="lineNum"> 2054</span>              :        *  @param __c  Character to locate. </span>
<span class="lineNum"> 2055</span>              :        *  @param __pos  Index of character to search back from (default end). </span>
<span class="lineNum"> 2056</span>              :        *  @return  Index of last occurrence. </span>
<span class="lineNum"> 2057</span>              :        * </span>
<span class="lineNum"> 2058</span>              :        *  Starting from @a __pos, searches backward for @a __c within </span>
<span class="lineNum"> 2059</span>              :        *  this string.  If found, returns the index where it was </span>
<span class="lineNum"> 2060</span>              :        *  found.  If not found, returns npos. </span>
<span class="lineNum"> 2061</span>              :        * </span>
<span class="lineNum"> 2062</span>              :        *  Note: equivalent to rfind(__c, __pos). </span>
<span class="lineNum"> 2063</span>              :       *&#047; </span>
<span class="lineNum"> 2064</span>              :       size_type </span>
<span class="lineNum"> 2065</span>              :       find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum"> 2066</span>              :       { return this-&gt;rfind(__c, __pos); } </span>
<span class="lineNum"> 2067</span>              :  </span>
<span class="lineNum"> 2068</span>              :       &#047;** </span>
<span class="lineNum"> 2069</span>              :        *  @brief  Find position of a character not in string. </span>
<span class="lineNum"> 2070</span>              :        *  @param __str  String containing characters to avoid. </span>
<span class="lineNum"> 2071</span>              :        *  @param __pos  Index of character to search from (default 0). </span>
<span class="lineNum"> 2072</span>              :        *  @return  Index of first occurrence. </span>
<span class="lineNum"> 2073</span>              :        * </span>
<span class="lineNum"> 2074</span>              :        *  Starting from @a __pos, searches forward for a character not contained </span>
<span class="lineNum"> 2075</span>              :        *  in @a __str within this string.  If found, returns the index where it </span>
<span class="lineNum"> 2076</span>              :        *  was found.  If not found, returns npos. </span>
<span class="lineNum"> 2077</span>              :       *&#047; </span>
<span class="lineNum"> 2078</span>              :       size_type </span>
<span class="lineNum"> 2079</span>              :       find_first_not_of(const basic_string&amp; __str, size_type __pos = 0) const </span>
<span class="lineNum"> 2080</span>              : 	_GLIBCXX_NOEXCEPT </span>
<span class="lineNum"> 2081</span>              :       { return this-&gt;find_first_not_of(__str.data(), __pos, __str.size()); } </span>
<span class="lineNum"> 2082</span>              :  </span>
<span class="lineNum"> 2083</span>              :       &#047;** </span>
<span class="lineNum"> 2084</span>              :        *  @brief  Find position of a character not in C substring. </span>
<span class="lineNum"> 2085</span>              :        *  @param __s  C string containing characters to avoid. </span>
<span class="lineNum"> 2086</span>              :        *  @param __pos  Index of character to search from. </span>
<span class="lineNum"> 2087</span>              :        *  @param __n  Number of characters from __s to consider. </span>
<span class="lineNum"> 2088</span>              :        *  @return  Index of first occurrence. </span>
<span class="lineNum"> 2089</span>              :        * </span>
<span class="lineNum"> 2090</span>              :        *  Starting from @a __pos, searches forward for a character not </span>
<span class="lineNum"> 2091</span>              :        *  contained in the first @a __n characters of @a __s within </span>
<span class="lineNum"> 2092</span>              :        *  this string.  If found, returns the index where it was </span>
<span class="lineNum"> 2093</span>              :        *  found.  If not found, returns npos. </span>
<span class="lineNum"> 2094</span>              :       *&#047; </span>
<span class="lineNum"> 2095</span>              :       size_type </span>
<span class="lineNum"> 2096</span>              :       find_first_not_of(const _CharT* __s, size_type __pos, </span>
<span class="lineNum"> 2097</span>              : 			size_type __n) const; </span>
<span class="lineNum"> 2098</span>              :  </span>
<span class="lineNum"> 2099</span>              :       &#047;** </span>
<span class="lineNum"> 2100</span>              :        *  @brief  Find position of a character not in C string. </span>
<span class="lineNum"> 2101</span>              :        *  @param __s  C string containing characters to avoid. </span>
<span class="lineNum"> 2102</span>              :        *  @param __pos  Index of character to search from (default 0). </span>
<span class="lineNum"> 2103</span>              :        *  @return  Index of first occurrence. </span>
<span class="lineNum"> 2104</span>              :        * </span>
<span class="lineNum"> 2105</span>              :        *  Starting from @a __pos, searches forward for a character not </span>
<span class="lineNum"> 2106</span>              :        *  contained in @a __s within this string.  If found, returns </span>
<span class="lineNum"> 2107</span>              :        *  the index where it was found.  If not found, returns npos. </span>
<span class="lineNum"> 2108</span>              :       *&#047; </span>
<span class="lineNum"> 2109</span>              :       size_type </span>
<span class="lineNum"> 2110</span>              :       find_first_not_of(const _CharT* __s, size_type __pos = 0) const </span>
<span class="lineNum"> 2111</span>              :       { </span>
<span class="lineNum"> 2112</span>              : 	__glibcxx_requires_string(__s); </span>
<span class="lineNum"> 2113</span>              : 	return this-&gt;find_first_not_of(__s, __pos, traits_type::length(__s)); </span>
<span class="lineNum"> 2114</span>              :       } </span>
<span class="lineNum"> 2115</span>              :  </span>
<span class="lineNum"> 2116</span>              :       &#047;** </span>
<span class="lineNum"> 2117</span>              :        *  @brief  Find position of a different character. </span>
<span class="lineNum"> 2118</span>              :        *  @param __c  Character to avoid. </span>
<span class="lineNum"> 2119</span>              :        *  @param __pos  Index of character to search from (default 0). </span>
<span class="lineNum"> 2120</span>              :        *  @return  Index of first occurrence. </span>
<span class="lineNum"> 2121</span>              :        * </span>
<span class="lineNum"> 2122</span>              :        *  Starting from @a __pos, searches forward for a character </span>
<span class="lineNum"> 2123</span>              :        *  other than @a __c within this string.  If found, returns the </span>
<span class="lineNum"> 2124</span>              :        *  index where it was found.  If not found, returns npos. </span>
<span class="lineNum"> 2125</span>              :       *&#047; </span>
<span class="lineNum"> 2126</span>              :       size_type </span>
<span class="lineNum"> 2127</span>              :       find_first_not_of(_CharT __c, size_type __pos = 0) const </span>
<span class="lineNum"> 2128</span>              : 	_GLIBCXX_NOEXCEPT; </span>
<span class="lineNum"> 2129</span>              :  </span>
<span class="lineNum"> 2130</span>              :       &#047;** </span>
<span class="lineNum"> 2131</span>              :        *  @brief  Find last position of a character not in string. </span>
<span class="lineNum"> 2132</span>              :        *  @param __str  String containing characters to avoid. </span>
<span class="lineNum"> 2133</span>              :        *  @param __pos  Index of character to search back from (default end). </span>
<span class="lineNum"> 2134</span>              :        *  @return  Index of last occurrence. </span>
<span class="lineNum"> 2135</span>              :        * </span>
<span class="lineNum"> 2136</span>              :        *  Starting from @a __pos, searches backward for a character </span>
<span class="lineNum"> 2137</span>              :        *  not contained in @a __str within this string.  If found, </span>
<span class="lineNum"> 2138</span>              :        *  returns the index where it was found.  If not found, returns </span>
<span class="lineNum"> 2139</span>              :        *  npos. </span>
<span class="lineNum"> 2140</span>              :       *&#047; </span>
<span class="lineNum"> 2141</span>              :       size_type </span>
<span class="lineNum"> 2142</span>              :       find_last_not_of(const basic_string&amp; __str, size_type __pos = npos) const </span>
<span class="lineNum"> 2143</span>              : 	_GLIBCXX_NOEXCEPT </span>
<span class="lineNum"> 2144</span>              :       { return this-&gt;find_last_not_of(__str.data(), __pos, __str.size()); } </span>
<span class="lineNum"> 2145</span>              :  </span>
<span class="lineNum"> 2146</span>              :       &#047;** </span>
<span class="lineNum"> 2147</span>              :        *  @brief  Find last position of a character not in C substring. </span>
<span class="lineNum"> 2148</span>              :        *  @param __s  C string containing characters to avoid. </span>
<span class="lineNum"> 2149</span>              :        *  @param __pos  Index of character to search back from. </span>
<span class="lineNum"> 2150</span>              :        *  @param __n  Number of characters from s to consider. </span>
<span class="lineNum"> 2151</span>              :        *  @return  Index of last occurrence. </span>
<span class="lineNum"> 2152</span>              :        * </span>
<span class="lineNum"> 2153</span>              :        *  Starting from @a __pos, searches backward for a character not </span>
<span class="lineNum"> 2154</span>              :        *  contained in the first @a __n characters of @a __s within this string. </span>
<span class="lineNum"> 2155</span>              :        *  If found, returns the index where it was found.  If not found, </span>
<span class="lineNum"> 2156</span>              :        *  returns npos. </span>
<span class="lineNum"> 2157</span>              :       *&#047; </span>
<span class="lineNum"> 2158</span>              :       size_type </span>
<span class="lineNum"> 2159</span>              :       find_last_not_of(const _CharT* __s, size_type __pos, </span>
<span class="lineNum"> 2160</span>              : 		       size_type __n) const; </span>
<span class="lineNum"> 2161</span>              :       &#047;** </span>
<span class="lineNum"> 2162</span>              :        *  @brief  Find last position of a character not in C string. </span>
<span class="lineNum"> 2163</span>              :        *  @param __s  C string containing characters to avoid. </span>
<span class="lineNum"> 2164</span>              :        *  @param __pos  Index of character to search back from (default end). </span>
<span class="lineNum"> 2165</span>              :        *  @return  Index of last occurrence. </span>
<span class="lineNum"> 2166</span>              :        * </span>
<span class="lineNum"> 2167</span>              :        *  Starting from @a __pos, searches backward for a character </span>
<span class="lineNum"> 2168</span>              :        *  not contained in @a __s within this string.  If found, </span>
<span class="lineNum"> 2169</span>              :        *  returns the index where it was found.  If not found, returns </span>
<span class="lineNum"> 2170</span>              :        *  npos. </span>
<span class="lineNum"> 2171</span>              :       *&#047; </span>
<span class="lineNum"> 2172</span>              :       size_type </span>
<span class="lineNum"> 2173</span>              :       find_last_not_of(const _CharT* __s, size_type __pos = npos) const </span>
<span class="lineNum"> 2174</span>              :       { </span>
<span class="lineNum"> 2175</span>              : 	__glibcxx_requires_string(__s); </span>
<span class="lineNum"> 2176</span>              : 	return this-&gt;find_last_not_of(__s, __pos, traits_type::length(__s)); </span>
<span class="lineNum"> 2177</span>              :       } </span>
<span class="lineNum"> 2178</span>              :  </span>
<span class="lineNum"> 2179</span>              :       &#047;** </span>
<span class="lineNum"> 2180</span>              :        *  @brief  Find last position of a different character. </span>
<span class="lineNum"> 2181</span>              :        *  @param __c  Character to avoid. </span>
<span class="lineNum"> 2182</span>              :        *  @param __pos  Index of character to search back from (default end). </span>
<span class="lineNum"> 2183</span>              :        *  @return  Index of last occurrence. </span>
<span class="lineNum"> 2184</span>              :        * </span>
<span class="lineNum"> 2185</span>              :        *  Starting from @a __pos, searches backward for a character other than </span>
<span class="lineNum"> 2186</span>              :        *  @a __c within this string.  If found, returns the index where it was </span>
<span class="lineNum"> 2187</span>              :        *  found.  If not found, returns npos. </span>
<span class="lineNum"> 2188</span>              :       *&#047; </span>
<span class="lineNum"> 2189</span>              :       size_type </span>
<span class="lineNum"> 2190</span>              :       find_last_not_of(_CharT __c, size_type __pos = npos) const </span>
<span class="lineNum"> 2191</span>              : 	_GLIBCXX_NOEXCEPT; </span>
<span class="lineNum"> 2192</span>              :  </span>
<span class="lineNum"> 2193</span>              :       &#047;** </span>
<span class="lineNum"> 2194</span>              :        *  @brief  Get a substring. </span>
<span class="lineNum"> 2195</span>              :        *  @param __pos  Index of first character (default 0). </span>
<span class="lineNum"> 2196</span>              :        *  @param __n  Number of characters in substring (default remainder). </span>
<span class="lineNum"> 2197</span>              :        *  @return  The new string. </span>
<span class="lineNum"> 2198</span>              :        *  @throw  std::out_of_range  If __pos &gt; size(). </span>
<span class="lineNum"> 2199</span>              :        * </span>
<span class="lineNum"> 2200</span>              :        *  Construct and return a new string using the @a __n </span>
<span class="lineNum"> 2201</span>              :        *  characters starting at @a __pos.  If the string is too </span>
<span class="lineNum"> 2202</span>              :        *  short, use the remainder of the characters.  If @a __pos is </span>
<span class="lineNum"> 2203</span>              :        *  beyond the end of the string, out_of_range is thrown. </span>
<span class="lineNum"> 2204</span>              :       *&#047; </span>
<span class="lineNum"> 2205</span>              :       basic_string </span>
<span class="lineNum"> 2206</span>              :       substr(size_type __pos = 0, size_type __n = npos) const </span>
<span class="lineNum"> 2207</span>              :       { return basic_string(*this, </span>
<span class="lineNum"> 2208</span>              : 			    _M_check(__pos, &quot;basic_string::substr&quot;), __n); } </span>
<span class="lineNum"> 2209</span>              :  </span>
<span class="lineNum"> 2210</span>              :       &#047;** </span>
<span class="lineNum"> 2211</span>              :        *  @brief  Compare to a string. </span>
<span class="lineNum"> 2212</span>              :        *  @param __str  String to compare against. </span>
<span class="lineNum"> 2213</span>              :        *  @return  Integer &lt; 0, 0, or &gt; 0. </span>
<span class="lineNum"> 2214</span>              :        * </span>
<span class="lineNum"> 2215</span>              :        *  Returns an integer &lt; 0 if this string is ordered before @a </span>
<span class="lineNum"> 2216</span>              :        *  __str, 0 if their values are equivalent, or &gt; 0 if this </span>
<span class="lineNum"> 2217</span>              :        *  string is ordered after @a __str.  Determines the effective </span>
<span class="lineNum"> 2218</span>              :        *  length rlen of the strings to compare as the smallest of </span>
<span class="lineNum"> 2219</span>              :        *  size() and str.size().  The function then compares the two </span>
<span class="lineNum"> 2220</span>              :        *  strings by calling traits::compare(data(), str.data(),rlen). </span>
<span class="lineNum"> 2221</span>              :        *  If the result of the comparison is nonzero returns it, </span>
<span class="lineNum"> 2222</span>              :        *  otherwise the shorter one is ordered first. </span>
<span class="lineNum"> 2223</span>              :       *&#047; </span>
<span class="lineNum"> 2224</span>              :       int </span>
<span class="lineNum"> 2225</span>              :       compare(const basic_string&amp; __str) const </span>
<span class="lineNum"> 2226</span>              :       { </span>
<span class="lineNum"> 2227</span>              : 	const size_type __size = this-&gt;size(); </span>
<span class="lineNum"> 2228</span>              : 	const size_type __osize = __str.size(); </span>
<span class="lineNum"> 2229</span>              : 	const size_type __len = std::min(__size, __osize); </span>
<span class="lineNum"> 2230</span>              :  </span>
<span class="lineNum"> 2231</span>              : 	int __r = traits_type::compare(_M_data(), __str.data(), __len); </span>
<span class="lineNum"> 2232</span>              : 	if (!__r) </span>
<span class="lineNum"> 2233</span>              : 	  __r = _S_compare(__size, __osize); </span>
<span class="lineNum"> 2234</span>              : 	return __r; </span>
<span class="lineNum"> 2235</span>              :       } </span>
<span class="lineNum"> 2236</span>              :  </span>
<span class="lineNum"> 2237</span>              :       &#047;** </span>
<span class="lineNum"> 2238</span>              :        *  @brief  Compare substring to a string. </span>
<span class="lineNum"> 2239</span>              :        *  @param __pos  Index of first character of substring. </span>
<span class="lineNum"> 2240</span>              :        *  @param __n  Number of characters in substring. </span>
<span class="lineNum"> 2241</span>              :        *  @param __str  String to compare against. </span>
<span class="lineNum"> 2242</span>              :        *  @return  Integer &lt; 0, 0, or &gt; 0. </span>
<span class="lineNum"> 2243</span>              :        * </span>
<span class="lineNum"> 2244</span>              :        *  Form the substring of this string from the @a __n characters </span>
<span class="lineNum"> 2245</span>              :        *  starting at @a __pos.  Returns an integer &lt; 0 if the </span>
<span class="lineNum"> 2246</span>              :        *  substring is ordered before @a __str, 0 if their values are </span>
<span class="lineNum"> 2247</span>              :        *  equivalent, or &gt; 0 if the substring is ordered after @a </span>
<span class="lineNum"> 2248</span>              :        *  __str.  Determines the effective length rlen of the strings </span>
<span class="lineNum"> 2249</span>              :        *  to compare as the smallest of the length of the substring </span>
<span class="lineNum"> 2250</span>              :        *  and @a __str.size().  The function then compares the two </span>
<span class="lineNum"> 2251</span>              :        *  strings by calling </span>
<span class="lineNum"> 2252</span>              :        *  traits::compare(substring.data(),str.data(),rlen).  If the </span>
<span class="lineNum"> 2253</span>              :        *  result of the comparison is nonzero returns it, otherwise </span>
<span class="lineNum"> 2254</span>              :        *  the shorter one is ordered first. </span>
<span class="lineNum"> 2255</span>              :       *&#047; </span>
<span class="lineNum"> 2256</span>              :       int </span>
<span class="lineNum"> 2257</span>              :       compare(size_type __pos, size_type __n, const basic_string&amp; __str) const; </span>
<span class="lineNum"> 2258</span>              :  </span>
<span class="lineNum"> 2259</span>              :       &#047;** </span>
<span class="lineNum"> 2260</span>              :        *  @brief  Compare substring to a substring. </span>
<span class="lineNum"> 2261</span>              :        *  @param __pos1  Index of first character of substring. </span>
<span class="lineNum"> 2262</span>              :        *  @param __n1  Number of characters in substring. </span>
<span class="lineNum"> 2263</span>              :        *  @param __str  String to compare against. </span>
<span class="lineNum"> 2264</span>              :        *  @param __pos2  Index of first character of substring of str. </span>
<span class="lineNum"> 2265</span>              :        *  @param __n2  Number of characters in substring of str. </span>
<span class="lineNum"> 2266</span>              :        *  @return  Integer &lt; 0, 0, or &gt; 0. </span>
<span class="lineNum"> 2267</span>              :        * </span>
<span class="lineNum"> 2268</span>              :        *  Form the substring of this string from the @a __n1 </span>
<span class="lineNum"> 2269</span>              :        *  characters starting at @a __pos1.  Form the substring of @a </span>
<span class="lineNum"> 2270</span>              :        *  __str from the @a __n2 characters starting at @a __pos2. </span>
<span class="lineNum"> 2271</span>              :        *  Returns an integer &lt; 0 if this substring is ordered before </span>
<span class="lineNum"> 2272</span>              :        *  the substring of @a __str, 0 if their values are equivalent, </span>
<span class="lineNum"> 2273</span>              :        *  or &gt; 0 if this substring is ordered after the substring of </span>
<span class="lineNum"> 2274</span>              :        *  @a __str.  Determines the effective length rlen of the </span>
<span class="lineNum"> 2275</span>              :        *  strings to compare as the smallest of the lengths of the </span>
<span class="lineNum"> 2276</span>              :        *  substrings.  The function then compares the two strings by </span>
<span class="lineNum"> 2277</span>              :        *  calling </span>
<span class="lineNum"> 2278</span>              :        *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen). </span>
<span class="lineNum"> 2279</span>              :        *  If the result of the comparison is nonzero returns it, </span>
<span class="lineNum"> 2280</span>              :        *  otherwise the shorter one is ordered first. </span>
<span class="lineNum"> 2281</span>              :       *&#047; </span>
<span class="lineNum"> 2282</span>              :       int </span>
<span class="lineNum"> 2283</span>              :       compare(size_type __pos1, size_type __n1, const basic_string&amp; __str, </span>
<span class="lineNum"> 2284</span>              : 	      size_type __pos2, size_type __n2) const; </span>
<span class="lineNum"> 2285</span>              :  </span>
<span class="lineNum"> 2286</span>              :       &#047;** </span>
<span class="lineNum"> 2287</span>              :        *  @brief  Compare to a C string. </span>
<span class="lineNum"> 2288</span>              :        *  @param __s  C string to compare against. </span>
<span class="lineNum"> 2289</span>              :        *  @return  Integer &lt; 0, 0, or &gt; 0. </span>
<span class="lineNum"> 2290</span>              :        * </span>
<span class="lineNum"> 2291</span>              :        *  Returns an integer &lt; 0 if this string is ordered before @a __s, 0 if </span>
<span class="lineNum"> 2292</span>              :        *  their values are equivalent, or &gt; 0 if this string is ordered after </span>
<span class="lineNum"> 2293</span>              :        *  @a __s.  Determines the effective length rlen of the strings to </span>
<span class="lineNum"> 2294</span>              :        *  compare as the smallest of size() and the length of a string </span>
<span class="lineNum"> 2295</span>              :        *  constructed from @a __s.  The function then compares the two strings </span>
<span class="lineNum"> 2296</span>              :        *  by calling traits::compare(data(),s,rlen).  If the result of the </span>
<span class="lineNum"> 2297</span>              :        *  comparison is nonzero returns it, otherwise the shorter one is </span>
<span class="lineNum"> 2298</span>              :        *  ordered first. </span>
<span class="lineNum"> 2299</span>              :       *&#047; </span>
<span class="lineNum"> 2300</span>              :       int </span>
<span class="lineNum"> 2301</span>              :       compare(const _CharT* __s) const; </span>
<span class="lineNum"> 2302</span>              :  </span>
<span class="lineNum"> 2303</span>              :       &#047;&#047; _GLIBCXX_RESOLVE_LIB_DEFECTS </span>
<span class="lineNum"> 2304</span>              :       &#047;&#047; 5 String::compare specification questionable </span>
<span class="lineNum"> 2305</span>              :       &#047;** </span>
<span class="lineNum"> 2306</span>              :        *  @brief  Compare substring to a C string. </span>
<span class="lineNum"> 2307</span>              :        *  @param __pos  Index of first character of substring. </span>
<span class="lineNum"> 2308</span>              :        *  @param __n1  Number of characters in substring. </span>
<span class="lineNum"> 2309</span>              :        *  @param __s  C string to compare against. </span>
<span class="lineNum"> 2310</span>              :        *  @return  Integer &lt; 0, 0, or &gt; 0. </span>
<span class="lineNum"> 2311</span>              :        * </span>
<span class="lineNum"> 2312</span>              :        *  Form the substring of this string from the @a __n1 </span>
<span class="lineNum"> 2313</span>              :        *  characters starting at @a pos.  Returns an integer &lt; 0 if </span>
<span class="lineNum"> 2314</span>              :        *  the substring is ordered before @a __s, 0 if their values </span>
<span class="lineNum"> 2315</span>              :        *  are equivalent, or &gt; 0 if the substring is ordered after @a </span>
<span class="lineNum"> 2316</span>              :        *  __s.  Determines the effective length rlen of the strings to </span>
<span class="lineNum"> 2317</span>              :        *  compare as the smallest of the length of the substring and </span>
<span class="lineNum"> 2318</span>              :        *  the length of a string constructed from @a __s.  The </span>
<span class="lineNum"> 2319</span>              :        *  function then compares the two string by calling </span>
<span class="lineNum"> 2320</span>              :        *  traits::compare(substring.data(),__s,rlen).  If the result of </span>
<span class="lineNum"> 2321</span>              :        *  the comparison is nonzero returns it, otherwise the shorter </span>
<span class="lineNum"> 2322</span>              :        *  one is ordered first. </span>
<span class="lineNum"> 2323</span>              :       *&#047; </span>
<span class="lineNum"> 2324</span>              :       int </span>
<span class="lineNum"> 2325</span>              :       compare(size_type __pos, size_type __n1, const _CharT* __s) const; </span>
<span class="lineNum"> 2326</span>              :  </span>
<span class="lineNum"> 2327</span>              :       &#047;** </span>
<span class="lineNum"> 2328</span>              :        *  @brief  Compare substring against a character %array. </span>
<span class="lineNum"> 2329</span>              :        *  @param __pos  Index of first character of substring. </span>
<span class="lineNum"> 2330</span>              :        *  @param __n1  Number of characters in substring. </span>
<span class="lineNum"> 2331</span>              :        *  @param __s  character %array to compare against. </span>
<span class="lineNum"> 2332</span>              :        *  @param __n2  Number of characters of s. </span>
<span class="lineNum"> 2333</span>              :        *  @return  Integer &lt; 0, 0, or &gt; 0. </span>
<span class="lineNum"> 2334</span>              :        * </span>
<span class="lineNum"> 2335</span>              :        *  Form the substring of this string from the @a __n1 </span>
<span class="lineNum"> 2336</span>              :        *  characters starting at @a __pos.  Form a string from the </span>
<span class="lineNum"> 2337</span>              :        *  first @a __n2 characters of @a __s.  Returns an integer &lt; 0 </span>
<span class="lineNum"> 2338</span>              :        *  if this substring is ordered before the string from @a __s, </span>
<span class="lineNum"> 2339</span>              :        *  0 if their values are equivalent, or &gt; 0 if this substring </span>
<span class="lineNum"> 2340</span>              :        *  is ordered after the string from @a __s.  Determines the </span>
<span class="lineNum"> 2341</span>              :        *  effective length rlen of the strings to compare as the </span>
<span class="lineNum"> 2342</span>              :        *  smallest of the length of the substring and @a __n2.  The </span>
<span class="lineNum"> 2343</span>              :        *  function then compares the two strings by calling </span>
<span class="lineNum"> 2344</span>              :        *  traits::compare(substring.data(),s,rlen).  If the result of </span>
<span class="lineNum"> 2345</span>              :        *  the comparison is nonzero returns it, otherwise the shorter </span>
<span class="lineNum"> 2346</span>              :        *  one is ordered first. </span>
<span class="lineNum"> 2347</span>              :        * </span>
<span class="lineNum"> 2348</span>              :        *  NB: s must have at least n2 characters, &amp;apos;&#092;&#092;0&amp;apos; has </span>
<span class="lineNum"> 2349</span>              :        *  no special meaning. </span>
<span class="lineNum"> 2350</span>              :       *&#047; </span>
<span class="lineNum"> 2351</span>              :       int </span>
<span class="lineNum"> 2352</span>              :       compare(size_type __pos, size_type __n1, const _CharT* __s, </span>
<span class="lineNum"> 2353</span>              : 	      size_type __n2) const; </span>
<span class="lineNum"> 2354</span>              :   }; </span>
<span class="lineNum"> 2355</span>              :  </span>
<span class="lineNum"> 2356</span>              :   &#047;&#047; operator+ </span>
<span class="lineNum"> 2357</span>              :   &#047;** </span>
<span class="lineNum"> 2358</span>              :    *  @brief  Concatenate two strings. </span>
<span class="lineNum"> 2359</span>              :    *  @param __lhs  First string. </span>
<span class="lineNum"> 2360</span>              :    *  @param __rhs  Last string. </span>
<span class="lineNum"> 2361</span>              :    *  @return  New string with value of @a __lhs followed by @a __rhs. </span>
<span class="lineNum"> 2362</span>              :    *&#047; </span>
<span class="lineNum"> 2363</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2364</span>              :     basic_string&lt;_CharT, _Traits, _Alloc&gt; </span>
<span class="lineNum"> 2365</span><span class="lineCov">      1  /   1:     operator+(const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __lhs, </span>
<span class="lineNum"> 2366</span>              : 	      const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __rhs) </span>
<span class="lineNum"> 2367</span>              :     { </span>
<span class="lineNum"> 2368</span><span class="lineCov">      1  /   1:       basic_string&lt;_CharT, _Traits, _Alloc&gt; __str(__lhs); </span>
<span class="lineNum"> 2369</span><span class="lineCov">      1  /   1:       __str.append(__rhs); </span>
<span class="lineNum"> 2370</span><span class="lineCov">      1  /   1:       return __str; </span>
<span class="lineNum"> 2371</span><span class="lineCov">      2  /   2:     } </span>
<span class="lineNum"> 2372</span>              :  </span>
<span class="lineNum"> 2373</span>              :   &#047;** </span>
<span class="lineNum"> 2374</span>              :    *  @brief  Concatenate C string and string. </span>
<span class="lineNum"> 2375</span>              :    *  @param __lhs  First string. </span>
<span class="lineNum"> 2376</span>              :    *  @param __rhs  Last string. </span>
<span class="lineNum"> 2377</span>              :    *  @return  New string with value of @a __lhs followed by @a __rhs. </span>
<span class="lineNum"> 2378</span>              :    *&#047; </span>
<span class="lineNum"> 2379</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2380</span>              :     basic_string&lt;_CharT,_Traits,_Alloc&gt; </span>
<span class="lineNum"> 2381</span>              :     operator+(const _CharT* __lhs, </span>
<span class="lineNum"> 2382</span>              : 	      const basic_string&lt;_CharT,_Traits,_Alloc&gt;&amp; __rhs); </span>
<span class="lineNum"> 2383</span>              :  </span>
<span class="lineNum"> 2384</span>              :   &#047;** </span>
<span class="lineNum"> 2385</span>              :    *  @brief  Concatenate character and string. </span>
<span class="lineNum"> 2386</span>              :    *  @param __lhs  First string. </span>
<span class="lineNum"> 2387</span>              :    *  @param __rhs  Last string. </span>
<span class="lineNum"> 2388</span>              :    *  @return  New string with @a __lhs followed by @a __rhs. </span>
<span class="lineNum"> 2389</span>              :    *&#047; </span>
<span class="lineNum"> 2390</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2391</span>              :     basic_string&lt;_CharT,_Traits,_Alloc&gt; </span>
<span class="lineNum"> 2392</span>              :     operator+(_CharT __lhs, const basic_string&lt;_CharT,_Traits,_Alloc&gt;&amp; __rhs); </span>
<span class="lineNum"> 2393</span>              :  </span>
<span class="lineNum"> 2394</span>              :   &#047;** </span>
<span class="lineNum"> 2395</span>              :    *  @brief  Concatenate string and C string. </span>
<span class="lineNum"> 2396</span>              :    *  @param __lhs  First string. </span>
<span class="lineNum"> 2397</span>              :    *  @param __rhs  Last string. </span>
<span class="lineNum"> 2398</span>              :    *  @return  New string with @a __lhs followed by @a __rhs. </span>
<span class="lineNum"> 2399</span>              :    *&#047; </span>
<span class="lineNum"> 2400</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2401</span>              :     inline basic_string&lt;_CharT, _Traits, _Alloc&gt; </span>
<span class="lineNum"> 2402</span><span class="lineNoCov">      0  /   1:     operator+(const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __lhs, </span>
<span class="lineNum"> 2403</span>              : 	     const _CharT* __rhs) </span>
<span class="lineNum"> 2404</span>              :     { </span>
<span class="lineNum"> 2405</span><span class="lineCov">      1  /   1:       basic_string&lt;_CharT, _Traits, _Alloc&gt; __str(__lhs); </span>
<span class="lineNum"> 2406</span><span class="lineCov">      1  /   1:       __str.append(__rhs); </span>
<span class="lineNum"> 2407</span><span class="lineCov">      1  /   1:       return __str; </span>
<span class="lineNum"> 2408</span><span class="lineCov">      2  /   2:     } </span>
<span class="lineNum"> 2409</span>              :  </span>
<span class="lineNum"> 2410</span>              :   &#047;** </span>
<span class="lineNum"> 2411</span>              :    *  @brief  Concatenate string and character. </span>
<span class="lineNum"> 2412</span>              :    *  @param __lhs  First string. </span>
<span class="lineNum"> 2413</span>              :    *  @param __rhs  Last string. </span>
<span class="lineNum"> 2414</span>              :    *  @return  New string with @a __lhs followed by @a __rhs. </span>
<span class="lineNum"> 2415</span>              :    *&#047; </span>
<span class="lineNum"> 2416</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2417</span>              :     inline basic_string&lt;_CharT, _Traits, _Alloc&gt; </span>
<span class="lineNum"> 2418</span>              :     operator+(const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __lhs, _CharT __rhs) </span>
<span class="lineNum"> 2419</span>              :     { </span>
<span class="lineNum"> 2420</span>              :       typedef basic_string&lt;_CharT, _Traits, _Alloc&gt;	__string_type; </span>
<span class="lineNum"> 2421</span>              :       typedef typename __string_type::size_type		__size_type; </span>
<span class="lineNum"> 2422</span>              :       __string_type __str(__lhs); </span>
<span class="lineNum"> 2423</span>              :       __str.append(__size_type(1), __rhs); </span>
<span class="lineNum"> 2424</span>              :       return __str; </span>
<span class="lineNum"> 2425</span>              :     } </span>
<span class="lineNum"> 2426</span>              :  </span>
<span class="lineNum"> 2427</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 2428</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2429</span>              :     inline basic_string&lt;_CharT, _Traits, _Alloc&gt; </span>
<span class="lineNum"> 2430</span><span class="lineCov">      1  /   1:     operator+(basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp;&amp; __lhs, </span>
<span class="lineNum"> 2431</span>              : 	      const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __rhs) </span>
<span class="lineNum"> 2432</span><span class="linePartCov">      1  /   2:     { return std::move(__lhs.append(__rhs)); } </span>
<span class="lineNum"> 2433</span>              :  </span>
<span class="lineNum"> 2434</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2435</span>              :     inline basic_string&lt;_CharT, _Traits, _Alloc&gt; </span>
<span class="lineNum"> 2436</span><span class="lineNoCov">      0  /   1:     operator+(const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __lhs, </span>
<span class="lineNum"> 2437</span>              : 	      basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp;&amp; __rhs) </span>
<span class="lineNum"> 2438</span><span class="linePartCov">      1  /   2:     { return std::move(__rhs.insert(0, __lhs)); } </span>
<span class="lineNum"> 2439</span>              :  </span>
<span class="lineNum"> 2440</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2441</span>              :     inline basic_string&lt;_CharT, _Traits, _Alloc&gt; </span>
<span class="lineNum"> 2442</span><span class="lineCov">      1  /   1:     operator+(basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp;&amp; __lhs, </span>
<span class="lineNum"> 2443</span>              : 	      basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp;&amp; __rhs) </span>
<span class="lineNum"> 2444</span>              :     { </span>
<span class="lineNum"> 2445</span><span class="lineCov">      1  /   1:       const auto __size = __lhs.size() + __rhs.size(); </span>
<span class="lineNum"> 2446</span><span class="lineCov">      1  /   1:       const bool __cond = (__size &gt; __lhs.capacity() </span>
<span class="lineNum"> 2447</span><span class="lineCov">      1  /   1: 			   &amp;&amp; __size &lt;= __rhs.capacity()); </span>
<span class="lineNum"> 2448</span><span class="lineNoCov">      0  /   1:       return __cond ? std::move(__rhs.insert(0, __lhs)) </span>
<span class="lineNum"> 2449</span><span class="linePartCov">      1  /   2: 	            : std::move(__lhs.append(__rhs)); </span>
<span class="lineNum"> 2450</span><span class="linePartCov">      1  /   2:     } </span>
<span class="lineNum"> 2451</span>              :  </span>
<span class="lineNum"> 2452</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2453</span>              :     inline basic_string&lt;_CharT, _Traits, _Alloc&gt; </span>
<span class="lineNum"> 2454</span><span class="lineCov">      1  /   1:     operator+(const _CharT* __lhs, </span>
<span class="lineNum"> 2455</span>              : 	      basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp;&amp; __rhs) </span>
<span class="lineNum"> 2456</span><span class="linePartCov">      1  /   2:     { return std::move(__rhs.insert(0, __lhs)); } </span>
<span class="lineNum"> 2457</span>              :  </span>
<span class="lineNum"> 2458</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2459</span>              :     inline basic_string&lt;_CharT, _Traits, _Alloc&gt; </span>
<span class="lineNum"> 2460</span>              :     operator+(_CharT __lhs, </span>
<span class="lineNum"> 2461</span>              : 	      basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp;&amp; __rhs) </span>
<span class="lineNum"> 2462</span>              :     { return std::move(__rhs.insert(0, 1, __lhs)); } </span>
<span class="lineNum"> 2463</span>              :  </span>
<span class="lineNum"> 2464</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2465</span>              :     inline basic_string&lt;_CharT, _Traits, _Alloc&gt; </span>
<span class="lineNum"> 2466</span><span class="lineCov">      1  /   1:     operator+(basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp;&amp; __lhs, </span>
<span class="lineNum"> 2467</span>              : 	      const _CharT* __rhs) </span>
<span class="lineNum"> 2468</span><span class="linePartCov">      1  /   2:     { return std::move(__lhs.append(__rhs)); } </span>
<span class="lineNum"> 2469</span>              :  </span>
<span class="lineNum"> 2470</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2471</span>              :     inline basic_string&lt;_CharT, _Traits, _Alloc&gt; </span>
<span class="lineNum"> 2472</span>              :     operator+(basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp;&amp; __lhs, </span>
<span class="lineNum"> 2473</span>              : 	      _CharT __rhs) </span>
<span class="lineNum"> 2474</span>              :     { return std::move(__lhs.append(1, __rhs)); } </span>
<span class="lineNum"> 2475</span>              : #endif </span>
<span class="lineNum"> 2476</span>              :  </span>
<span class="lineNum"> 2477</span>              :   &#047;&#047; operator == </span>
<span class="lineNum"> 2478</span>              :   &#047;** </span>
<span class="lineNum"> 2479</span>              :    *  @brief  Test equivalence of two strings. </span>
<span class="lineNum"> 2480</span>              :    *  @param __lhs  First string. </span>
<span class="lineNum"> 2481</span>              :    *  @param __rhs  Second string. </span>
<span class="lineNum"> 2482</span>              :    *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise. </span>
<span class="lineNum"> 2483</span>              :    *&#047; </span>
<span class="lineNum"> 2484</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2485</span>              :     inline bool </span>
<span class="lineNum"> 2486</span>              :     operator==(const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __lhs, </span>
<span class="lineNum"> 2487</span>              : 	       const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __rhs) </span>
<span class="lineNum"> 2488</span>              :     { return __lhs.compare(__rhs) == 0; } </span>
<span class="lineNum"> 2489</span>              :  </span>
<span class="lineNum"> 2490</span>              :   template&lt;typename _CharT&gt; </span>
<span class="lineNum"> 2491</span>              :     inline </span>
<span class="lineNum"> 2492</span>              :     typename __gnu_cxx::__enable_if&lt;__is_char&lt;_CharT&gt;::__value, bool&gt;::__type </span>
<span class="lineNum"> 2493</span><span class="lineCov">      1  /   1:     operator==(const basic_string&lt;_CharT&gt;&amp; __lhs, </span>
<span class="lineNum"> 2494</span>              : 	       const basic_string&lt;_CharT&gt;&amp; __rhs) </span>
<span class="lineNum"> 2495</span><span class="lineCov">      1  /   1:     { return (__lhs.size() == __rhs.size() </span>
<span class="lineNum"> 2496</span>              : 	      &amp;&amp; !std::char_traits&lt;_CharT&gt;::compare(__lhs.data(), __rhs.data(), </span>
<span class="lineNum"> 2497</span><span class="lineCov">      1  /   1: 						    __lhs.size())); } </span>
<span class="lineNum"> 2498</span>              :  </span>
<span class="lineNum"> 2499</span>              :   &#047;** </span>
<span class="lineNum"> 2500</span>              :    *  @brief  Test equivalence of C string and string. </span>
<span class="lineNum"> 2501</span>              :    *  @param __lhs  C string. </span>
<span class="lineNum"> 2502</span>              :    *  @param __rhs  String. </span>
<span class="lineNum"> 2503</span>              :    *  @return  True if @a __rhs.compare(@a __lhs) == 0.  False otherwise. </span>
<span class="lineNum"> 2504</span>              :    *&#047; </span>
<span class="lineNum"> 2505</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2506</span>              :     inline bool </span>
<span class="lineNum"> 2507</span>              :     operator==(const _CharT* __lhs, </span>
<span class="lineNum"> 2508</span>              : 	       const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __rhs) </span>
<span class="lineNum"> 2509</span>              :     { return __rhs.compare(__lhs) == 0; } </span>
<span class="lineNum"> 2510</span>              :  </span>
<span class="lineNum"> 2511</span>              :   &#047;** </span>
<span class="lineNum"> 2512</span>              :    *  @brief  Test equivalence of string and C string. </span>
<span class="lineNum"> 2513</span>              :    *  @param __lhs  String. </span>
<span class="lineNum"> 2514</span>              :    *  @param __rhs  C string. </span>
<span class="lineNum"> 2515</span>              :    *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise. </span>
<span class="lineNum"> 2516</span>              :    *&#047; </span>
<span class="lineNum"> 2517</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2518</span>              :     inline bool </span>
<span class="lineNum"> 2519</span><span class="lineCov">      1  /   1:     operator==(const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __lhs, </span>
<span class="lineNum"> 2520</span>              : 	       const _CharT* __rhs) </span>
<span class="lineNum"> 2521</span><span class="lineCov">      2  /   2:     { return __lhs.compare(__rhs) == 0; } </span>
<span class="lineNum"> 2522</span>              :  </span>
<span class="lineNum"> 2523</span>              :   &#047;&#047; operator != </span>
<span class="lineNum"> 2524</span>              :   &#047;** </span>
<span class="lineNum"> 2525</span>              :    *  @brief  Test difference of two strings. </span>
<span class="lineNum"> 2526</span>              :    *  @param __lhs  First string. </span>
<span class="lineNum"> 2527</span>              :    *  @param __rhs  Second string. </span>
<span class="lineNum"> 2528</span>              :    *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise. </span>
<span class="lineNum"> 2529</span>              :    *&#047; </span>
<span class="lineNum"> 2530</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2531</span>              :     inline bool </span>
<span class="lineNum"> 2532</span>              :     operator!=(const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __lhs, </span>
<span class="lineNum"> 2533</span>              : 	       const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __rhs) </span>
<span class="lineNum"> 2534</span>              :     { return !(__lhs == __rhs); } </span>
<span class="lineNum"> 2535</span>              :  </span>
<span class="lineNum"> 2536</span>              :   &#047;** </span>
<span class="lineNum"> 2537</span>              :    *  @brief  Test difference of C string and string. </span>
<span class="lineNum"> 2538</span>              :    *  @param __lhs  C string. </span>
<span class="lineNum"> 2539</span>              :    *  @param __rhs  String. </span>
<span class="lineNum"> 2540</span>              :    *  @return  True if @a __rhs.compare(@a __lhs) != 0.  False otherwise. </span>
<span class="lineNum"> 2541</span>              :    *&#047; </span>
<span class="lineNum"> 2542</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2543</span>              :     inline bool </span>
<span class="lineNum"> 2544</span>              :     operator!=(const _CharT* __lhs, </span>
<span class="lineNum"> 2545</span>              : 	       const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __rhs) </span>
<span class="lineNum"> 2546</span>              :     { return !(__lhs == __rhs); } </span>
<span class="lineNum"> 2547</span>              :  </span>
<span class="lineNum"> 2548</span>              :   &#047;** </span>
<span class="lineNum"> 2549</span>              :    *  @brief  Test difference of string and C string. </span>
<span class="lineNum"> 2550</span>              :    *  @param __lhs  String. </span>
<span class="lineNum"> 2551</span>              :    *  @param __rhs  C string. </span>
<span class="lineNum"> 2552</span>              :    *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise. </span>
<span class="lineNum"> 2553</span>              :    *&#047; </span>
<span class="lineNum"> 2554</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2555</span>              :     inline bool </span>
<span class="lineNum"> 2556</span>              :     operator!=(const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __lhs, </span>
<span class="lineNum"> 2557</span>              : 	       const _CharT* __rhs) </span>
<span class="lineNum"> 2558</span>              :     { return !(__lhs == __rhs); } </span>
<span class="lineNum"> 2559</span>              :  </span>
<span class="lineNum"> 2560</span>              :   &#047;&#047; operator &lt; </span>
<span class="lineNum"> 2561</span>              :   &#047;** </span>
<span class="lineNum"> 2562</span>              :    *  @brief  Test if string precedes string. </span>
<span class="lineNum"> 2563</span>              :    *  @param __lhs  First string. </span>
<span class="lineNum"> 2564</span>              :    *  @param __rhs  Second string. </span>
<span class="lineNum"> 2565</span>              :    *  @return  True if @a __lhs precedes @a __rhs.  False otherwise. </span>
<span class="lineNum"> 2566</span>              :    *&#047; </span>
<span class="lineNum"> 2567</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2568</span>              :     inline bool </span>
<span class="lineNum"> 2569</span><span class="lineCov">      1  /   1:     operator&lt;(const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __lhs, </span>
<span class="lineNum"> 2570</span>              : 	      const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __rhs) </span>
<span class="lineNum"> 2571</span><span class="linePartCov">      1  /   2:     { return __lhs.compare(__rhs) &lt; 0; } </span>
<span class="lineNum"> 2572</span>              :  </span>
<span class="lineNum"> 2573</span>              :   &#047;** </span>
<span class="lineNum"> 2574</span>              :    *  @brief  Test if string precedes C string. </span>
<span class="lineNum"> 2575</span>              :    *  @param __lhs  String. </span>
<span class="lineNum"> 2576</span>              :    *  @param __rhs  C string. </span>
<span class="lineNum"> 2577</span>              :    *  @return  True if @a __lhs precedes @a __rhs.  False otherwise. </span>
<span class="lineNum"> 2578</span>              :    *&#047; </span>
<span class="lineNum"> 2579</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2580</span>              :     inline bool </span>
<span class="lineNum"> 2581</span>              :     operator&lt;(const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __lhs, </span>
<span class="lineNum"> 2582</span>              : 	      const _CharT* __rhs) </span>
<span class="lineNum"> 2583</span>              :     { return __lhs.compare(__rhs) &lt; 0; } </span>
<span class="lineNum"> 2584</span>              :  </span>
<span class="lineNum"> 2585</span>              :   &#047;** </span>
<span class="lineNum"> 2586</span>              :    *  @brief  Test if C string precedes string. </span>
<span class="lineNum"> 2587</span>              :    *  @param __lhs  C string. </span>
<span class="lineNum"> 2588</span>              :    *  @param __rhs  String. </span>
<span class="lineNum"> 2589</span>              :    *  @return  True if @a __lhs precedes @a __rhs.  False otherwise. </span>
<span class="lineNum"> 2590</span>              :    *&#047; </span>
<span class="lineNum"> 2591</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2592</span>              :     inline bool </span>
<span class="lineNum"> 2593</span>              :     operator&lt;(const _CharT* __lhs, </span>
<span class="lineNum"> 2594</span>              : 	      const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __rhs) </span>
<span class="lineNum"> 2595</span>              :     { return __rhs.compare(__lhs) &gt; 0; } </span>
<span class="lineNum"> 2596</span>              :  </span>
<span class="lineNum"> 2597</span>              :   &#047;&#047; operator &gt; </span>
<span class="lineNum"> 2598</span>              :   &#047;** </span>
<span class="lineNum"> 2599</span>              :    *  @brief  Test if string follows string. </span>
<span class="lineNum"> 2600</span>              :    *  @param __lhs  First string. </span>
<span class="lineNum"> 2601</span>              :    *  @param __rhs  Second string. </span>
<span class="lineNum"> 2602</span>              :    *  @return  True if @a __lhs follows @a __rhs.  False otherwise. </span>
<span class="lineNum"> 2603</span>              :    *&#047; </span>
<span class="lineNum"> 2604</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2605</span>              :     inline bool </span>
<span class="lineNum"> 2606</span>              :     operator&gt;(const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __lhs, </span>
<span class="lineNum"> 2607</span>              : 	      const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __rhs) </span>
<span class="lineNum"> 2608</span>              :     { return __lhs.compare(__rhs) &gt; 0; } </span>
<span class="lineNum"> 2609</span>              :  </span>
<span class="lineNum"> 2610</span>              :   &#047;** </span>
<span class="lineNum"> 2611</span>              :    *  @brief  Test if string follows C string. </span>
<span class="lineNum"> 2612</span>              :    *  @param __lhs  String. </span>
<span class="lineNum"> 2613</span>              :    *  @param __rhs  C string. </span>
<span class="lineNum"> 2614</span>              :    *  @return  True if @a __lhs follows @a __rhs.  False otherwise. </span>
<span class="lineNum"> 2615</span>              :    *&#047; </span>
<span class="lineNum"> 2616</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2617</span>              :     inline bool </span>
<span class="lineNum"> 2618</span>              :     operator&gt;(const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __lhs, </span>
<span class="lineNum"> 2619</span>              : 	      const _CharT* __rhs) </span>
<span class="lineNum"> 2620</span>              :     { return __lhs.compare(__rhs) &gt; 0; } </span>
<span class="lineNum"> 2621</span>              :  </span>
<span class="lineNum"> 2622</span>              :   &#047;** </span>
<span class="lineNum"> 2623</span>              :    *  @brief  Test if C string follows string. </span>
<span class="lineNum"> 2624</span>              :    *  @param __lhs  C string. </span>
<span class="lineNum"> 2625</span>              :    *  @param __rhs  String. </span>
<span class="lineNum"> 2626</span>              :    *  @return  True if @a __lhs follows @a __rhs.  False otherwise. </span>
<span class="lineNum"> 2627</span>              :    *&#047; </span>
<span class="lineNum"> 2628</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2629</span>              :     inline bool </span>
<span class="lineNum"> 2630</span>              :     operator&gt;(const _CharT* __lhs, </span>
<span class="lineNum"> 2631</span>              : 	      const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __rhs) </span>
<span class="lineNum"> 2632</span>              :     { return __rhs.compare(__lhs) &lt; 0; } </span>
<span class="lineNum"> 2633</span>              :  </span>
<span class="lineNum"> 2634</span>              :   &#047;&#047; operator &lt;= </span>
<span class="lineNum"> 2635</span>              :   &#047;** </span>
<span class="lineNum"> 2636</span>              :    *  @brief  Test if string doesn&#039;t follow string. </span>
<span class="lineNum"> 2637</span>              :    *  @param __lhs  First string. </span>
<span class="lineNum"> 2638</span>              :    *  @param __rhs  Second string. </span>
<span class="lineNum"> 2639</span>              :    *  @return  True if @a __lhs doesn&#039;t follow @a __rhs.  False otherwise. </span>
<span class="lineNum"> 2640</span>              :    *&#047; </span>
<span class="lineNum"> 2641</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2642</span>              :     inline bool </span>
<span class="lineNum"> 2643</span>              :     operator&lt;=(const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __lhs, </span>
<span class="lineNum"> 2644</span>              : 	       const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __rhs) </span>
<span class="lineNum"> 2645</span>              :     { return __lhs.compare(__rhs) &lt;= 0; } </span>
<span class="lineNum"> 2646</span>              :  </span>
<span class="lineNum"> 2647</span>              :   &#047;** </span>
<span class="lineNum"> 2648</span>              :    *  @brief  Test if string doesn&#039;t follow C string. </span>
<span class="lineNum"> 2649</span>              :    *  @param __lhs  String. </span>
<span class="lineNum"> 2650</span>              :    *  @param __rhs  C string. </span>
<span class="lineNum"> 2651</span>              :    *  @return  True if @a __lhs doesn&#039;t follow @a __rhs.  False otherwise. </span>
<span class="lineNum"> 2652</span>              :    *&#047; </span>
<span class="lineNum"> 2653</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2654</span>              :     inline bool </span>
<span class="lineNum"> 2655</span>              :     operator&lt;=(const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __lhs, </span>
<span class="lineNum"> 2656</span>              : 	       const _CharT* __rhs) </span>
<span class="lineNum"> 2657</span>              :     { return __lhs.compare(__rhs) &lt;= 0; } </span>
<span class="lineNum"> 2658</span>              :  </span>
<span class="lineNum"> 2659</span>              :   &#047;** </span>
<span class="lineNum"> 2660</span>              :    *  @brief  Test if C string doesn&#039;t follow string. </span>
<span class="lineNum"> 2661</span>              :    *  @param __lhs  C string. </span>
<span class="lineNum"> 2662</span>              :    *  @param __rhs  String. </span>
<span class="lineNum"> 2663</span>              :    *  @return  True if @a __lhs doesn&#039;t follow @a __rhs.  False otherwise. </span>
<span class="lineNum"> 2664</span>              :    *&#047; </span>
<span class="lineNum"> 2665</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2666</span>              :     inline bool </span>
<span class="lineNum"> 2667</span>              :     operator&lt;=(const _CharT* __lhs, </span>
<span class="lineNum"> 2668</span>              : 	       const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __rhs) </span>
<span class="lineNum"> 2669</span>              :     { return __rhs.compare(__lhs) &gt;= 0; } </span>
<span class="lineNum"> 2670</span>              :  </span>
<span class="lineNum"> 2671</span>              :   &#047;&#047; operator &gt;= </span>
<span class="lineNum"> 2672</span>              :   &#047;** </span>
<span class="lineNum"> 2673</span>              :    *  @brief  Test if string doesn&#039;t precede string. </span>
<span class="lineNum"> 2674</span>              :    *  @param __lhs  First string. </span>
<span class="lineNum"> 2675</span>              :    *  @param __rhs  Second string. </span>
<span class="lineNum"> 2676</span>              :    *  @return  True if @a __lhs doesn&#039;t precede @a __rhs.  False otherwise. </span>
<span class="lineNum"> 2677</span>              :    *&#047; </span>
<span class="lineNum"> 2678</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2679</span>              :     inline bool </span>
<span class="lineNum"> 2680</span>              :     operator&gt;=(const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __lhs, </span>
<span class="lineNum"> 2681</span>              : 	       const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __rhs) </span>
<span class="lineNum"> 2682</span>              :     { return __lhs.compare(__rhs) &gt;= 0; } </span>
<span class="lineNum"> 2683</span>              :  </span>
<span class="lineNum"> 2684</span>              :   &#047;** </span>
<span class="lineNum"> 2685</span>              :    *  @brief  Test if string doesn&#039;t precede C string. </span>
<span class="lineNum"> 2686</span>              :    *  @param __lhs  String. </span>
<span class="lineNum"> 2687</span>              :    *  @param __rhs  C string. </span>
<span class="lineNum"> 2688</span>              :    *  @return  True if @a __lhs doesn&#039;t precede @a __rhs.  False otherwise. </span>
<span class="lineNum"> 2689</span>              :    *&#047; </span>
<span class="lineNum"> 2690</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2691</span>              :     inline bool </span>
<span class="lineNum"> 2692</span>              :     operator&gt;=(const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __lhs, </span>
<span class="lineNum"> 2693</span>              : 	       const _CharT* __rhs) </span>
<span class="lineNum"> 2694</span>              :     { return __lhs.compare(__rhs) &gt;= 0; } </span>
<span class="lineNum"> 2695</span>              :  </span>
<span class="lineNum"> 2696</span>              :   &#047;** </span>
<span class="lineNum"> 2697</span>              :    *  @brief  Test if C string doesn&#039;t precede string. </span>
<span class="lineNum"> 2698</span>              :    *  @param __lhs  C string. </span>
<span class="lineNum"> 2699</span>              :    *  @param __rhs  String. </span>
<span class="lineNum"> 2700</span>              :    *  @return  True if @a __lhs doesn&#039;t precede @a __rhs.  False otherwise. </span>
<span class="lineNum"> 2701</span>              :    *&#047; </span>
<span class="lineNum"> 2702</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2703</span>              :     inline bool </span>
<span class="lineNum"> 2704</span>              :     operator&gt;=(const _CharT* __lhs, </span>
<span class="lineNum"> 2705</span>              : 	     const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __rhs) </span>
<span class="lineNum"> 2706</span>              :     { return __rhs.compare(__lhs) &lt;= 0; } </span>
<span class="lineNum"> 2707</span>              :  </span>
<span class="lineNum"> 2708</span>              :   &#047;** </span>
<span class="lineNum"> 2709</span>              :    *  @brief  Swap contents of two strings. </span>
<span class="lineNum"> 2710</span>              :    *  @param __lhs  First string. </span>
<span class="lineNum"> 2711</span>              :    *  @param __rhs  Second string. </span>
<span class="lineNum"> 2712</span>              :    * </span>
<span class="lineNum"> 2713</span>              :    *  Exchanges the contents of @a __lhs and @a __rhs in constant time. </span>
<span class="lineNum"> 2714</span>              :    *&#047; </span>
<span class="lineNum"> 2715</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2716</span>              :     inline void </span>
<span class="lineNum"> 2717</span>              :     swap(basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __lhs, </span>
<span class="lineNum"> 2718</span>              : 	 basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __rhs) </span>
<span class="lineNum"> 2719</span>              :     { __lhs.swap(__rhs); } </span>
<span class="lineNum"> 2720</span>              :  </span>
<span class="lineNum"> 2721</span>              :   &#047;** </span>
<span class="lineNum"> 2722</span>              :    *  @brief  Read stream into a string. </span>
<span class="lineNum"> 2723</span>              :    *  @param __is  Input stream. </span>
<span class="lineNum"> 2724</span>              :    *  @param __str  Buffer to store into. </span>
<span class="lineNum"> 2725</span>              :    *  @return  Reference to the input stream. </span>
<span class="lineNum"> 2726</span>              :    * </span>
<span class="lineNum"> 2727</span>              :    *  Stores characters from @a __is into @a __str until whitespace is </span>
<span class="lineNum"> 2728</span>              :    *  found, the end of the stream is encountered, or str.max_size() </span>
<span class="lineNum"> 2729</span>              :    *  is reached.  If is.width() is non-zero, that is the limit on the </span>
<span class="lineNum"> 2730</span>              :    *  number of characters stored into @a __str.  Any previous </span>
<span class="lineNum"> 2731</span>              :    *  contents of @a __str are erased. </span>
<span class="lineNum"> 2732</span>              :    *&#047; </span>
<span class="lineNum"> 2733</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2734</span>              :     basic_istream&lt;_CharT, _Traits&gt;&amp; </span>
<span class="lineNum"> 2735</span>              :     operator&gt;&gt;(basic_istream&lt;_CharT, _Traits&gt;&amp; __is, </span>
<span class="lineNum"> 2736</span>              : 	       basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __str); </span>
<span class="lineNum"> 2737</span>              :  </span>
<span class="lineNum"> 2738</span>              :   template&lt;&gt; </span>
<span class="lineNum"> 2739</span>              :     basic_istream&lt;char&gt;&amp; </span>
<span class="lineNum"> 2740</span>              :     operator&gt;&gt;(basic_istream&lt;char&gt;&amp; __is, basic_string&lt;char&gt;&amp; __str); </span>
<span class="lineNum"> 2741</span>              :  </span>
<span class="lineNum"> 2742</span>              :   &#047;** </span>
<span class="lineNum"> 2743</span>              :    *  @brief  Write string to a stream. </span>
<span class="lineNum"> 2744</span>              :    *  @param __os  Output stream. </span>
<span class="lineNum"> 2745</span>              :    *  @param __str  String to write out. </span>
<span class="lineNum"> 2746</span>              :    *  @return  Reference to the output stream. </span>
<span class="lineNum"> 2747</span>              :    * </span>
<span class="lineNum"> 2748</span>              :    *  Output characters of @a __str into os following the same rules as for </span>
<span class="lineNum"> 2749</span>              :    *  writing a C string. </span>
<span class="lineNum"> 2750</span>              :    *&#047; </span>
<span class="lineNum"> 2751</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2752</span>              :     inline basic_ostream&lt;_CharT, _Traits&gt;&amp; </span>
<span class="lineNum"> 2753</span>              :     operator&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp; __os, </span>
<span class="lineNum"> 2754</span>              : 	       const basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __str) </span>
<span class="lineNum"> 2755</span>              :     { </span>
<span class="lineNum"> 2756</span>              :       &#047;&#047; _GLIBCXX_RESOLVE_LIB_DEFECTS </span>
<span class="lineNum"> 2757</span>              :       &#047;&#047; 586. string inserter not a formatted function </span>
<span class="lineNum"> 2758</span>              :       return __ostream_insert(__os, __str.data(), __str.size()); </span>
<span class="lineNum"> 2759</span>              :     } </span>
<span class="lineNum"> 2760</span>              :  </span>
<span class="lineNum"> 2761</span>              :   &#047;** </span>
<span class="lineNum"> 2762</span>              :    *  @brief  Read a line from stream into a string. </span>
<span class="lineNum"> 2763</span>              :    *  @param __is  Input stream. </span>
<span class="lineNum"> 2764</span>              :    *  @param __str  Buffer to store into. </span>
<span class="lineNum"> 2765</span>              :    *  @param __delim  Character marking end of line. </span>
<span class="lineNum"> 2766</span>              :    *  @return  Reference to the input stream. </span>
<span class="lineNum"> 2767</span>              :    * </span>
<span class="lineNum"> 2768</span>              :    *  Stores characters from @a __is into @a __str until @a __delim is </span>
<span class="lineNum"> 2769</span>              :    *  found, the end of the stream is encountered, or str.max_size() </span>
<span class="lineNum"> 2770</span>              :    *  is reached.  Any previous contents of @a __str are erased.  If </span>
<span class="lineNum"> 2771</span>              :    *  @a __delim is encountered, it is extracted but not stored into </span>
<span class="lineNum"> 2772</span>              :    *  @a __str. </span>
<span class="lineNum"> 2773</span>              :    *&#047; </span>
<span class="lineNum"> 2774</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2775</span>              :     basic_istream&lt;_CharT, _Traits&gt;&amp; </span>
<span class="lineNum"> 2776</span>              :     getline(basic_istream&lt;_CharT, _Traits&gt;&amp; __is, </span>
<span class="lineNum"> 2777</span>              : 	    basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __str, _CharT __delim); </span>
<span class="lineNum"> 2778</span>              :  </span>
<span class="lineNum"> 2779</span>              :   &#047;** </span>
<span class="lineNum"> 2780</span>              :    *  @brief  Read a line from stream into a string. </span>
<span class="lineNum"> 2781</span>              :    *  @param __is  Input stream. </span>
<span class="lineNum"> 2782</span>              :    *  @param __str  Buffer to store into. </span>
<span class="lineNum"> 2783</span>              :    *  @return  Reference to the input stream. </span>
<span class="lineNum"> 2784</span>              :    * </span>
<span class="lineNum"> 2785</span>              :    *  Stores characters from is into @a __str until &amp;apos;&#092;n&amp;apos; is </span>
<span class="lineNum"> 2786</span>              :    *  found, the end of the stream is encountered, or str.max_size() </span>
<span class="lineNum"> 2787</span>              :    *  is reached.  Any previous contents of @a __str are erased.  If </span>
<span class="lineNum"> 2788</span>              :    *  end of line is encountered, it is extracted but not stored into </span>
<span class="lineNum"> 2789</span>              :    *  @a __str. </span>
<span class="lineNum"> 2790</span>              :    *&#047; </span>
<span class="lineNum"> 2791</span>              :   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt; </span>
<span class="lineNum"> 2792</span>              :     inline basic_istream&lt;_CharT, _Traits&gt;&amp; </span>
<span class="lineNum"> 2793</span>              :     getline(basic_istream&lt;_CharT, _Traits&gt;&amp; __is, </span>
<span class="lineNum"> 2794</span>              : 	    basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __str) </span>
<span class="lineNum"> 2795</span>              :     { return getline(__is, __str, __is.widen(&#039;&#092;n&#039;)); } </span>
<span class="lineNum"> 2796</span>              :  </span>
<span class="lineNum"> 2797</span>              :   template&lt;&gt; </span>
<span class="lineNum"> 2798</span>              :     basic_istream&lt;char&gt;&amp; </span>
<span class="lineNum"> 2799</span>              :     getline(basic_istream&lt;char&gt;&amp; __in, basic_string&lt;char&gt;&amp; __str, </span>
<span class="lineNum"> 2800</span>              : 	    char __delim); </span>
<span class="lineNum"> 2801</span>              :  </span>
<span class="lineNum"> 2802</span>              : #ifdef _GLIBCXX_USE_WCHAR_T </span>
<span class="lineNum"> 2803</span>              :   template&lt;&gt; </span>
<span class="lineNum"> 2804</span>              :     basic_istream&lt;wchar_t&gt;&amp; </span>
<span class="lineNum"> 2805</span>              :     getline(basic_istream&lt;wchar_t&gt;&amp; __in, basic_string&lt;wchar_t&gt;&amp; __str, </span>
<span class="lineNum"> 2806</span>              : 	    wchar_t __delim); </span>
<span class="lineNum"> 2807</span>              : #endif   </span>
<span class="lineNum"> 2808</span>              :  </span>
<span class="lineNum"> 2809</span>              : _GLIBCXX_END_NAMESPACE_VERSION </span>
<span class="lineNum"> 2810</span>              : } &#047;&#047; namespace </span>
<span class="lineNum"> 2811</span>              :  </span>
<span class="lineNum"> 2812</span>              : #if ((__cplusplus &gt;= 201103L) &amp;&amp; defined(_GLIBCXX_USE_C99) &#092; </span>
<span class="lineNum"> 2813</span>              :      &amp;&amp; !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF)) </span>
<span class="lineNum"> 2814</span>              :  </span>
<span class="lineNum"> 2815</span>              : #include &lt;ext&#047;string_conversions.h&gt; </span>
<span class="lineNum"> 2816</span>              :  </span>
<span class="lineNum"> 2817</span>              : namespace std _GLIBCXX_VISIBILITY(default) </span>
<span class="lineNum"> 2818</span>              : { </span>
<span class="lineNum"> 2819</span>              : _GLIBCXX_BEGIN_NAMESPACE_VERSION </span>
<span class="lineNum"> 2820</span>              :  </span>
<span class="lineNum"> 2821</span>              :   &#047;&#047; 21.4 Numeric Conversions [string.conversions]. </span>
<span class="lineNum"> 2822</span>              :   inline int </span>
<span class="lineNum"> 2823</span>              :   stoi(const string&amp; __str, size_t* __idx = 0, int __base = 10) </span>
<span class="lineNum"> 2824</span>              :   { return __gnu_cxx::__stoa&lt;long, int&gt;(&amp;std::strtol, &quot;stoi&quot;, __str.c_str(), </span>
<span class="lineNum"> 2825</span>              : 					__idx, __base); } </span>
<span class="lineNum"> 2826</span>              :  </span>
<span class="lineNum"> 2827</span>              :   inline long </span>
<span class="lineNum"> 2828</span>              :   stol(const string&amp; __str, size_t* __idx = 0, int __base = 10) </span>
<span class="lineNum"> 2829</span>              :   { return __gnu_cxx::__stoa(&amp;std::strtol, &quot;stol&quot;, __str.c_str(), </span>
<span class="lineNum"> 2830</span>              : 			     __idx, __base); } </span>
<span class="lineNum"> 2831</span>              :  </span>
<span class="lineNum"> 2832</span>              :   inline unsigned long </span>
<span class="lineNum"> 2833</span>              :   stoul(const string&amp; __str, size_t* __idx = 0, int __base = 10) </span>
<span class="lineNum"> 2834</span><span class="lineNoCov">      0  /   1:   { return __gnu_cxx::__stoa(&amp;std::strtoul, &quot;stoul&quot;, __str.c_str(), </span>
<span class="lineNum"> 2835</span><span class="lineNoCov">      0  /   2: 			     __idx, __base); } </span>
<span class="lineNum"> 2836</span>              :  </span>
<span class="lineNum"> 2837</span>              :   inline long long </span>
<span class="lineNum"> 2838</span>              :   stoll(const string&amp; __str, size_t* __idx = 0, int __base = 10) </span>
<span class="lineNum"> 2839</span>              :   { return __gnu_cxx::__stoa(&amp;std::strtoll, &quot;stoll&quot;, __str.c_str(), </span>
<span class="lineNum"> 2840</span>              : 			     __idx, __base); } </span>
<span class="lineNum"> 2841</span>              :  </span>
<span class="lineNum"> 2842</span>              :   inline unsigned long long </span>
<span class="lineNum"> 2843</span>              :   stoull(const string&amp; __str, size_t* __idx = 0, int __base = 10) </span>
<span class="lineNum"> 2844</span>              :   { return __gnu_cxx::__stoa(&amp;std::strtoull, &quot;stoull&quot;, __str.c_str(), </span>
<span class="lineNum"> 2845</span>              : 			     __idx, __base); } </span>
<span class="lineNum"> 2846</span>              :  </span>
<span class="lineNum"> 2847</span>              :   &#047;&#047; NB: strtof vs strtod. </span>
<span class="lineNum"> 2848</span>              :   inline float </span>
<span class="lineNum"> 2849</span>              :   stof(const string&amp; __str, size_t* __idx = 0) </span>
<span class="lineNum"> 2850</span>              :   { return __gnu_cxx::__stoa(&amp;std::strtof, &quot;stof&quot;, __str.c_str(), __idx); } </span>
<span class="lineNum"> 2851</span>              :  </span>
<span class="lineNum"> 2852</span>              :   inline double </span>
<span class="lineNum"> 2853</span>              :   stod(const string&amp; __str, size_t* __idx = 0) </span>
<span class="lineNum"> 2854</span>              :   { return __gnu_cxx::__stoa(&amp;std::strtod, &quot;stod&quot;, __str.c_str(), __idx); } </span>
<span class="lineNum"> 2855</span>              :  </span>
<span class="lineNum"> 2856</span>              :   inline long double </span>
<span class="lineNum"> 2857</span>              :   stold(const string&amp; __str, size_t* __idx = 0) </span>
<span class="lineNum"> 2858</span>              :   { return __gnu_cxx::__stoa(&amp;std::strtold, &quot;stold&quot;, __str.c_str(), __idx); } </span>
<span class="lineNum"> 2859</span>              :  </span>
<span class="lineNum"> 2860</span>              :   &#047;&#047; NB: (v)snprintf vs sprintf. </span>
<span class="lineNum"> 2861</span>              :  </span>
<span class="lineNum"> 2862</span>              :   &#047;&#047; DR 1261. </span>
<span class="lineNum"> 2863</span>              :   inline string </span>
<span class="lineNum"> 2864</span>              :   to_string(int __val) </span>
<span class="lineNum"> 2865</span>              :   { return __gnu_cxx::__to_xstring&lt;string&gt;(&amp;std::vsnprintf, 4 * sizeof(int), </span>
<span class="lineNum"> 2866</span>              : 					   &quot;%d&quot;, __val); } </span>
<span class="lineNum"> 2867</span>              :  </span>
<span class="lineNum"> 2868</span>              :   inline string </span>
<span class="lineNum"> 2869</span>              :   to_string(unsigned __val) </span>
<span class="lineNum"> 2870</span>              :   { return __gnu_cxx::__to_xstring&lt;string&gt;(&amp;std::vsnprintf, </span>
<span class="lineNum"> 2871</span>              : 					   4 * sizeof(unsigned), </span>
<span class="lineNum"> 2872</span>              : 					   &quot;%u&quot;, __val); } </span>
<span class="lineNum"> 2873</span>              :  </span>
<span class="lineNum"> 2874</span>              :   inline string </span>
<span class="lineNum"> 2875</span>              :   to_string(long __val) </span>
<span class="lineNum"> 2876</span>              :   { return __gnu_cxx::__to_xstring&lt;string&gt;(&amp;std::vsnprintf, 4 * sizeof(long), </span>
<span class="lineNum"> 2877</span>              : 					   &quot;%ld&quot;, __val); } </span>
<span class="lineNum"> 2878</span>              :  </span>
<span class="lineNum"> 2879</span>              :   inline string </span>
<span class="lineNum"> 2880</span>              :   to_string(unsigned long __val) </span>
<span class="lineNum"> 2881</span>              :   { return __gnu_cxx::__to_xstring&lt;string&gt;(&amp;std::vsnprintf, </span>
<span class="lineNum"> 2882</span>              : 					   4 * sizeof(unsigned long), </span>
<span class="lineNum"> 2883</span>              : 					   &quot;%lu&quot;, __val); } </span>
<span class="lineNum"> 2884</span>              :  </span>
<span class="lineNum"> 2885</span>              :   inline string </span>
<span class="lineNum"> 2886</span>              :   to_string(long long __val) </span>
<span class="lineNum"> 2887</span>              :   { return __gnu_cxx::__to_xstring&lt;string&gt;(&amp;std::vsnprintf, </span>
<span class="lineNum"> 2888</span>              : 					   4 * sizeof(long long), </span>
<span class="lineNum"> 2889</span>              : 					   &quot;%lld&quot;, __val); } </span>
<span class="lineNum"> 2890</span>              :  </span>
<span class="lineNum"> 2891</span>              :   inline string </span>
<span class="lineNum"> 2892</span>              :   to_string(unsigned long long __val) </span>
<span class="lineNum"> 2893</span>              :   { return __gnu_cxx::__to_xstring&lt;string&gt;(&amp;std::vsnprintf, </span>
<span class="lineNum"> 2894</span>              : 					   4 * sizeof(unsigned long long), </span>
<span class="lineNum"> 2895</span>              : 					   &quot;%llu&quot;, __val); } </span>
<span class="lineNum"> 2896</span>              :  </span>
<span class="lineNum"> 2897</span>              :   inline string </span>
<span class="lineNum"> 2898</span>              :   to_string(float __val) </span>
<span class="lineNum"> 2899</span>              :   { </span>
<span class="lineNum"> 2900</span>              :     const int __n =  </span>
<span class="lineNum"> 2901</span>              :       __gnu_cxx::__numeric_traits&lt;float&gt;::__max_exponent10 + 20; </span>
<span class="lineNum"> 2902</span>              :     return __gnu_cxx::__to_xstring&lt;string&gt;(&amp;std::vsnprintf, __n, </span>
<span class="lineNum"> 2903</span>              : 					   &quot;%f&quot;, __val); </span>
<span class="lineNum"> 2904</span>              :   } </span>
<span class="lineNum"> 2905</span>              :  </span>
<span class="lineNum"> 2906</span>              :   inline string </span>
<span class="lineNum"> 2907</span>              :   to_string(double __val) </span>
<span class="lineNum"> 2908</span>              :   { </span>
<span class="lineNum"> 2909</span>              :     const int __n =  </span>
<span class="lineNum"> 2910</span>              :       __gnu_cxx::__numeric_traits&lt;double&gt;::__max_exponent10 + 20; </span>
<span class="lineNum"> 2911</span>              :     return __gnu_cxx::__to_xstring&lt;string&gt;(&amp;std::vsnprintf, __n, </span>
<span class="lineNum"> 2912</span>              : 					   &quot;%f&quot;, __val); </span>
<span class="lineNum"> 2913</span>              :   } </span>
<span class="lineNum"> 2914</span>              :  </span>
<span class="lineNum"> 2915</span>              :   inline string </span>
<span class="lineNum"> 2916</span>              :   to_string(long double __val) </span>
<span class="lineNum"> 2917</span>              :   { </span>
<span class="lineNum"> 2918</span>              :     const int __n =  </span>
<span class="lineNum"> 2919</span>              :       __gnu_cxx::__numeric_traits&lt;long double&gt;::__max_exponent10 + 20; </span>
<span class="lineNum"> 2920</span>              :     return __gnu_cxx::__to_xstring&lt;string&gt;(&amp;std::vsnprintf, __n, </span>
<span class="lineNum"> 2921</span>              : 					   &quot;%Lf&quot;, __val); </span>
<span class="lineNum"> 2922</span>              :   } </span>
<span class="lineNum"> 2923</span>              :  </span>
<span class="lineNum"> 2924</span>              : #ifdef _GLIBCXX_USE_WCHAR_T </span>
<span class="lineNum"> 2925</span>              :   inline int  </span>
<span class="lineNum"> 2926</span>              :   stoi(const wstring&amp; __str, size_t* __idx = 0, int __base = 10) </span>
<span class="lineNum"> 2927</span>              :   { return __gnu_cxx::__stoa&lt;long, int&gt;(&amp;std::wcstol, &quot;stoi&quot;, __str.c_str(), </span>
<span class="lineNum"> 2928</span>              : 					__idx, __base); } </span>
<span class="lineNum"> 2929</span>              :  </span>
<span class="lineNum"> 2930</span>              :   inline long  </span>
<span class="lineNum"> 2931</span>              :   stol(const wstring&amp; __str, size_t* __idx = 0, int __base = 10) </span>
<span class="lineNum"> 2932</span>              :   { return __gnu_cxx::__stoa(&amp;std::wcstol, &quot;stol&quot;, __str.c_str(), </span>
<span class="lineNum"> 2933</span>              : 			     __idx, __base); } </span>
<span class="lineNum"> 2934</span>              :  </span>
<span class="lineNum"> 2935</span>              :   inline unsigned long </span>
<span class="lineNum"> 2936</span>              :   stoul(const wstring&amp; __str, size_t* __idx = 0, int __base = 10) </span>
<span class="lineNum"> 2937</span>              :   { return __gnu_cxx::__stoa(&amp;std::wcstoul, &quot;stoul&quot;, __str.c_str(), </span>
<span class="lineNum"> 2938</span>              : 			     __idx, __base); } </span>
<span class="lineNum"> 2939</span>              :  </span>
<span class="lineNum"> 2940</span>              :   inline long long </span>
<span class="lineNum"> 2941</span>              :   stoll(const wstring&amp; __str, size_t* __idx = 0, int __base = 10) </span>
<span class="lineNum"> 2942</span>              :   { return __gnu_cxx::__stoa(&amp;std::wcstoll, &quot;stoll&quot;, __str.c_str(), </span>
<span class="lineNum"> 2943</span>              : 			     __idx, __base); } </span>
<span class="lineNum"> 2944</span>              :  </span>
<span class="lineNum"> 2945</span>              :   inline unsigned long long </span>
<span class="lineNum"> 2946</span>              :   stoull(const wstring&amp; __str, size_t* __idx = 0, int __base = 10) </span>
<span class="lineNum"> 2947</span>              :   { return __gnu_cxx::__stoa(&amp;std::wcstoull, &quot;stoull&quot;, __str.c_str(), </span>
<span class="lineNum"> 2948</span>              : 			     __idx, __base); } </span>
<span class="lineNum"> 2949</span>              :  </span>
<span class="lineNum"> 2950</span>              :   &#047;&#047; NB: wcstof vs wcstod. </span>
<span class="lineNum"> 2951</span>              :   inline float </span>
<span class="lineNum"> 2952</span>              :   stof(const wstring&amp; __str, size_t* __idx = 0) </span>
<span class="lineNum"> 2953</span>              :   { return __gnu_cxx::__stoa(&amp;std::wcstof, &quot;stof&quot;, __str.c_str(), __idx); } </span>
<span class="lineNum"> 2954</span>              :  </span>
<span class="lineNum"> 2955</span>              :   inline double </span>
<span class="lineNum"> 2956</span>              :   stod(const wstring&amp; __str, size_t* __idx = 0) </span>
<span class="lineNum"> 2957</span>              :   { return __gnu_cxx::__stoa(&amp;std::wcstod, &quot;stod&quot;, __str.c_str(), __idx); } </span>
<span class="lineNum"> 2958</span>              :  </span>
<span class="lineNum"> 2959</span>              :   inline long double </span>
<span class="lineNum"> 2960</span>              :   stold(const wstring&amp; __str, size_t* __idx = 0) </span>
<span class="lineNum"> 2961</span>              :   { return __gnu_cxx::__stoa(&amp;std::wcstold, &quot;stold&quot;, __str.c_str(), __idx); } </span>
<span class="lineNum"> 2962</span>              :  </span>
<span class="lineNum"> 2963</span>              :   &#047;&#047; DR 1261. </span>
<span class="lineNum"> 2964</span>              :   inline wstring </span>
<span class="lineNum"> 2965</span>              :   to_wstring(int __val) </span>
<span class="lineNum"> 2966</span>              :   { return __gnu_cxx::__to_xstring&lt;wstring&gt;(&amp;std::vswprintf, 4 * sizeof(int), </span>
<span class="lineNum"> 2967</span>              : 					    L&quot;%d&quot;, __val); } </span>
<span class="lineNum"> 2968</span>              :  </span>
<span class="lineNum"> 2969</span>              :   inline wstring </span>
<span class="lineNum"> 2970</span>              :   to_wstring(unsigned __val) </span>
<span class="lineNum"> 2971</span>              :   { return __gnu_cxx::__to_xstring&lt;wstring&gt;(&amp;std::vswprintf, </span>
<span class="lineNum"> 2972</span>              : 					    4 * sizeof(unsigned), </span>
<span class="lineNum"> 2973</span>              : 					    L&quot;%u&quot;, __val); } </span>
<span class="lineNum"> 2974</span>              :  </span>
<span class="lineNum"> 2975</span>              :   inline wstring </span>
<span class="lineNum"> 2976</span>              :   to_wstring(long __val) </span>
<span class="lineNum"> 2977</span>              :   { return __gnu_cxx::__to_xstring&lt;wstring&gt;(&amp;std::vswprintf, 4 * sizeof(long), </span>
<span class="lineNum"> 2978</span>              : 					    L&quot;%ld&quot;, __val); } </span>
<span class="lineNum"> 2979</span>              :  </span>
<span class="lineNum"> 2980</span>              :   inline wstring </span>
<span class="lineNum"> 2981</span>              :   to_wstring(unsigned long __val) </span>
<span class="lineNum"> 2982</span>              :   { return __gnu_cxx::__to_xstring&lt;wstring&gt;(&amp;std::vswprintf, </span>
<span class="lineNum"> 2983</span>              : 					    4 * sizeof(unsigned long), </span>
<span class="lineNum"> 2984</span>              : 					    L&quot;%lu&quot;, __val); } </span>
<span class="lineNum"> 2985</span>              :  </span>
<span class="lineNum"> 2986</span>              :   inline wstring </span>
<span class="lineNum"> 2987</span>              :   to_wstring(long long __val) </span>
<span class="lineNum"> 2988</span>              :   { return __gnu_cxx::__to_xstring&lt;wstring&gt;(&amp;std::vswprintf, </span>
<span class="lineNum"> 2989</span>              : 					    4 * sizeof(long long), </span>
<span class="lineNum"> 2990</span>              : 					    L&quot;%lld&quot;, __val); } </span>
<span class="lineNum"> 2991</span>              :  </span>
<span class="lineNum"> 2992</span>              :   inline wstring </span>
<span class="lineNum"> 2993</span>              :   to_wstring(unsigned long long __val) </span>
<span class="lineNum"> 2994</span>              :   { return __gnu_cxx::__to_xstring&lt;wstring&gt;(&amp;std::vswprintf, </span>
<span class="lineNum"> 2995</span>              : 					    4 * sizeof(unsigned long long), </span>
<span class="lineNum"> 2996</span>              : 					    L&quot;%llu&quot;, __val); } </span>
<span class="lineNum"> 2997</span>              :  </span>
<span class="lineNum"> 2998</span>              :   inline wstring </span>
<span class="lineNum"> 2999</span>              :   to_wstring(float __val) </span>
<span class="lineNum"> 3000</span>              :   { </span>
<span class="lineNum"> 3001</span>              :     const int __n = </span>
<span class="lineNum"> 3002</span>              :       __gnu_cxx::__numeric_traits&lt;float&gt;::__max_exponent10 + 20; </span>
<span class="lineNum"> 3003</span>              :     return __gnu_cxx::__to_xstring&lt;wstring&gt;(&amp;std::vswprintf, __n, </span>
<span class="lineNum"> 3004</span>              : 					    L&quot;%f&quot;, __val); </span>
<span class="lineNum"> 3005</span>              :   } </span>
<span class="lineNum"> 3006</span>              :  </span>
<span class="lineNum"> 3007</span>              :   inline wstring </span>
<span class="lineNum"> 3008</span>              :   to_wstring(double __val) </span>
<span class="lineNum"> 3009</span>              :   { </span>
<span class="lineNum"> 3010</span>              :     const int __n = </span>
<span class="lineNum"> 3011</span>              :       __gnu_cxx::__numeric_traits&lt;double&gt;::__max_exponent10 + 20; </span>
<span class="lineNum"> 3012</span>              :     return __gnu_cxx::__to_xstring&lt;wstring&gt;(&amp;std::vswprintf, __n, </span>
<span class="lineNum"> 3013</span>              : 					    L&quot;%f&quot;, __val); </span>
<span class="lineNum"> 3014</span>              :   } </span>
<span class="lineNum"> 3015</span>              :  </span>
<span class="lineNum"> 3016</span>              :   inline wstring </span>
<span class="lineNum"> 3017</span>              :   to_wstring(long double __val) </span>
<span class="lineNum"> 3018</span>              :   { </span>
<span class="lineNum"> 3019</span>              :     const int __n = </span>
<span class="lineNum"> 3020</span>              :       __gnu_cxx::__numeric_traits&lt;long double&gt;::__max_exponent10 + 20; </span>
<span class="lineNum"> 3021</span>              :     return __gnu_cxx::__to_xstring&lt;wstring&gt;(&amp;std::vswprintf, __n, </span>
<span class="lineNum"> 3022</span>              : 					    L&quot;%Lf&quot;, __val); </span>
<span class="lineNum"> 3023</span>              :   } </span>
<span class="lineNum"> 3024</span>              : #endif </span>
<span class="lineNum"> 3025</span>              :  </span>
<span class="lineNum"> 3026</span>              : _GLIBCXX_END_NAMESPACE_VERSION </span>
<span class="lineNum"> 3027</span>              : } &#047;&#047; namespace </span>
<span class="lineNum"> 3028</span>              :  </span>
<span class="lineNum"> 3029</span>              : #endif &#047;* C++11 &amp;&amp; _GLIBCXX_USE_C99 ... *&#047; </span>
<span class="lineNum"> 3030</span>              :  </span>
<span class="lineNum"> 3031</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 3032</span>              :  </span>
<span class="lineNum"> 3033</span>              : #include &lt;bits&#047;functional_hash.h&gt; </span>
<span class="lineNum"> 3034</span>              :  </span>
<span class="lineNum"> 3035</span>              : namespace std _GLIBCXX_VISIBILITY(default) </span>
<span class="lineNum"> 3036</span>              : { </span>
<span class="lineNum"> 3037</span>              : _GLIBCXX_BEGIN_NAMESPACE_VERSION </span>
<span class="lineNum"> 3038</span>              :  </span>
<span class="lineNum"> 3039</span>              :   &#047;&#047; DR 1182. </span>
<span class="lineNum"> 3040</span>              :  </span>
<span class="lineNum"> 3041</span>              : #ifndef _GLIBCXX_COMPATIBILITY_CXX0X </span>
<span class="lineNum"> 3042</span>              :   &#047;&#047;&#047; std::hash specialization for string. </span>
<span class="lineNum"> 3043</span>              :   template&lt;&gt; </span>
<span class="lineNum"> 3044</span>              :     struct hash&lt;string&gt; </span>
<span class="lineNum"> 3045</span>              :     : public __hash_base&lt;size_t, string&gt; </span>
<span class="lineNum"> 3046</span>              :     { </span>
<span class="lineNum"> 3047</span>              :       size_t </span>
<span class="lineNum"> 3048</span><span class="lineCov">      1  /   1:       operator()(const string&amp; __s) const noexcept </span>
<span class="lineNum"> 3049</span><span class="linePartCov">      1  /   2:       { return std::_Hash_impl::hash(__s.data(), __s.length()); } </span>
<span class="lineNum"> 3050</span>              :     }; </span>
<span class="lineNum"> 3051</span>              :  </span>
<span class="lineNum"> 3052</span>              :   template&lt;&gt; </span>
<span class="lineNum"> 3053</span>              :     struct __is_fast_hash&lt;hash&lt;string&gt;&gt; : std::false_type </span>
<span class="lineNum"> 3054</span>              :     { }; </span>
<span class="lineNum"> 3055</span>              :  </span>
<span class="lineNum"> 3056</span>              : #ifdef _GLIBCXX_USE_WCHAR_T </span>
<span class="lineNum"> 3057</span>              :   &#047;&#047;&#047; std::hash specialization for wstring. </span>
<span class="lineNum"> 3058</span>              :   template&lt;&gt; </span>
<span class="lineNum"> 3059</span>              :     struct hash&lt;wstring&gt; </span>
<span class="lineNum"> 3060</span>              :     : public __hash_base&lt;size_t, wstring&gt; </span>
<span class="lineNum"> 3061</span>              :     { </span>
<span class="lineNum"> 3062</span>              :       size_t </span>
<span class="lineNum"> 3063</span>              :       operator()(const wstring&amp; __s) const noexcept </span>
<span class="lineNum"> 3064</span>              :       { return std::_Hash_impl::hash(__s.data(), </span>
<span class="lineNum"> 3065</span>              :                                      __s.length() * sizeof(wchar_t)); } </span>
<span class="lineNum"> 3066</span>              :     }; </span>
<span class="lineNum"> 3067</span>              :  </span>
<span class="lineNum"> 3068</span>              :   template&lt;&gt; </span>
<span class="lineNum"> 3069</span>              :     struct __is_fast_hash&lt;hash&lt;wstring&gt;&gt; : std::false_type </span>
<span class="lineNum"> 3070</span>              :     { }; </span>
<span class="lineNum"> 3071</span>              : #endif </span>
<span class="lineNum"> 3072</span>              : #endif &#047;* _GLIBCXX_COMPATIBILITY_CXX0X *&#047; </span>
<span class="lineNum"> 3073</span>              :  </span>
<span class="lineNum"> 3074</span>              : #ifdef _GLIBCXX_USE_C99_STDINT_TR1 </span>
<span class="lineNum"> 3075</span>              :   &#047;&#047;&#047; std::hash specialization for u16string. </span>
<span class="lineNum"> 3076</span>              :   template&lt;&gt; </span>
<span class="lineNum"> 3077</span>              :     struct hash&lt;u16string&gt; </span>
<span class="lineNum"> 3078</span>              :     : public __hash_base&lt;size_t, u16string&gt; </span>
<span class="lineNum"> 3079</span>              :     { </span>
<span class="lineNum"> 3080</span>              :       size_t </span>
<span class="lineNum"> 3081</span>              :       operator()(const u16string&amp; __s) const noexcept </span>
<span class="lineNum"> 3082</span>              :       { return std::_Hash_impl::hash(__s.data(), </span>
<span class="lineNum"> 3083</span>              :                                      __s.length() * sizeof(char16_t)); } </span>
<span class="lineNum"> 3084</span>              :     }; </span>
<span class="lineNum"> 3085</span>              :  </span>
<span class="lineNum"> 3086</span>              :   template&lt;&gt; </span>
<span class="lineNum"> 3087</span>              :     struct __is_fast_hash&lt;hash&lt;u16string&gt;&gt; : std::false_type </span>
<span class="lineNum"> 3088</span>              :     { }; </span>
<span class="lineNum"> 3089</span>              :  </span>
<span class="lineNum"> 3090</span>              :   &#047;&#047;&#047; std::hash specialization for u32string. </span>
<span class="lineNum"> 3091</span>              :   template&lt;&gt; </span>
<span class="lineNum"> 3092</span>              :     struct hash&lt;u32string&gt; </span>
<span class="lineNum"> 3093</span>              :     : public __hash_base&lt;size_t, u32string&gt; </span>
<span class="lineNum"> 3094</span>              :     { </span>
<span class="lineNum"> 3095</span>              :       size_t </span>
<span class="lineNum"> 3096</span>              :       operator()(const u32string&amp; __s) const noexcept </span>
<span class="lineNum"> 3097</span>              :       { return std::_Hash_impl::hash(__s.data(), </span>
<span class="lineNum"> 3098</span>              :                                      __s.length() * sizeof(char32_t)); } </span>
<span class="lineNum"> 3099</span>              :     }; </span>
<span class="lineNum"> 3100</span>              :  </span>
<span class="lineNum"> 3101</span>              :   template&lt;&gt; </span>
<span class="lineNum"> 3102</span>              :     struct __is_fast_hash&lt;hash&lt;u32string&gt;&gt; : std::false_type </span>
<span class="lineNum"> 3103</span>              :     { }; </span>
<span class="lineNum"> 3104</span>              : #endif </span>
<span class="lineNum"> 3105</span>              :  </span>
<span class="lineNum"> 3106</span>              : _GLIBCXX_END_NAMESPACE_VERSION </span>
<span class="lineNum"> 3107</span>              : } &#047;&#047; namespace </span>
<span class="lineNum"> 3108</span>              :  </span>
<span class="lineNum"> 3109</span>              : #endif &#047;&#047; C++11 </span>
<span class="lineNum"> 3110</span>              :  </span>
<span class="lineNum"> 3111</span>              : #endif &#047;* _BASIC_STRING_H *&#047; </span>
</pre>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr><td class="versionInfo">Generated by: <a href="http://simonkagstrom.github.com/kcov/index.html">Kcov</a></td></tr>
</table>
<br/>
</body>
</html>
